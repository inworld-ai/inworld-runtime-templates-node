/**
 *
 * Note: This file is autogenerated and not intended to be modified manually.
 *
 */
import * as z from 'zod';
/**
 * Device Type
 *
 * Type of the device.
 *
 * Allowed values: "CPU", "CUDA", "Metal", "ROCm"
 *
 * Type: 'CPU' | 'CUDA' | 'Metal' | 'ROCm'.
 */
export declare const DeviceTypeSchema: z.ZodPipe<z.ZodUnion<readonly [z.ZodEnum<{
    CPU: "CPU";
    CUDA: "CUDA";
    Metal: "Metal";
    ROCm: "ROCm";
}>]>, z.ZodTransform<string, "CPU" | "CUDA" | "Metal" | "ROCm">>;
/**
 * Device Type
 *
 * Type of the device.
 *
 * Allowed values: "CPU", "CUDA", "Metal", "ROCm"
 *
 * Type: 'CPU' | 'CUDA' | 'Metal' | 'ROCm'.
 */
export type DeviceType = z.infer<typeof DeviceTypeSchema>;
/**
 * File Type
 *
 * Type of the file.
 *
 * Allowed values: "TYPE_UNSPECIFIED", "TYPE_PDF", "TYPE_TXT"
 *
 * Type: 'TYPE_UNSPECIFIED' | 'TYPE_PDF' | 'TYPE_TXT'.
 */
export declare const FileTypeSchema: z.ZodEnum<{
    TYPE_PDF: "TYPE_PDF";
    TYPE_TXT: "TYPE_TXT";
    TYPE_UNSPECIFIED: "TYPE_UNSPECIFIED";
}>;
/**
 * File Type
 *
 * Type of the file.
 *
 * Allowed values: "TYPE_UNSPECIFIED", "TYPE_PDF", "TYPE_TXT"
 *
 * Type: 'TYPE_UNSPECIFIED' | 'TYPE_PDF' | 'TYPE_TXT'.
 */
export type FileType = z.infer<typeof FileTypeSchema>;
/**
 * Image Detail
 *
 * Allowed values: "auto", "low", "high"
 *
 * Type: 'auto' | 'low' | 'high'.
 */
export declare const ImageDetailSchema: z.ZodPipe<z.ZodUnion<readonly [z.ZodEnum<{
    auto: "auto";
    high: "high";
    low: "low";
}>]>, z.ZodTransform<string, "auto" | "high" | "low">>;
/**
 * Image Detail
 *
 * Allowed values: "auto", "low", "high"
 *
 * Type: 'auto' | 'low' | 'high'.
 */
export type ImageDetail = z.infer<typeof ImageDetailSchema>;
/**
 * Effort
 *
 * Allowed values: "EFFORT_UNSPECIFIED", "EFFORT_NONE", "EFFORT_MINIMAL", "EFFORT_LOW", "EFFORT_MEDIUM", "EFFORT_HIGH", "EFFORT_XHIGH"
 *
 * Type: 'EFFORT_UNSPECIFIED' | 'EFFORT_NONE' | 'EFFORT_MINIMAL' | 'EFFORT_LOW' | 'EFFORT_MEDIUM' | 'EFFORT_HIGH' | 'EFFORT_XHIGH'.
 */
export declare const EffortSchema: z.ZodEnum<{
    EFFORT_HIGH: "EFFORT_HIGH";
    EFFORT_LOW: "EFFORT_LOW";
    EFFORT_MEDIUM: "EFFORT_MEDIUM";
    EFFORT_MINIMAL: "EFFORT_MINIMAL";
    EFFORT_NONE: "EFFORT_NONE";
    EFFORT_UNSPECIFIED: "EFFORT_UNSPECIFIED";
    EFFORT_XHIGH: "EFFORT_XHIGH";
}>;
/**
 * Effort
 *
 * Allowed values: "EFFORT_UNSPECIFIED", "EFFORT_NONE", "EFFORT_MINIMAL", "EFFORT_LOW", "EFFORT_MEDIUM", "EFFORT_HIGH", "EFFORT_XHIGH"
 *
 * Type: 'EFFORT_UNSPECIFIED' | 'EFFORT_NONE' | 'EFFORT_MINIMAL' | 'EFFORT_LOW' | 'EFFORT_MEDIUM' | 'EFFORT_HIGH' | 'EFFORT_XHIGH'.
 */
export type Effort = z.infer<typeof EffortSchema>;
/**
 * Response Format
 *
 * Optional response format specification
 *
 * Allowed values: "text", "json", "json_schema"
 *
 * Type: 'text' | 'json' | 'json_schema'.
 */
export declare const ResponseFormatSchema: z.ZodPipe<z.ZodUnion<readonly [z.ZodEnum<{
    text: "text";
    json: "json";
    json_schema: "json_schema";
}>]>, z.ZodTransform<string, "text" | "json" | "json_schema">>;
/**
 * Response Format
 *
 * Optional response format specification
 *
 * Allowed values: "text", "json", "json_schema"
 *
 * Type: 'text' | 'json' | 'json_schema'.
 */
export type ResponseFormat = z.infer<typeof ResponseFormatSchema>;
/**
 * Eleven Labs Output Format
 *
 * Output format.
 *
 * Allowed values: "ELEVENLABS_OUTPUT_FORMAT_UNSPECIFIED", "ELEVENLABS_OUTPUT_FORMAT_MP3_22050_32", "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_32", "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_64", "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_96", "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_128", "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_192"
 *
 * Type: 'ELEVENLABS_OUTPUT_FORMAT_UNSPECIFIED' | 'ELEVENLABS_OUTPUT_FORMAT_MP3_22050_32' | 'ELEVENLABS_OUTPUT_FORMAT_MP3_44100_32' | 'ELEVENLABS_OUTPUT_FORMAT_MP3_44100_64' | 'ELEVENLABS_OUTPUT_FORMAT_MP3_44100_96' | 'ELEVENLABS_OUTPUT_FORMAT_MP3_44100_128' | 'ELEVENLABS_OUTPUT_FORMAT_MP3_44100_192'.
 */
export declare const ElevenLabsOutputFormatSchema: z.ZodEnum<{
    ELEVENLABS_OUTPUT_FORMAT_MP3_22050_32: "ELEVENLABS_OUTPUT_FORMAT_MP3_22050_32";
    ELEVENLABS_OUTPUT_FORMAT_MP3_44100_128: "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_128";
    ELEVENLABS_OUTPUT_FORMAT_MP3_44100_192: "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_192";
    ELEVENLABS_OUTPUT_FORMAT_MP3_44100_32: "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_32";
    ELEVENLABS_OUTPUT_FORMAT_MP3_44100_64: "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_64";
    ELEVENLABS_OUTPUT_FORMAT_MP3_44100_96: "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_96";
    ELEVENLABS_OUTPUT_FORMAT_UNSPECIFIED: "ELEVENLABS_OUTPUT_FORMAT_UNSPECIFIED";
}>;
/**
 * Eleven Labs Output Format
 *
 * Output format.
 *
 * Allowed values: "ELEVENLABS_OUTPUT_FORMAT_UNSPECIFIED", "ELEVENLABS_OUTPUT_FORMAT_MP3_22050_32", "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_32", "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_64", "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_96", "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_128", "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_192"
 *
 * Type: 'ELEVENLABS_OUTPUT_FORMAT_UNSPECIFIED' | 'ELEVENLABS_OUTPUT_FORMAT_MP3_22050_32' | 'ELEVENLABS_OUTPUT_FORMAT_MP3_44100_32' | 'ELEVENLABS_OUTPUT_FORMAT_MP3_44100_64' | 'ELEVENLABS_OUTPUT_FORMAT_MP3_44100_96' | 'ELEVENLABS_OUTPUT_FORMAT_MP3_44100_128' | 'ELEVENLABS_OUTPUT_FORMAT_MP3_44100_192'.
 */
export type ElevenLabsOutputFormat = z.infer<typeof ElevenLabsOutputFormatSchema>;
/**
 * Eleven Labs Text Normalization
 *
 * Text normalization setting.
 *
 * Allowed values: "ELEVENLABS_TEXT_NORMALIZATION_UNSPECIFIED", "ELEVENLABS_TEXT_NORMALIZATION_AUTO", "ELEVENLABS_TEXT_NORMALIZATION_ON", "ELEVENLABS_TEXT_NORMALIZATION_OFF"
 *
 * Type: 'ELEVENLABS_TEXT_NORMALIZATION_UNSPECIFIED' | 'ELEVENLABS_TEXT_NORMALIZATION_AUTO' | 'ELEVENLABS_TEXT_NORMALIZATION_ON' | 'ELEVENLABS_TEXT_NORMALIZATION_OFF'.
 */
export declare const ElevenLabsTextNormalizationSchema: z.ZodEnum<{
    ELEVENLABS_TEXT_NORMALIZATION_AUTO: "ELEVENLABS_TEXT_NORMALIZATION_AUTO";
    ELEVENLABS_TEXT_NORMALIZATION_OFF: "ELEVENLABS_TEXT_NORMALIZATION_OFF";
    ELEVENLABS_TEXT_NORMALIZATION_ON: "ELEVENLABS_TEXT_NORMALIZATION_ON";
    ELEVENLABS_TEXT_NORMALIZATION_UNSPECIFIED: "ELEVENLABS_TEXT_NORMALIZATION_UNSPECIFIED";
}>;
/**
 * Eleven Labs Text Normalization
 *
 * Text normalization setting.
 *
 * Allowed values: "ELEVENLABS_TEXT_NORMALIZATION_UNSPECIFIED", "ELEVENLABS_TEXT_NORMALIZATION_AUTO", "ELEVENLABS_TEXT_NORMALIZATION_ON", "ELEVENLABS_TEXT_NORMALIZATION_OFF"
 *
 * Type: 'ELEVENLABS_TEXT_NORMALIZATION_UNSPECIFIED' | 'ELEVENLABS_TEXT_NORMALIZATION_AUTO' | 'ELEVENLABS_TEXT_NORMALIZATION_ON' | 'ELEVENLABS_TEXT_NORMALIZATION_OFF'.
 */
export type ElevenLabsTextNormalization = z.infer<typeof ElevenLabsTextNormalizationSchema>;
/**
 * Timestamp Type
 *
 * Optional type of timestamp alignment to return.
 *
 * Allowed values: "TIMESTAMP_TYPE_UNSPECIFIED", "TIMESTAMP_TYPE_WORD", "TIMESTAMP_TYPE_CHARACTER"
 *
 * Type: 'TIMESTAMP_TYPE_UNSPECIFIED' | 'TIMESTAMP_TYPE_WORD' | 'TIMESTAMP_TYPE_CHARACTER'.
 */
export declare const TimestampTypeSchema: z.ZodEnum<{
    TIMESTAMP_TYPE_CHARACTER: "TIMESTAMP_TYPE_CHARACTER";
    TIMESTAMP_TYPE_UNSPECIFIED: "TIMESTAMP_TYPE_UNSPECIFIED";
    TIMESTAMP_TYPE_WORD: "TIMESTAMP_TYPE_WORD";
}>;
/**
 * Timestamp Type
 *
 * Optional type of timestamp alignment to return.
 *
 * Allowed values: "TIMESTAMP_TYPE_UNSPECIFIED", "TIMESTAMP_TYPE_WORD", "TIMESTAMP_TYPE_CHARACTER"
 *
 * Type: 'TIMESTAMP_TYPE_UNSPECIFIED' | 'TIMESTAMP_TYPE_WORD' | 'TIMESTAMP_TYPE_CHARACTER'.
 */
export type TimestampType = z.infer<typeof TimestampTypeSchema>;
/**
 * Turn Status
 *
 * Detection result indicating whether the turn is complete or not.
 *
 * Allowed values: "Incomplete", "Complete"
 *
 * Type: 'Incomplete' | 'Complete'.
 */
export declare const TurnStatusSchema: z.ZodPipe<z.ZodUnion<readonly [z.ZodEnum<{
    Incomplete: "Incomplete";
    Complete: "Complete";
}>]>, z.ZodTransform<string, "Incomplete" | "Complete">>;
/**
 * Turn Status
 *
 * Detection result indicating whether the turn is complete or not.
 *
 * Allowed values: "Incomplete", "Complete"
 *
 * Type: 'Incomplete' | 'Complete'.
 */
export type TurnStatus = z.infer<typeof TurnStatusSchema>;
/**
 * Exporter Type
 *
 * Type of exporter to use.
 *
 * Allowed values: "EXPORTER_TYPE_UNSPECIFIED", "EXPORTER_TYPE_LOCAL", "EXPORTER_TYPE_REMOTE"
 *
 * Type: 'EXPORTER_TYPE_UNSPECIFIED' | 'EXPORTER_TYPE_LOCAL' | 'EXPORTER_TYPE_REMOTE'.
 */
export declare const ExporterTypeSchema: z.ZodEnum<{
    EXPORTER_TYPE_LOCAL: "EXPORTER_TYPE_LOCAL";
    EXPORTER_TYPE_REMOTE: "EXPORTER_TYPE_REMOTE";
    EXPORTER_TYPE_UNSPECIFIED: "EXPORTER_TYPE_UNSPECIFIED";
}>;
/**
 * Exporter Type
 *
 * Type of exporter to use.
 *
 * Allowed values: "EXPORTER_TYPE_UNSPECIFIED", "EXPORTER_TYPE_LOCAL", "EXPORTER_TYPE_REMOTE"
 *
 * Type: 'EXPORTER_TYPE_UNSPECIFIED' | 'EXPORTER_TYPE_LOCAL' | 'EXPORTER_TYPE_REMOTE'.
 */
export type ExporterType = z.infer<typeof ExporterTypeSchema>;
/**
 * Log Level
 *
 * Minimum log level to record.
 *
 * Allowed values: "LOG_LEVEL_UNSPECIFIED", "LOG_LEVEL_TRACE", "LOG_LEVEL_DEBUG", "LOG_LEVEL_INFO", "LOG_LEVEL_WARN", "LOG_LEVEL_ERROR"
 *
 * Type: 'LOG_LEVEL_UNSPECIFIED' | 'LOG_LEVEL_TRACE' | 'LOG_LEVEL_DEBUG' | 'LOG_LEVEL_INFO' | 'LOG_LEVEL_WARN' | 'LOG_LEVEL_ERROR'.
 */
export declare const LogLevelSchema: z.ZodEnum<{
    LOG_LEVEL_DEBUG: "LOG_LEVEL_DEBUG";
    LOG_LEVEL_ERROR: "LOG_LEVEL_ERROR";
    LOG_LEVEL_INFO: "LOG_LEVEL_INFO";
    LOG_LEVEL_TRACE: "LOG_LEVEL_TRACE";
    LOG_LEVEL_UNSPECIFIED: "LOG_LEVEL_UNSPECIFIED";
    LOG_LEVEL_WARN: "LOG_LEVEL_WARN";
}>;
/**
 * Log Level
 *
 * Minimum log level to record.
 *
 * Allowed values: "LOG_LEVEL_UNSPECIFIED", "LOG_LEVEL_TRACE", "LOG_LEVEL_DEBUG", "LOG_LEVEL_INFO", "LOG_LEVEL_WARN", "LOG_LEVEL_ERROR"
 *
 * Type: 'LOG_LEVEL_UNSPECIFIED' | 'LOG_LEVEL_TRACE' | 'LOG_LEVEL_DEBUG' | 'LOG_LEVEL_INFO' | 'LOG_LEVEL_WARN' | 'LOG_LEVEL_ERROR'.
 */
export type LogLevel = z.infer<typeof LogLevelSchema>;
/**
 * Metric Kind
 *
 * Kind of the metric (counter, gauge, or histogram).
 *
 * Allowed values: "METRIC_KIND_UNSPECIFIED", "METRIC_KIND_COUNTER", "METRIC_KIND_GAUGE", "METRIC_KIND_HISTOGRAM"
 *
 * Type: 'METRIC_KIND_UNSPECIFIED' | 'METRIC_KIND_COUNTER' | 'METRIC_KIND_GAUGE' | 'METRIC_KIND_HISTOGRAM'.
 */
export declare const MetricKindSchema: z.ZodEnum<{
    METRIC_KIND_COUNTER: "METRIC_KIND_COUNTER";
    METRIC_KIND_GAUGE: "METRIC_KIND_GAUGE";
    METRIC_KIND_HISTOGRAM: "METRIC_KIND_HISTOGRAM";
    METRIC_KIND_UNSPECIFIED: "METRIC_KIND_UNSPECIFIED";
}>;
/**
 * Metric Kind
 *
 * Kind of the metric (counter, gauge, or histogram).
 *
 * Allowed values: "METRIC_KIND_UNSPECIFIED", "METRIC_KIND_COUNTER", "METRIC_KIND_GAUGE", "METRIC_KIND_HISTOGRAM"
 *
 * Type: 'METRIC_KIND_UNSPECIFIED' | 'METRIC_KIND_COUNTER' | 'METRIC_KIND_GAUGE' | 'METRIC_KIND_HISTOGRAM'.
 */
export type MetricKind = z.infer<typeof MetricKindSchema>;
/**
 * Metric Value Type
 *
 * Value type of the metric (integer or double).
 *
 * Allowed values: "METRIC_VALUE_TYPE_UNSPECIFIED", "METRIC_VALUE_TYPE_INTEGER", "METRIC_VALUE_TYPE_DOUBLE"
 *
 * Type: 'METRIC_VALUE_TYPE_UNSPECIFIED' | 'METRIC_VALUE_TYPE_INTEGER' | 'METRIC_VALUE_TYPE_DOUBLE'.
 */
export declare const MetricValueTypeSchema: z.ZodEnum<{
    METRIC_VALUE_TYPE_DOUBLE: "METRIC_VALUE_TYPE_DOUBLE";
    METRIC_VALUE_TYPE_INTEGER: "METRIC_VALUE_TYPE_INTEGER";
    METRIC_VALUE_TYPE_UNSPECIFIED: "METRIC_VALUE_TYPE_UNSPECIFIED";
}>;
/**
 * Metric Value Type
 *
 * Value type of the metric (integer or double).
 *
 * Allowed values: "METRIC_VALUE_TYPE_UNSPECIFIED", "METRIC_VALUE_TYPE_INTEGER", "METRIC_VALUE_TYPE_DOUBLE"
 *
 * Type: 'METRIC_VALUE_TYPE_UNSPECIFIED' | 'METRIC_VALUE_TYPE_INTEGER' | 'METRIC_VALUE_TYPE_DOUBLE'.
 */
export type MetricValueType = z.infer<typeof MetricValueTypeSchema>;
/**
 * Span Kind
 *
 * Span kind
 *
 * Allowed values: "SPAN_KIND_UNSPECIFIED", "SPAN_KIND_INTERNAL", "SPAN_KIND_SERVER", "SPAN_KIND_CLIENT", "SPAN_KIND_PRODUCER", "SPAN_KIND_CONSUMER"
 *
 * Type: 'SPAN_KIND_UNSPECIFIED' | 'SPAN_KIND_INTERNAL' | 'SPAN_KIND_SERVER' | 'SPAN_KIND_CLIENT' | 'SPAN_KIND_PRODUCER' | 'SPAN_KIND_CONSUMER'.
 */
export declare const SpanKindSchema: z.ZodEnum<{
    SPAN_KIND_CLIENT: "SPAN_KIND_CLIENT";
    SPAN_KIND_CONSUMER: "SPAN_KIND_CONSUMER";
    SPAN_KIND_INTERNAL: "SPAN_KIND_INTERNAL";
    SPAN_KIND_PRODUCER: "SPAN_KIND_PRODUCER";
    SPAN_KIND_SERVER: "SPAN_KIND_SERVER";
    SPAN_KIND_UNSPECIFIED: "SPAN_KIND_UNSPECIFIED";
}>;
/**
 * Span Kind
 *
 * Span kind
 *
 * Allowed values: "SPAN_KIND_UNSPECIFIED", "SPAN_KIND_INTERNAL", "SPAN_KIND_SERVER", "SPAN_KIND_CLIENT", "SPAN_KIND_PRODUCER", "SPAN_KIND_CONSUMER"
 *
 * Type: 'SPAN_KIND_UNSPECIFIED' | 'SPAN_KIND_INTERNAL' | 'SPAN_KIND_SERVER' | 'SPAN_KIND_CLIENT' | 'SPAN_KIND_PRODUCER' | 'SPAN_KIND_CONSUMER'.
 */
export type SpanKind = z.infer<typeof SpanKindSchema>;
/**
 * Span Status
 *
 * Span status
 *
 * Allowed values: "SPAN_STATUS_UNSET", "SPAN_STATUS_OK", "SPAN_STATUS_ERROR"
 *
 * Type: 'SPAN_STATUS_UNSET' | 'SPAN_STATUS_OK' | 'SPAN_STATUS_ERROR'.
 */
export declare const SpanStatusSchema: z.ZodEnum<{
    SPAN_STATUS_ERROR: "SPAN_STATUS_ERROR";
    SPAN_STATUS_OK: "SPAN_STATUS_OK";
    SPAN_STATUS_UNSET: "SPAN_STATUS_UNSET";
}>;
/**
 * Span Status
 *
 * Span status
 *
 * Allowed values: "SPAN_STATUS_UNSET", "SPAN_STATUS_OK", "SPAN_STATUS_ERROR"
 *
 * Type: 'SPAN_STATUS_UNSET' | 'SPAN_STATUS_OK' | 'SPAN_STATUS_ERROR'.
 */
export type SpanStatus = z.infer<typeof SpanStatusSchema>;
/**
 * Credentials
 *
 * Credentials for authenticating with Inworld and third-party services.
 */
export declare const CredentialsSchema: z.ZodObject<{
    inworldApiKey: z.ZodOptional<z.ZodString>;
    inworldJwt: z.ZodOptional<z.ZodString>;
}, z.core.$strip>;
/**
 * Credentials
 *
 * Credentials for authenticating with Inworld and third-party services.
 *
 * @property {string} [inworldApiKey] - Optional API key for authenticating with Inworld services.
 * @property {string} [inworldJwt] - Optional JWT for authenticating with Inworld services.
 */
export type Credentials = z.infer<typeof CredentialsSchema>;
/**
 * Embed Response
 *
 * TextEmbedderInterface Response EmbedResponse returned by TextEmbedderInterface.Embed
 */
export declare const EmbedResponseSchema: z.ZodObject<{
    embedding: z.ZodArray<z.ZodNumber>;
}, z.core.$strip>;
/**
 * Embed Response
 *
 * TextEmbedderInterface Response EmbedResponse returned by TextEmbedderInterface.Embed
 *
 * @property {number[]} embedding - The embedding vector data.
 */
export type EmbedResponse = z.infer<typeof EmbedResponseSchema>;
/**
 * Embed Request
 *
 * TextEmbedderInterface Request EmbedRequest for TextEmbedderInterface.Embed
 */
export declare const EmbedRequestSchema: z.ZodObject<{
    credentials: z.ZodOptional<z.ZodObject<{
        inworldApiKey: z.ZodOptional<z.ZodString>;
        inworldJwt: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>>;
    text: z.ZodString;
}, z.core.$strip>;
/**
 * Embed Request
 *
 * TextEmbedderInterface Request EmbedRequest for TextEmbedderInterface.Embed
 *
 * @property {Credentials} [credentials] - Optional credentials for authenticating with embedding providers. Only used by remote/cloud embedders. Local embedders ignore this field.
 * @property {string} text - The text to embed.
 */
export type EmbedRequest = z.infer<typeof EmbedRequestSchema>;
/**
 * Device Selection
 *
 * DeviceSelection specifies a device by type and index.
 */
export declare const DeviceSelectionSchema: z.ZodObject<{
    index: z.ZodNumber;
    type: z.ZodPipe<z.ZodUnion<readonly [z.ZodEnum<{
        CPU: "CPU";
        CUDA: "CUDA";
        Metal: "Metal";
        ROCm: "ROCm";
    }>]>, z.ZodTransform<string, "CPU" | "CUDA" | "Metal" | "ROCm">>;
}, z.core.$strip>;
/**
 * Device Selection
 *
 * DeviceSelection specifies a device by type and index.
 *
 * @property {number} index - Index of the device.
 * @property {'CPU' | 'CUDA' | 'Metal' | 'ROCm'} type - Device Type. Type of the device.
 * @remarks type allowed values: "CPU", "CUDA", "Metal", "ROCm"
 */
export type DeviceSelection = z.infer<typeof DeviceSelectionSchema>;
/**
 * Remote Text Embedder Config
 *
 * RemoteTextEmbedderConfig specifies the parameters required to initialize a remote embedding model that interacts with the Inworld API.
 */
export declare const RemoteTextEmbedderConfigSchema: z.ZodObject<{
    apiKey: z.ZodString;
    defaultTimeout: z.ZodOptional<z.ZodString>;
    endpointOverride: z.ZodOptional<z.ZodString>;
    modelName: z.ZodString;
    provider: z.ZodString;
}, z.core.$strip>;
/**
 * Remote Text Embedder Config
 *
 * RemoteTextEmbedderConfig specifies the parameters required to initialize a remote embedding model that interacts with the Inworld API.
 *
 * @property {string} apiKey - Inworld API key for authentication.
 * @property {Duration} [defaultTimeout] - Default timeout for the request.
 * @property {string} [endpointOverride] - Endpoint override. If provided, it is used over any other configured endpoint.
 * @property {string} modelName - Name of the model to use.
 * @property {string} provider - Provider of the remote LLM.
 */
export type RemoteTextEmbedderConfig = z.infer<typeof RemoteTextEmbedderConfigSchema>;
/**
 * File
 *
 * File represents a file with its content and type.
 */
export declare const FileSchema: z.ZodObject<{
    content: z.ZodString;
    type: z.ZodEnum<{
        TYPE_PDF: "TYPE_PDF";
        TYPE_TXT: "TYPE_TXT";
        TYPE_UNSPECIFIED: "TYPE_UNSPECIFIED";
    }>;
}, z.core.$strip>;
/**
 * File
 *
 * File represents a file with its content and type.
 *
 * @property {string} content - File content as bytes (UTF-8 encoding).
 * @property {'TYPE_UNSPECIFIED' | 'TYPE_PDF' | 'TYPE_TXT'} type - File Type. Type of the file.
 * @remarks type allowed values: "TYPE_UNSPECIFIED", "TYPE_PDF", "TYPE_TXT"
 */
export type File = z.infer<typeof FileSchema>;
/**
 * Knowledge Records
 *
 * Wrapper for a list of knowledge records.
 */
export declare const KnowledgeRecordsSchema: z.ZodObject<{
    records: z.ZodOptional<z.ZodArray<z.ZodString>>;
}, z.core.$strip>;
/**
 * Knowledge Records
 *
 * Wrapper for a list of knowledge records.
 *
 * @property {string[]} [records] - List of knowledge record strings.
 */
export type KnowledgeRecords = z.infer<typeof KnowledgeRecordsSchema>;
/**
 * Compile Knowledge Response
 *
 * CompileKnowledgeResponse containing compiled knowledge records.
 */
export declare const CompileKnowledgeResponseSchema: z.ZodObject<{
    records: z.ZodOptional<z.ZodArray<z.ZodString>>;
}, z.core.$strip>;
/**
 * Compile Knowledge Response
 *
 * CompileKnowledgeResponse containing compiled knowledge records.
 *
 * @property {string[]} [records] - Compiled knowledge records.
 */
export type CompileKnowledgeResponse = z.infer<typeof CompileKnowledgeResponseSchema>;
/**
 * Retrieval Config
 *
 * RetrievalConfig represents the configuration for retrieving knowledge.
 */
export declare const RetrievalConfigSchema: z.ZodObject<{
    threshold: z.ZodNumber;
    topK: z.ZodNumber;
}, z.core.$strip>;
/**
 * Retrieval Config
 *
 * RetrievalConfig represents the configuration for retrieving knowledge.
 *
 * @property {number} threshold - The minimum relevance score for retrieval.
 * @property {number} topK - The maximum number of records to retrieve.
 */
export type RetrievalConfig = z.infer<typeof RetrievalConfigSchema>;
/**
 * Get Knowledge Response
 *
 * GetKnowledgeResponse containing retrieved knowledge records.
 */
export declare const GetKnowledgeResponseSchema: z.ZodObject<{
    records: z.ZodOptional<z.ZodArray<z.ZodString>>;
}, z.core.$strip>;
/**
 * Get Knowledge Response
 *
 * GetKnowledgeResponse containing retrieved knowledge records.
 *
 * @property {string[]} [records] - Retrieved knowledge records.
 */
export type GetKnowledgeResponse = z.infer<typeof GetKnowledgeResponseSchema>;
/**
 * Parsing Config
 *
 * ParsingConfig defines the configuration for parsing documents into chunks.
 */
export declare const ParsingConfigSchema: z.ZodObject<{
    maxCharsPerChunk: z.ZodNumber;
    maxChunksPerDocument: z.ZodNumber;
}, z.core.$strip>;
/**
 * Parsing Config
 *
 * ParsingConfig defines the configuration for parsing documents into chunks.
 *
 * @property {number} maxCharsPerChunk - Maximum number of characters per chunk.
 * @property {number} maxChunksPerDocument - Maximum number of chunks per document.
 */
export type ParsingConfig = z.infer<typeof ParsingConfigSchema>;
/**
 * Language
 *
 * Language represents a language with optional locale.
 */
export declare const LanguageSchema: z.ZodObject<{
    code: z.ZodString;
    locale: z.ZodOptional<z.ZodString>;
}, z.core.$strip>;
/**
 * Language
 *
 * Language represents a language with optional locale.
 *
 * @property {string} code - Language code (e.g., "en", "es", "fr").
 * @property {string} [locale] - Optional locale (e.g., "US", "GB", "MX").
 */
export type Language = z.infer<typeof LanguageSchema>;
/**
 * Remove Knowledge Request
 *
 * RemoveKnowledgeRequest for KnowledgeInterface.RemoveKnowledge
 */
export declare const RemoveKnowledgeRequestSchema: z.ZodObject<{
    credentials: z.ZodOptional<z.ZodObject<{
        inworldApiKey: z.ZodOptional<z.ZodString>;
        inworldJwt: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>>;
    knowledgeId: z.ZodString;
}, z.core.$strip>;
/**
 * Remove Knowledge Request
 *
 * RemoveKnowledgeRequest for KnowledgeInterface.RemoveKnowledge
 *
 * @property {Credentials} [credentials] - Optional credentials for authenticating with remote knowledge services. Only used by remote knowledge clients. Local clients ignore this field.
 * @property {string} knowledgeId - Knowledge ID to remove.
 */
export type RemoveKnowledgeRequest = z.infer<typeof RemoveKnowledgeRequestSchema>;
/**
 * Logit Bias
 *
 * LogitBias modifies the likelihood of specified tokens appearing in the completion.
 */
export declare const LogitBiasSchema: z.ZodObject<{
    biasValue: z.ZodNumber;
    tokenId: z.ZodString;
}, z.core.$strip>;
/**
 * Logit Bias
 *
 * LogitBias modifies the likelihood of specified tokens appearing in the completion.
 *
 * @property {number} biasValue
 * @property {string} tokenId
 */
export type LogitBias = z.infer<typeof LogitBiasSchema>;
/**
 * Image Url
 *
 * ImageUrl represents an image URL with detail level specification.
 */
export declare const ImageUrlSchema: z.ZodObject<{
    detail: z.ZodOptional<z.ZodPipe<z.ZodUnion<readonly [z.ZodEnum<{
        auto: "auto";
        high: "high";
        low: "low";
    }>]>, z.ZodTransform<string, "auto" | "high" | "low">>>;
    url: z.ZodString;
}, z.core.$strip>;
/**
 * Image Url
 *
 * ImageUrl represents an image URL with detail level specification.
 *
 * @property {'auto' | 'low' | 'high'} [detail] - Image Detail
 * @remarks detail allowed values: "auto", "low", "high"
 * @property {string} url
 */
export type ImageUrl = z.infer<typeof ImageUrlSchema>;
/**
 * Tool Call
 *
 * ToolCall represents a tool call made by the model.
 */
export declare const ToolCallSchema: z.ZodObject<{
    args: z.ZodOptional<z.ZodString>;
    id: z.ZodString;
    name: z.ZodString;
}, z.core.$strip>;
/**
 * Tool Call
 *
 * ToolCall represents a tool call made by the model.
 *
 * @property {string} [args]
 * @property {string} id
 * @property {string} name
 */
export type ToolCall = z.infer<typeof ToolCallSchema>;
/**
 * Reasoning Config
 *
 * ReasoningConfig for models that support chain-of-thought reasoning. Provides a unified interface across different providers (OpenAI, Anthropic, Google, Groq, etc.).
 */
export declare const ReasoningConfigSchema: z.ZodObject<{
    effort: z.ZodOptional<z.ZodEnum<{
        EFFORT_HIGH: "EFFORT_HIGH";
        EFFORT_LOW: "EFFORT_LOW";
        EFFORT_MEDIUM: "EFFORT_MEDIUM";
        EFFORT_MINIMAL: "EFFORT_MINIMAL";
        EFFORT_NONE: "EFFORT_NONE";
        EFFORT_UNSPECIFIED: "EFFORT_UNSPECIFIED";
        EFFORT_XHIGH: "EFFORT_XHIGH";
    }>>;
    exclude: z.ZodOptional<z.ZodBoolean>;
    maxTokens: z.ZodOptional<z.ZodNumber>;
}, z.core.$strip>;
/**
 * Reasoning Config
 *
 * ReasoningConfig for models that support chain-of-thought reasoning. Provides a unified interface across different providers (OpenAI, Anthropic, Google, Groq, etc.).
 *
 * @property {'EFFORT_UNSPECIFIED' | 'EFFORT_NONE' | 'EFFORT_MINIMAL' | 'EFFORT_LOW' | 'EFFORT_MEDIUM' | 'EFFORT_HIGH' | 'EFFORT_XHIGH'} [effort] - Effort
 * @remarks effort allowed values: "EFFORT_UNSPECIFIED", "EFFORT_NONE", "EFFORT_MINIMAL", "EFFORT_LOW", "EFFORT_MEDIUM", "EFFORT_HIGH", "EFFORT_XHIGH"
 * @property {boolean} [exclude] - Whether to exclude reasoning tokens from the response. When true, the model still uses reasoning internally but doesn't return it. Default is false (reasoning is included in response if available).
 * @property {number} [maxTokens] - Maximum number of tokens to use for reasoning. Anthropic/Google-style control. Takes precedence over effort when specified. For providers that only support effort levels, this is converted to the appropriate level.
 */
export type ReasoningConfig = z.infer<typeof ReasoningConfigSchema>;
/**
 * Function Choice
 *
 * FunctionChoice represents a specific function to be called.
 */
export declare const FunctionChoiceSchema: z.ZodObject<{
    name: z.ZodString;
    type: z.ZodString;
}, z.core.$strip>;
/**
 * Function Choice
 *
 * FunctionChoice represents a specific function to be called.
 *
 * @property {string} name
 * @property {string} type
 */
export type FunctionChoice = z.infer<typeof FunctionChoiceSchema>;
/**
 * Tool
 *
 * Tool represents a tool that the model may call.
 */
export declare const ToolSchema: z.ZodObject<{
    description: z.ZodString;
    name: z.ZodString;
    properties: z.ZodPipe<z.ZodUnion<readonly [z.ZodString, z.ZodRecord<z.ZodString, z.ZodAny>]>, z.ZodTransform<string, string | Record<string, any>>>;
}, z.core.$strip>;
/**
 * Tool
 *
 * Tool represents a tool that the model may call.
 *
 * @property {string} description
 * @property {string} name
 * @property {string} [properties]
 */
export type Tool = z.infer<typeof ToolSchema>;
/**
 * Get Models Request
 *
 * GetModelsRequest for LLMInterface.GetModels
 */
export declare const GetModelsRequestSchema: z.ZodObject<{
    credentials: z.ZodOptional<z.ZodObject<{
        inworldApiKey: z.ZodOptional<z.ZodString>;
        inworldJwt: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>>;
    modelName: z.ZodOptional<z.ZodString>;
    provider: z.ZodOptional<z.ZodString>;
}, z.core.$strip>;
/**
 * Get Models Request
 *
 * GetModelsRequest for LLMInterface.GetModels
 *
 * @property {Credentials} [credentials] - Optional credentials for authenticating with remote LLM providers.
 * @property {string} [modelName] - Optional filter by model name
 * @property {string} [provider] - Optional filter by provider name
 */
export type GetModelsRequest = z.infer<typeof GetModelsRequestSchema>;
/**
 * LLM Benchmarks
 *
 * Benchmark scores for LLM model capabilities
 */
export declare const LLMBenchmarksSchema: z.ZodObject<{
    codingIndex: z.ZodOptional<z.ZodNumber>;
    intelligenceIndex: z.ZodOptional<z.ZodNumber>;
    mathIndex: z.ZodOptional<z.ZodNumber>;
}, z.core.$strip>;
/**
 * LLM Benchmarks
 *
 * Benchmark scores for LLM model capabilities
 *
 * @property {number} [codingIndex] - Coding benchmark score
 * @property {number} [intelligenceIndex] - Intelligence benchmark score
 * @property {number} [mathIndex] - Math benchmark score
 */
export type LLMBenchmarks = z.infer<typeof LLMBenchmarksSchema>;
/**
 * Model Id
 *
 * ModelId represents the identifier for an LLM model.
 */
export declare const ModelIdSchema: z.ZodObject<{
    modelName: z.ZodOptional<z.ZodString>;
    provider: z.ZodString;
}, z.core.$strip>;
/**
 * Model Id
 *
 * ModelId represents the identifier for an LLM model.
 *
 * @property {string} [modelName] - The name of the model
 * @property {string} provider - The provider of the model
 */
export type ModelId = z.infer<typeof ModelIdSchema>;
/**
 * LLM Performance
 *
 * Performance metrics for LLM model latency and throughput
 */
export declare const LLMPerformanceSchema: z.ZodObject<{
    medianOutputTokensPerSecond: z.ZodOptional<z.ZodNumber>;
    medianTimeToFirstAnswerToken: z.ZodOptional<z.ZodNumber>;
    medianTimeToFirstTokenSeconds: z.ZodOptional<z.ZodNumber>;
}, z.core.$strip>;
/**
 * LLM Performance
 *
 * Performance metrics for LLM model latency and throughput
 *
 * @property {number} [medianOutputTokensPerSecond] - Median number of tokens received per second, after the first token
 * @property {number} [medianTimeToFirstAnswerToken] - Median time in seconds to receive the first answer token (after reasoning)
 * @property {number} [medianTimeToFirstTokenSeconds] - Median time in seconds to receive the first token
 */
export type LLMPerformance = z.infer<typeof LLMPerformanceSchema>;
/**
 * LLM Pricing
 *
 * Pricing information for LLM model usage
 */
export declare const LLMPricingSchema: z.ZodObject<{
    completion: z.ZodOptional<z.ZodNumber>;
    image: z.ZodOptional<z.ZodNumber>;
    internalReasoning: z.ZodOptional<z.ZodNumber>;
    prompt: z.ZodOptional<z.ZodNumber>;
    request: z.ZodOptional<z.ZodNumber>;
    webSearch: z.ZodOptional<z.ZodNumber>;
}, z.core.$strip>;
/**
 * LLM Pricing
 *
 * Pricing information for LLM model usage
 *
 * @property {number} [completion] - Price per output token in USD
 * @property {number} [image] - Price per image input in USD
 * @property {number} [internalReasoning] - Price for internal reasoning tokens in USD
 * @property {number} [prompt] - Price per input token in USD
 * @property {number} [request] - Price per API request in USD
 * @property {number} [webSearch] - Price per web search operation in USD
 */
export type LLMPricing = z.infer<typeof LLMPricingSchema>;
/**
 * LLM Spec
 *
 * LLM model specifications and capabilities
 */
export declare const LLMSpecSchema: z.ZodObject<{
    contextLength: z.ZodOptional<z.ZodNumber>;
    description: z.ZodOptional<z.ZodString>;
    inputModalities: z.ZodOptional<z.ZodArray<z.ZodString>>;
    maxCompletionTokens: z.ZodOptional<z.ZodNumber>;
    outputModalities: z.ZodOptional<z.ZodArray<z.ZodString>>;
    supportedParameters: z.ZodOptional<z.ZodArray<z.ZodString>>;
}, z.core.$strip>;
/**
 * LLM Spec
 *
 * LLM model specifications and capabilities
 *
 * @property {number} [contextLength] - Maximum context length in tokens
 * @property {string} [description] - Model description
 * @property {string[]} [inputModalities] - Supported input modalities (e.g., "text", "image", "audio")
 * @property {number} [maxCompletionTokens] - Maximum completion tokens
 * @property {string[]} [outputModalities] - Supported output modalities (e.g., "text", "image", "audio")
 * @property {string[]} [supportedParameters] - Supported parameters (e.g., "temperature", "top_p", "max_tokens")
 */
export type LLMSpec = z.infer<typeof LLMSpecSchema>;
/**
 * Tool Call Result
 *
 * ToolCallResult represents the result of a tool call.
 */
export declare const ToolCallResultSchema: z.ZodObject<{
    result: z.ZodString;
}, z.core.$strip>;
/**
 * Tool Call Result
 *
 * ToolCallResult represents the result of a tool call.
 *
 * @property {string} result
 */
export type ToolCallResult = z.infer<typeof ToolCallResultSchema>;
/**
 * Tool List
 *
 * ToolList represents a list of tools.
 */
export declare const ToolListSchema: z.ZodObject<{
    tools: z.ZodArray<z.ZodObject<{
        description: z.ZodString;
        name: z.ZodString;
        properties: z.ZodPipe<z.ZodUnion<readonly [z.ZodString, z.ZodRecord<z.ZodString, z.ZodAny>]>, z.ZodTransform<string, string | Record<string, any>>>;
    }, z.core.$strip>>;
}, z.core.$strip>;
/**
 * Tool List
 *
 * ToolList represents a list of tools.
 *
 * @property {Tool[]} tools
 */
export type ToolList = z.infer<typeof ToolListSchema>;
/**
 * MCP Http Config
 *
 * MCPHttpConfig configuration for creating an MCP client that communicates over HTTP.
 */
export declare const MCPHttpConfigSchema: z.ZodObject<{
    apiKey: z.ZodString;
    defaultTimeout: z.ZodOptional<z.ZodString>;
}, z.core.$strip>;
/**
 * MCP Http Config
 *
 * MCPHttpConfig configuration for creating an MCP client that communicates over HTTP.
 *
 * @property {string} apiKey - The API key for authentication.
 * @property {Duration} [defaultTimeout] - Default timeout for the request.
 */
export type MCPHttpConfig = z.infer<typeof MCPHttpConfigSchema>;
/**
 * Paragon Api Config
 *
 * ParagonApiConfig configuration for creating an MCP client that communicates with the Paragon API.
 */
export declare const ParagonApiConfigSchema: z.ZodObject<{
    defaultTimeout: z.ZodOptional<z.ZodString>;
    jwtToken: z.ZodString;
}, z.core.$strip>;
/**
 * Paragon Api Config
 *
 * ParagonApiConfig configuration for creating an MCP client that communicates with the Paragon API.
 *
 * @property {Duration} [defaultTimeout] - Default timeout for the request.
 * @property {string} jwtToken - The JWT token for authentication.
 */
export type ParagonApiConfig = z.infer<typeof ParagonApiConfigSchema>;
/**
 * MCP Stdio Config
 *
 * MCPStdioConfig configuration for creating an MCP client that communicates over stdio.
 */
export declare const MCPStdioConfigSchema: z.ZodObject<{
    env: z.ZodRecord<z.ZodString, z.ZodString>;
}, z.core.$strip>;
/**
 * MCP Stdio Config
 *
 * MCPStdioConfig configuration for creating an MCP client that communicates over stdio.
 *
 * @property {Record<string, unknown>} env - Environment variables to set for the subprocess.
 */
export type MCPStdioConfig = z.infer<typeof MCPStdioConfigSchema>;
/**
 * Class Threshold
 *
 * ClassThreshold represents a class with its detection threshold.
 */
export declare const ClassThresholdSchema: z.ZodObject<{
    classLabel: z.ZodString;
    threshold: z.ZodNumber;
}, z.core.$strip>;
/**
 * Class Threshold
 *
 * ClassThreshold represents a class with its detection threshold.
 *
 * @property {string} classLabel - The class label to detect.
 * @property {number} threshold - Threshold value (0.0 to 1.0) for detection sensitivity.
 */
export type ClassThreshold = z.infer<typeof ClassThresholdSchema>;
/**
 * Classify Text Response
 *
 * ClassifyTextResponse response from a text classification operation.
 */
export declare const ClassifyTextResponseSchema: z.ZodObject<{
    classes: z.ZodArray<z.ZodString>;
}, z.core.$strip>;
/**
 * Classify Text Response
 *
 * ClassifyTextResponse response from a text classification operation.
 *
 * @property {string[]} classes - List of class labels that exceeded their thresholds. If empty, no classes were assigned to the input text.
 */
export type ClassifyTextResponse = z.infer<typeof ClassifyTextResponseSchema>;
/**
 * Entity Match
 *
 * EntityMatch a structure that describes a single occurrence of an entity in text.
 */
export declare const EntityMatchSchema: z.ZodObject<{
    entityName: z.ZodString;
    ruleName: z.ZodString;
    text: z.ZodString;
}, z.core.$strip>;
/**
 * Entity Match
 *
 * EntityMatch a structure that describes a single occurrence of an entity in text.
 *
 * @property {string} entityName - ID of the matched entity.
 * @property {string} ruleName - Value of the entity.
 * @property {string} text - Text that matched the rule.
 */
export type EntityMatch = z.infer<typeof EntityMatchSchema>;
/**
 * Intent
 *
 * Intent represents an intent with a name and a list of training phrases.
 */
export declare const IntentSchema: z.ZodObject<{
    name: z.ZodString;
    phrases: z.ZodArray<z.ZodString>;
}, z.core.$strip>;
/**
 * Intent
 *
 * Intent represents an intent with a name and a list of training phrases.
 *
 * @property {string} name - Unique identifier for the intent.
 * @property {string[]} phrases - List of example phrases that represent this intent.
 */
export type Intent = z.infer<typeof IntentSchema>;
/**
 * Embedding Matcher Config
 *
 * EmbeddingMatcherConfig configuration for embedding-based intent matching.
 */
export declare const EmbeddingMatcherConfigSchema: z.ZodObject<{
    similarityThreshold: z.ZodNumber;
}, z.core.$strip>;
/**
 * Embedding Matcher Config
 *
 * EmbeddingMatcherConfig configuration for embedding-based intent matching.
 *
 * @property {number} similarityThreshold - Similarity threshold for embedding-based matching.
 */
export type EmbeddingMatcherConfig = z.infer<typeof EmbeddingMatcherConfigSchema>;
/**
 * Keyword Group
 *
 * KeywordGroup represents a named group of keywords.
 */
export declare const KeywordGroupSchema: z.ZodObject<{
    keywords: z.ZodArray<z.ZodString>;
    name: z.ZodString;
}, z.core.$strip>;
/**
 * Keyword Group
 *
 * KeywordGroup represents a named group of keywords.
 *
 * @property {string[]} keywords - List of keywords to match.
 * @property {string} name - Unique name for this keyword group.
 */
export type KeywordGroup = z.infer<typeof KeywordGroupSchema>;
/**
 * Keyword Match
 *
 * KeywordMatch information about a matched keyword.
 */
export declare const KeywordMatchSchema: z.ZodObject<{
    groupName: z.ZodString;
    keyword: z.ZodString;
}, z.core.$strip>;
/**
 * Keyword Match
 *
 * KeywordMatch information about a matched keyword.
 *
 * @property {string} groupName - Name of the keyword group that matched.
 * @property {string} keyword - The keyword that was matched.
 */
export type KeywordMatch = z.infer<typeof KeywordMatchSchema>;
/**
 * Dictionary Rule
 *
 * DictionaryRule a rule that defines a custom entity and its variations.
 */
export declare const DictionaryRuleSchema: z.ZodObject<{
    displayName: z.ZodString;
    name: z.ZodString;
    synonyms: z.ZodOptional<z.ZodArray<z.ZodString>>;
}, z.core.$strip>;
/**
 * Dictionary Rule
 *
 * DictionaryRule a rule that defines a custom entity and its variations.
 *
 * @property {string} displayName - Display name of the rule in natural language.
 * @property {string} name - Unique ID of the rule.
 * @property {string[]} [synonyms] - List of synonyms for the rule.
 */
export type DictionaryRule = z.infer<typeof DictionaryRuleSchema>;
/**
 * Text Classifier Creation Config
 *
 * TextClassifierCreationConfig configuration for creating a text classifier.
 */
export declare const TextClassifierCreationConfigSchema: z.ZodObject<{
    modelWeightsPath: z.ZodString;
    supportedClasses: z.ZodArray<z.ZodString>;
}, z.core.$strip>;
/**
 * Text Classifier Creation Config
 *
 * TextClassifierCreationConfig configuration for creating a text classifier.
 *
 * @property {string} modelWeightsPath - Path to the trained model weights file.
 * @property {string[]} supportedClasses - Classes that the model was trained to classify.
 */
export type TextClassifierCreationConfig = z.infer<typeof TextClassifierCreationConfigSchema>;
/**
 * Device Info
 *
 * DeviceInfo contains information about a device at a given point in time.
 */
export declare const DeviceInfoSchema: z.ZodObject<{
    freeMemoryBytes: z.ZodNumber;
    name: z.ZodString;
    timestamp: z.ZodCoercedDate<unknown>;
    totalMemoryBytes: z.ZodNumber;
}, z.core.$strip>;
/**
 * Device Info
 *
 * DeviceInfo contains information about a device at a given point in time.
 *
 * @property {number} freeMemoryBytes - Free memory in bytes.
 * @property {string} name - Name of the device, e.g. "Apple M3" or "NVIDIA A100".
 * @property {Timestamp} timestamp - Timestamp of the snapshot taken.
 * @property {number} totalMemoryBytes - Total memory in bytes.
 */
export type DeviceInfo = z.infer<typeof DeviceInfoSchema>;
export declare const GoogleSerperApiClientCreationConfigSchema: z.ZodObject<{
    apiEndpoint: z.ZodOptional<z.ZodString>;
    apiKey: z.ZodString;
    defaultTimeout: z.ZodOptional<z.ZodString>;
}, z.core.$strip>;
export type GoogleSerperApiClientCreationConfig = z.infer<typeof GoogleSerperApiClientCreationConfigSchema>;
/**
 * Google Serper Api Search Request
 *
 * GoogleSerperApiSearchRequest for GoogleSerperAPIClientInterface.Search
 */
export declare const GoogleSerperApiSearchRequestSchema: z.ZodObject<{
    autocorrection: z.ZodOptional<z.ZodBoolean>;
    country: z.ZodOptional<z.ZodString>;
    dateRange: z.ZodOptional<z.ZodString>;
    language: z.ZodOptional<z.ZodString>;
    numResults: z.ZodOptional<z.ZodNumber>;
    page: z.ZodOptional<z.ZodNumber>;
    query: z.ZodString;
}, z.core.$strip>;
/**
 * Google Serper Api Search Request
 *
 * GoogleSerperApiSearchRequest for GoogleSerperAPIClientInterface.Search
 *
 * @property {boolean} [autocorrection] - The auto correction flag
 * @property {string} [country] - The country code for localized results
 * @property {string} [dateRange] - The date range filter
 * @property {string} [language] - The language code for search results
 * @property {number} [numResults] - The number of results to return per page
 * @property {number} [page] - The page number for pagination
 * @property {string} query - The search query string
 */
export type GoogleSerperApiSearchRequest = z.infer<typeof GoogleSerperApiSearchRequestSchema>;
/**
 * Knowledge Graph
 *
 * Represents knowledge graph information from search results
 */
export declare const KnowledgeGraphSchema: z.ZodObject<{
    attributes: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
    description: z.ZodOptional<z.ZodString>;
    descriptionLink: z.ZodOptional<z.ZodString>;
    descriptionSource: z.ZodOptional<z.ZodString>;
    imageUrl: z.ZodOptional<z.ZodString>;
    title: z.ZodOptional<z.ZodString>;
    type: z.ZodOptional<z.ZodString>;
    website: z.ZodOptional<z.ZodString>;
}, z.core.$strip>;
/**
 * Knowledge Graph
 *
 * Represents knowledge graph information from search results
 *
 * @property {Record<string, unknown>} [attributes] - Additional attributes as key-value pairs
 * @property {string} [description] - The entity's description
 * @property {string} [descriptionLink] - The link to the description source
 * @property {string} [descriptionSource] - Description source of the entity
 * @property {string} [imageUrl] - URL of the entity's image
 * @property {string} [title] - The title of the knowledge graph entity
 * @property {string} [type] - The type of entity (e.g., "Person", "Place", "Organization")
 * @property {string} [website] - The URL of the entity's website
 */
export type KnowledgeGraph = z.infer<typeof KnowledgeGraphSchema>;
/**
 * Sitelink
 *
 * Represents a sitelink with title and URL
 */
export declare const SitelinkSchema: z.ZodObject<{
    link: z.ZodOptional<z.ZodString>;
    title: z.ZodOptional<z.ZodString>;
}, z.core.$strip>;
/**
 * Sitelink
 *
 * Represents a sitelink with title and URL
 *
 * @property {string} [link] - The URL of the sitelink
 * @property {string} [title] - The title/text of the sitelink
 */
export type Sitelink = z.infer<typeof SitelinkSchema>;
/**
 * People Also Ask
 *
 * Represents a "People Also Ask" question and answer
 */
export declare const PeopleAlsoAskSchema: z.ZodObject<{
    link: z.ZodOptional<z.ZodString>;
    question: z.ZodOptional<z.ZodString>;
    snippet: z.ZodOptional<z.ZodString>;
    title: z.ZodOptional<z.ZodString>;
}, z.core.$strip>;
/**
 * People Also Ask
 *
 * Represents a "People Also Ask" question and answer
 *
 * @property {string} [link] - The source URL
 * @property {string} [question] - The question text
 * @property {string} [snippet] - The answer snippet
 * @property {string} [title] - The source title
 */
export type PeopleAlsoAsk = z.infer<typeof PeopleAlsoAskSchema>;
/**
 * Top Story
 *
 * Represents a top story
 */
export declare const TopStorySchema: z.ZodObject<{
    date: z.ZodOptional<z.ZodString>;
    link: z.ZodOptional<z.ZodString>;
    source: z.ZodOptional<z.ZodString>;
    title: z.ZodOptional<z.ZodString>;
}, z.core.$strip>;
/**
 * Top Story
 *
 * Represents a top story
 *
 * @property {string} [date] - Date of the top story
 * @property {string} [link] - The URL of the top story
 * @property {string} [source] - Source of the story
 * @property {string} [title] - The title of the top story
 */
export type TopStory = z.infer<typeof TopStorySchema>;
/**
 * Acoustic Echo Cancellation Config
 *
 * AcousticEchoCancellationConfig for AEC filtering behavior.
 *
 * Type: Record<string, unknown>.
 */
export declare const AcousticEchoCancellationConfigSchema: z.ZodObject<{}, z.core.$strip>;
/**
 * Acoustic Echo Cancellation Config
 *
 * AcousticEchoCancellationConfig for AEC filtering behavior.
 *
 * Type: Record<string, unknown>.
 */
export type AcousticEchoCancellationConfig = z.infer<typeof AcousticEchoCancellationConfigSchema>;
/**
 * Voice Activity Detection Config
 *
 * VoiceActivityDetectionConfig specifies VAD model parameters.
 */
export declare const VoiceActivityDetectionConfigSchema: z.ZodObject<{
    speechThreshold: z.ZodNumber;
}, z.core.$strip>;
/**
 * Voice Activity Detection Config
 *
 * VoiceActivityDetectionConfig specifies VAD model parameters.
 *
 * @property {number} speechThreshold - Sensitivity threshold for detecting speech. Defaults to 0.4.
 */
export type VoiceActivityDetectionConfig = z.infer<typeof VoiceActivityDetectionConfigSchema>;
/**
 * Audio Chunk Timestamp
 *
 * AudioChunkTimestamp represents timing information for a token in audio.
 */
export declare const AudioChunkTimestampSchema: z.ZodObject<{
    endTime: z.ZodNumber;
    startTime: z.ZodNumber;
    token: z.ZodString;
}, z.core.$strip>;
/**
 * Audio Chunk Timestamp
 *
 * AudioChunkTimestamp represents timing information for a token in audio.
 *
 * @property {number} endTime - End time of the token relative to chunk start (in seconds).
 * @property {number} startTime - Start time of the token relative to chunk start (in seconds).
 * @property {string} token - The token text (word or character).
 */
export type AudioChunkTimestamp = z.infer<typeof AudioChunkTimestampSchema>;
/**
 * Turn Detection Config
 *
 * TurnDetectionConfig specifies turn detection model parameters.
 */
export declare const TurnDetectionConfigSchema: z.ZodObject<{
    threshold: z.ZodNumber;
}, z.core.$strip>;
/**
 * Turn Detection Config
 *
 * TurnDetectionConfig specifies turn detection model parameters.
 *
 * @property {number} threshold - Probability threshold for turn completion (0.0 to 1.0).
 */
export type TurnDetectionConfig = z.infer<typeof TurnDetectionConfigSchema>;
/**
 * Speech Recognition Config
 *
 * SpeechRecognitionConfig specifies STT model parameters.
 */
export declare const SpeechRecognitionConfigSchema: z.ZodObject<{
    language: z.ZodOptional<z.ZodString>;
}, z.core.$strip>;
/**
 * Speech Recognition Config
 *
 * SpeechRecognitionConfig specifies STT model parameters.
 *
 * @property {string} [language] - Optional language for speech recognition.
 */
export type SpeechRecognitionConfig = z.infer<typeof SpeechRecognitionConfigSchema>;
export declare const LocalSttConfigSchema: z.ZodObject<{
    defaultConfig: z.ZodObject<{
        language: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>;
    device: z.ZodObject<{
        index: z.ZodNumber;
        type: z.ZodPipe<z.ZodUnion<readonly [z.ZodEnum<{
            CPU: "CPU";
            CUDA: "CUDA";
            Metal: "Metal";
            ROCm: "ROCm";
        }>]>, z.ZodTransform<string, "CPU" | "CUDA" | "Metal" | "ROCm">>;
    }, z.core.$strip>;
    modelPath: z.ZodString;
}, z.core.$strip>;
export type LocalSttConfig = z.infer<typeof LocalSttConfigSchema>;
export declare const RemoteSttConfigSchema: z.ZodObject<{
    apiKey: z.ZodString;
    defaultConfig: z.ZodObject<{
        language: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>;
    defaultTimeout: z.ZodOptional<z.ZodString>;
    endpointOverride: z.ZodOptional<z.ZodString>;
}, z.core.$strip>;
export type RemoteSttConfig = z.infer<typeof RemoteSttConfigSchema>;
/**
 * Stream Speech Recognition Config
 *
 * StreamSpeechRecognitionConfig specifies streaming STT parameters.
 */
export declare const StreamSpeechRecognitionConfigSchema: z.ZodObject<{
    silenceThresholdMs: z.ZodNumber;
    speechConfig: z.ZodObject<{
        language: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>;
}, z.core.$strip>;
/**
 * Stream Speech Recognition Config
 *
 * StreamSpeechRecognitionConfig specifies streaming STT parameters.
 *
 * @property {number} silenceThresholdMs - Threshold for silence in milliseconds. Defaults to 1500.
 * @property {SpeechRecognitionConfig} speechConfig - Configuration for speech recognition.
 */
export type StreamSpeechRecognitionConfig = z.infer<typeof StreamSpeechRecognitionConfigSchema>;
/**
 * Stream Speech Recognition Response
 *
 * Streaming STT Interface Response Stream Element StreamSpeechRecognitionResponse for StreamingSTTInterface.StreamRecognizeSpeech
 */
export declare const StreamSpeechRecognitionResponseSchema: z.ZodObject<{
    isFinal: z.ZodBoolean;
    text: z.ZodString;
}, z.core.$strip>;
/**
 * Stream Speech Recognition Response
 *
 * Streaming STT Interface Response Stream Element StreamSpeechRecognitionResponse for StreamingSTTInterface.StreamRecognizeSpeech
 *
 * @property {boolean} isFinal - Whether this is a final result (true) or interim/partial (false)
 * @property {string} text - The recognized text
 */
export type StreamSpeechRecognitionResponse = z.infer<typeof StreamSpeechRecognitionResponseSchema>;
export declare const LocalStreamingSttConfigSchema: z.ZodObject<{
    defaultConfig: z.ZodObject<{
        silenceThresholdMs: z.ZodNumber;
        speechConfig: z.ZodObject<{
            language: z.ZodOptional<z.ZodString>;
        }, z.core.$strip>;
    }, z.core.$strip>;
    sttDevice: z.ZodObject<{
        index: z.ZodNumber;
        type: z.ZodPipe<z.ZodUnion<readonly [z.ZodEnum<{
            CPU: "CPU";
            CUDA: "CUDA";
            Metal: "Metal";
            ROCm: "ROCm";
        }>]>, z.ZodTransform<string, "CPU" | "CUDA" | "Metal" | "ROCm">>;
    }, z.core.$strip>;
    sttModelPath: z.ZodString;
    vadDevice: z.ZodObject<{
        index: z.ZodNumber;
        type: z.ZodPipe<z.ZodUnion<readonly [z.ZodEnum<{
            CPU: "CPU";
            CUDA: "CUDA";
            Metal: "Metal";
            ROCm: "ROCm";
        }>]>, z.ZodTransform<string, "CPU" | "CUDA" | "Metal" | "ROCm">>;
    }, z.core.$strip>;
    vadModelPath: z.ZodString;
}, z.core.$strip>;
export type LocalStreamingSttConfig = z.infer<typeof LocalStreamingSttConfigSchema>;
export declare const RemoteStreamingSttConfigSchema: z.ZodObject<{
    apiKey: z.ZodString;
    defaultConfig: z.ZodObject<{
        silenceThresholdMs: z.ZodNumber;
        speechConfig: z.ZodObject<{
            language: z.ZodOptional<z.ZodString>;
        }, z.core.$strip>;
    }, z.core.$strip>;
    defaultTimeout: z.ZodOptional<z.ZodString>;
    endpointOverride: z.ZodOptional<z.ZodString>;
    modelId: z.ZodOptional<z.ZodString>;
}, z.core.$strip>;
export type RemoteStreamingSttConfig = z.infer<typeof RemoteStreamingSttConfigSchema>;
/**
 * Eleven Labs Query Params
 *
 * ElevenLabsQueryParams for ElevenLabs TTS requests.
 */
export declare const ElevenLabsQueryParamsSchema: z.ZodObject<{
    enableLogging: z.ZodOptional<z.ZodBoolean>;
    outputFormat: z.ZodEnum<{
        ELEVENLABS_OUTPUT_FORMAT_MP3_22050_32: "ELEVENLABS_OUTPUT_FORMAT_MP3_22050_32";
        ELEVENLABS_OUTPUT_FORMAT_MP3_44100_128: "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_128";
        ELEVENLABS_OUTPUT_FORMAT_MP3_44100_192: "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_192";
        ELEVENLABS_OUTPUT_FORMAT_MP3_44100_32: "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_32";
        ELEVENLABS_OUTPUT_FORMAT_MP3_44100_64: "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_64";
        ELEVENLABS_OUTPUT_FORMAT_MP3_44100_96: "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_96";
        ELEVENLABS_OUTPUT_FORMAT_UNSPECIFIED: "ELEVENLABS_OUTPUT_FORMAT_UNSPECIFIED";
    }>;
}, z.core.$strip>;
/**
 * Eleven Labs Query Params
 *
 * ElevenLabsQueryParams for ElevenLabs TTS requests.
 *
 * @property {boolean} [enableLogging] - Enable logging.
 * @property {'ELEVENLABS_OUTPUT_FORMAT_UNSPECIFIED' | 'ELEVENLABS_OUTPUT_FORMAT_MP3_22050_32' | 'ELEVENLABS_OUTPUT_FORMAT_MP3_44100_32' | 'ELEVENLABS_OUTPUT_FORMAT_MP3_44100_64' | 'ELEVENLABS_OUTPUT_FORMAT_MP3_44100_96' | 'ELEVENLABS_OUTPUT_FORMAT_MP3_44100_128' | 'ELEVENLABS_OUTPUT_FORMAT_MP3_44100_192'} outputFormat - Eleven Labs Output Format. Output format.
 * @remarks outputFormat allowed values: "ELEVENLABS_OUTPUT_FORMAT_UNSPECIFIED", "ELEVENLABS_OUTPUT_FORMAT_MP3_22050_32", "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_32", "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_64", "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_96", "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_128", "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_192"
 */
export type ElevenLabsQueryParams = z.infer<typeof ElevenLabsQueryParamsSchema>;
/**
 * Eleven Labs Request Params
 *
 * ElevenLabsRequestParams for ElevenLabs TTS requests.
 */
export declare const ElevenLabsRequestParamsSchema: z.ZodObject<{
    applyTextNormalization: z.ZodEnum<{
        ELEVENLABS_TEXT_NORMALIZATION_AUTO: "ELEVENLABS_TEXT_NORMALIZATION_AUTO";
        ELEVENLABS_TEXT_NORMALIZATION_OFF: "ELEVENLABS_TEXT_NORMALIZATION_OFF";
        ELEVENLABS_TEXT_NORMALIZATION_ON: "ELEVENLABS_TEXT_NORMALIZATION_ON";
        ELEVENLABS_TEXT_NORMALIZATION_UNSPECIFIED: "ELEVENLABS_TEXT_NORMALIZATION_UNSPECIFIED";
    }>;
    modelId: z.ZodString;
}, z.core.$strip>;
/**
 * Eleven Labs Request Params
 *
 * ElevenLabsRequestParams for ElevenLabs TTS requests.
 *
 * @property {'ELEVENLABS_TEXT_NORMALIZATION_UNSPECIFIED' | 'ELEVENLABS_TEXT_NORMALIZATION_AUTO' | 'ELEVENLABS_TEXT_NORMALIZATION_ON' | 'ELEVENLABS_TEXT_NORMALIZATION_OFF'} applyTextNormalization - Eleven Labs Text Normalization. Text normalization setting.
 * @remarks applyTextNormalization allowed values: "ELEVENLABS_TEXT_NORMALIZATION_UNSPECIFIED", "ELEVENLABS_TEXT_NORMALIZATION_AUTO", "ELEVENLABS_TEXT_NORMALIZATION_ON", "ELEVENLABS_TEXT_NORMALIZATION_OFF"
 * @property {string} modelId - Model ID. Default: "eleven_multilingual_v2".
 */
export type ElevenLabsRequestParams = z.infer<typeof ElevenLabsRequestParamsSchema>;
/**
 * Speech Synthesis Inference Config
 *
 * SpeechSynthesisInferenceConfig specifies model inference parameters for TTS.
 */
export declare const SpeechSynthesisInferenceConfigSchema: z.ZodObject<{
    speakingRate: z.ZodNumber;
    temperature: z.ZodNumber;
}, z.core.$strip>;
/**
 * Speech Synthesis Inference Config
 *
 * SpeechSynthesisInferenceConfig specifies model inference parameters for TTS.
 *
 * @property {number} speakingRate - Speaking rate/speed, in the range [0.5, 1.5]. Default: 1.0.
 * @property {number} temperature - Temperature of the model. Range (0, 2]. Default: 0.8.
 */
export type SpeechSynthesisInferenceConfig = z.infer<typeof SpeechSynthesisInferenceConfigSchema>;
/**
 * Speech Synthesis Postprocessing Config
 *
 * SpeechSynthesisPostprocessingConfig specifies postprocessing for speech waveform.
 */
export declare const SpeechSynthesisPostprocessingConfigSchema: z.ZodObject<{
    sampleRate: z.ZodNumber;
}, z.core.$strip>;
/**
 * Speech Synthesis Postprocessing Config
 *
 * SpeechSynthesisPostprocessingConfig specifies postprocessing for speech waveform.
 *
 * @property {number} sampleRate - The sample rate for the output waveform.
 */
export type SpeechSynthesisPostprocessingConfig = z.infer<typeof SpeechSynthesisPostprocessingConfigSchema>;
/**
 * Voice
 *
 * Voice represents a voice for TTS synthesis.
 */
export declare const VoiceSchema: z.ZodObject<{
    id: z.ZodString;
    language: z.ZodOptional<z.ZodString>;
}, z.core.$strip>;
/**
 * Voice
 *
 * Voice represents a voice for TTS synthesis.
 *
 * @property {string} id - This voice's unique identifier.
 * @property {string} [language] - This voice's language.
 */
export type Voice = z.infer<typeof VoiceSchema>;
/**
 * Local Turn Detector Config
 *
 * LocalTurnDetectorConfig specifies the parameters for initializing a local turn detector.
 */
export declare const LocalTurnDetectorConfigSchema: z.ZodObject<{
    defaultConfig: z.ZodObject<{
        threshold: z.ZodNumber;
    }, z.core.$strip>;
    device: z.ZodObject<{
        index: z.ZodNumber;
        type: z.ZodPipe<z.ZodUnion<readonly [z.ZodEnum<{
            CPU: "CPU";
            CUDA: "CUDA";
            Metal: "Metal";
            ROCm: "ROCm";
        }>]>, z.ZodTransform<string, "CPU" | "CUDA" | "Metal" | "ROCm">>;
    }, z.core.$strip>;
    modelPath: z.ZodString;
}, z.core.$strip>;
/**
 * Local Turn Detector Config
 *
 * LocalTurnDetectorConfig specifies the parameters for initializing a local turn detector.
 *
 * @property {TurnDetectionConfig} defaultConfig - Default runtime turn detection configuration.
 * @property {DeviceSelection} device - Device selection to run inference on.
 * @property {string} modelPath - Path to the model file.
 */
export type LocalTurnDetectorConfig = z.infer<typeof LocalTurnDetectorConfigSchema>;
/**
 * Turn Prediction
 *
 * TurnPrediction represents the result of turn detection analysis.
 */
export declare const TurnPredictionSchema: z.ZodObject<{
    probability: z.ZodNumber;
    status: z.ZodPipe<z.ZodUnion<readonly [z.ZodEnum<{
        Incomplete: "Incomplete";
        Complete: "Complete";
    }>]>, z.ZodTransform<string, "Incomplete" | "Complete">>;
}, z.core.$strip>;
/**
 * Turn Prediction
 *
 * TurnPrediction represents the result of turn detection analysis.
 *
 * @property {number} probability - Confidence of the detection (0.0 to 1.0).
 * @property {'Incomplete' | 'Complete'} status - Turn Status. Detection result indicating whether the turn is complete or not.
 * @remarks status allowed values: "Incomplete", "Complete"
 */
export type TurnPrediction = z.infer<typeof TurnPredictionSchema>;
export declare const LocalVadConfigSchema: z.ZodObject<{
    defaultConfig: z.ZodObject<{
        speechThreshold: z.ZodNumber;
    }, z.core.$strip>;
    device: z.ZodObject<{
        index: z.ZodNumber;
        type: z.ZodPipe<z.ZodUnion<readonly [z.ZodEnum<{
            CPU: "CPU";
            CUDA: "CUDA";
            Metal: "Metal";
            ROCm: "ROCm";
        }>]>, z.ZodTransform<string, "CPU" | "CUDA" | "Metal" | "ROCm">>;
    }, z.core.$strip>;
    modelPath: z.ZodString;
}, z.core.$strip>;
export type LocalVadConfig = z.infer<typeof LocalVadConfigSchema>;
/**
 * Batch Processing Options
 *
 * BatchProcessingOptions configures batch processing for telemetry data.
 */
export declare const BatchProcessingOptionsSchema: z.ZodObject<{
    maxExportBatchSize: z.ZodOptional<z.ZodNumber>;
    maxQueueSize: z.ZodOptional<z.ZodNumber>;
    scheduleDelayMillis: z.ZodOptional<z.ZodNumber>;
}, z.core.$strip>;
/**
 * Batch Processing Options
 *
 * BatchProcessingOptions configures batch processing for telemetry data.
 *
 * @property {number} [maxExportBatchSize] - Maximum number of items to export in a single batch.
 * @property {number} [maxQueueSize] - Maximum size of the processing queue.
 * @property {number} [scheduleDelayMillis] - Delay in milliseconds before processing a batch.
 */
export type BatchProcessingOptions = z.infer<typeof BatchProcessingOptionsSchema>;
/**
 * Metric Config
 *
 * MetricConfig defines a single metric configuration.
 */
export declare const MetricConfigSchema: z.ZodObject<{
    description: z.ZodOptional<z.ZodString>;
    metricKind: z.ZodOptional<z.ZodEnum<{
        METRIC_KIND_COUNTER: "METRIC_KIND_COUNTER";
        METRIC_KIND_GAUGE: "METRIC_KIND_GAUGE";
        METRIC_KIND_HISTOGRAM: "METRIC_KIND_HISTOGRAM";
        METRIC_KIND_UNSPECIFIED: "METRIC_KIND_UNSPECIFIED";
    }>>;
    name: z.ZodOptional<z.ZodString>;
    unit: z.ZodOptional<z.ZodString>;
    valueType: z.ZodOptional<z.ZodEnum<{
        METRIC_VALUE_TYPE_DOUBLE: "METRIC_VALUE_TYPE_DOUBLE";
        METRIC_VALUE_TYPE_INTEGER: "METRIC_VALUE_TYPE_INTEGER";
        METRIC_VALUE_TYPE_UNSPECIFIED: "METRIC_VALUE_TYPE_UNSPECIFIED";
    }>>;
}, z.core.$strip>;
/**
 * Metric Config
 *
 * MetricConfig defines a single metric configuration.
 *
 * @property {string} [description] - Description of the metric.
 * @property {'METRIC_KIND_UNSPECIFIED' | 'METRIC_KIND_COUNTER' | 'METRIC_KIND_GAUGE' | 'METRIC_KIND_HISTOGRAM'} [metricKind] - Metric Kind. Kind of the metric (counter, gauge, or histogram).
 * @remarks metricKind allowed values: "METRIC_KIND_UNSPECIFIED", "METRIC_KIND_COUNTER", "METRIC_KIND_GAUGE", "METRIC_KIND_HISTOGRAM"
 * @property {string} [name] - Name of the metric.
 * @property {string} [unit] - Unit of the metric (e.g., "bytes", "seconds", "count").
 * @property {'METRIC_VALUE_TYPE_UNSPECIFIED' | 'METRIC_VALUE_TYPE_INTEGER' | 'METRIC_VALUE_TYPE_DOUBLE'} [valueType] - Metric Value Type. Value type of the metric (integer or double).
 * @remarks valueType allowed values: "METRIC_VALUE_TYPE_UNSPECIFIED", "METRIC_VALUE_TYPE_INTEGER", "METRIC_VALUE_TYPE_DOUBLE"
 */
export type MetricConfig = z.infer<typeof MetricConfigSchema>;
/**
 * Tracer Config
 *
 * TracerConfig configures distributed tracing.
 */
export declare const TracerConfigSchema: z.ZodObject<{
    batchProcessingOpts: z.ZodOptional<z.ZodObject<{
        maxExportBatchSize: z.ZodOptional<z.ZodNumber>;
        maxQueueSize: z.ZodOptional<z.ZodNumber>;
        scheduleDelayMillis: z.ZodOptional<z.ZodNumber>;
    }, z.core.$strip>>;
    enableSpanCapture: z.ZodOptional<z.ZodBoolean>;
    maxSpanCaptureQueueSize: z.ZodOptional<z.ZodNumber>;
    samplingRate: z.ZodOptional<z.ZodNumber>;
    spanDumpPath: z.ZodOptional<z.ZodString>;
}, z.core.$strip>;
/**
 * Tracer Config
 *
 * TracerConfig configures distributed tracing.
 *
 * @property {BatchProcessingOptions} [batchProcessingOpts] - Optional batch processing options for spans.
 * @property {boolean} [enableSpanCapture] - Whether to enable span capture.
 * @property {number} [maxSpanCaptureQueueSize] - Maximum size of the span capture queue.
 * @property {number} [samplingRate] - Sampling rate for traces (0.0 to 1.0).
 * @property {string} [spanDumpPath] - Optional path to dump span data.
 */
export type TracerConfig = z.infer<typeof TracerConfigSchema>;
/**
 * Simple Telemetry Config
 *
 * SimpleTelemetryConfig provides a minimal telemetry configuration.
 */
export declare const SimpleTelemetryConfigSchema: z.ZodObject<{
    serviceName: z.ZodOptional<z.ZodString>;
    serviceVersion: z.ZodOptional<z.ZodString>;
}, z.core.$strip>;
/**
 * Simple Telemetry Config
 *
 * SimpleTelemetryConfig provides a minimal telemetry configuration.
 *
 * @property {string} [serviceName] - Name of the service generating telemetry.
 * @property {string} [serviceVersion] - Version of the service.
 */
export type SimpleTelemetryConfig = z.infer<typeof SimpleTelemetryConfigSchema>;
/**
 * Span Event
 *
 * SpanEvent - Represents an event within a span
 */
export declare const SpanEventSchema: z.ZodObject<{
    attributes: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
    name: z.ZodOptional<z.ZodString>;
    timestampInNanos: z.ZodOptional<z.ZodNumber>;
}, z.core.$strip>;
/**
 * Span Event
 *
 * SpanEvent - Represents an event within a span
 *
 * @property {Record<string, unknown>} [attributes] - Event attributes (map<string, string> - matches existing pattern)
 * @property {string} [name] - Event name
 * @property {number} [timestampInNanos] - Timestamp in nanoseconds (since epoch)
 */
export type SpanEvent = z.infer<typeof SpanEventSchema>;
/**
 * Log Message Request
 *
 * Telemetry Interface Request Wrapper LogMessageRequest for JsSpan.logMessage
 */
export declare const LogMessageRequestSchema: z.ZodObject<{
    attributes: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
    logLevel: z.ZodEnum<{
        LOG_LEVEL_DEBUG: "LOG_LEVEL_DEBUG";
        LOG_LEVEL_ERROR: "LOG_LEVEL_ERROR";
        LOG_LEVEL_INFO: "LOG_LEVEL_INFO";
        LOG_LEVEL_TRACE: "LOG_LEVEL_TRACE";
        LOG_LEVEL_UNSPECIFIED: "LOG_LEVEL_UNSPECIFIED";
        LOG_LEVEL_WARN: "LOG_LEVEL_WARN";
    }>;
    message: z.ZodString;
}, z.core.$strip>;
/**
 * Log Message Request
 *
 * Telemetry Interface Request Wrapper LogMessageRequest for JsSpan.logMessage
 *
 * @property {Record<string, unknown>} [attributes] - Optional attributes (key-value pairs) to attach to the log message.
 * @property {'LOG_LEVEL_UNSPECIFIED' | 'LOG_LEVEL_TRACE' | 'LOG_LEVEL_DEBUG' | 'LOG_LEVEL_INFO' | 'LOG_LEVEL_WARN' | 'LOG_LEVEL_ERROR'} logLevel - Log Level. Log level of the message.
 * @remarks logLevel allowed values: "LOG_LEVEL_UNSPECIFIED", "LOG_LEVEL_TRACE", "LOG_LEVEL_DEBUG", "LOG_LEVEL_INFO", "LOG_LEVEL_WARN", "LOG_LEVEL_ERROR"
 * @property {string} message - Log message content.
 */
export type LogMessageRequest = z.infer<typeof LogMessageRequestSchema>;
/**
 * Counter Metric
 *
 * CounterMetric represents a counter metric value.
 */
export declare const CounterMetricSchema: z.ZodObject<{
    doubleValue: z.ZodOptional<z.ZodNumber>;
    uint64Value: z.ZodOptional<z.ZodNumber>;
}, z.core.$strip>;
/**
 * Counter Metric
 *
 * CounterMetric represents a counter metric value.
 *
 * @property {number} [doubleValue] - Double counter value.
 * @property {number} [uint64Value] - Unsigned integer counter value.
 */
export type CounterMetric = z.infer<typeof CounterMetricSchema>;
/**
 * Gauge Metric
 *
 * GaugeMetric represents a gauge metric value.
 */
export declare const GaugeMetricSchema: z.ZodObject<{
    doubleValue: z.ZodOptional<z.ZodNumber>;
    int64Value: z.ZodOptional<z.ZodNumber>;
}, z.core.$strip>;
/**
 * Gauge Metric
 *
 * GaugeMetric represents a gauge metric value.
 *
 * @property {number} [doubleValue] - Double gauge value.
 * @property {number} [int64Value] - Integer gauge value.
 */
export type GaugeMetric = z.infer<typeof GaugeMetricSchema>;
/**
 * Histogram Metric
 *
 * HistogramMetric represents a histogram metric value.
 */
export declare const HistogramMetricSchema: z.ZodObject<{
    doubleValue: z.ZodOptional<z.ZodNumber>;
    uint64Value: z.ZodOptional<z.ZodNumber>;
}, z.core.$strip>;
/**
 * Histogram Metric
 *
 * HistogramMetric represents a histogram metric value.
 *
 * @property {number} [doubleValue] - Double histogram value.
 * @property {number} [uint64Value] - Unsigned integer histogram value.
 */
export type HistogramMetric = z.infer<typeof HistogramMetricSchema>;
/**
 * Embed Batch Request
 *
 * TextEmbedderInterface Request EmbedBatchRequest for TextEmbedderInterface.EmbedBatch
 */
export declare const EmbedBatchRequestSchema: z.ZodObject<{
    credentials: z.ZodOptional<z.ZodObject<{
        inworldApiKey: z.ZodOptional<z.ZodString>;
        inworldJwt: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>>;
    texts: z.ZodArray<z.ZodString>;
}, z.core.$strip>;
/**
 * Embed Batch Request
 *
 * TextEmbedderInterface Request EmbedBatchRequest for TextEmbedderInterface.EmbedBatch
 *
 * @property {Credentials} [credentials] - Optional credentials for authenticating with embedding providers. Only used by remote/cloud embedders. Local embedders ignore this field.
 * @property {string[]} texts - The texts to embed.
 */
export type EmbedBatchRequest = z.infer<typeof EmbedBatchRequestSchema>;
/**
 * Embed Batch Response
 *
 * TextEmbedderInterface Response EmbedBatchResponse returned by TextEmbedderInterface.EmbedBatch
 */
export declare const EmbedBatchResponseSchema: z.ZodObject<{
    embeddings: z.ZodArray<z.ZodObject<{
        embedding: z.ZodArray<z.ZodNumber>;
    }, z.core.$strip>>;
}, z.core.$strip>;
/**
 * Embed Batch Response
 *
 * TextEmbedderInterface Response EmbedBatchResponse returned by TextEmbedderInterface.EmbedBatch
 *
 * @property {EmbedResponse[]} embeddings - The batch of embedding vectors. Each element is an embedding vector for the corresponding input text.
 */
export type EmbedBatchResponse = z.infer<typeof EmbedBatchResponseSchema>;
/**
 * Local Text Embedder Config
 *
 * LocalTextEmbedderConfig specifies the parameters required to initialize a local embedding model.
 */
export declare const LocalTextEmbedderConfigSchema: z.ZodObject<{
    device: z.ZodObject<{
        index: z.ZodNumber;
        type: z.ZodPipe<z.ZodUnion<readonly [z.ZodEnum<{
            CPU: "CPU";
            CUDA: "CUDA";
            Metal: "Metal";
            ROCm: "ROCm";
        }>]>, z.ZodTransform<string, "CPU" | "CUDA" | "Metal" | "ROCm">>;
    }, z.core.$strip>;
    modelPath: z.ZodString;
}, z.core.$strip>;
/**
 * Local Text Embedder Config
 *
 * LocalTextEmbedderConfig specifies the parameters required to initialize a local embedding model.
 *
 * @property {DeviceSelection} device - Device selection for embedding model placement.
 * @property {string} modelPath - Path to the model weights.
 */
export type LocalTextEmbedderConfig = z.infer<typeof LocalTextEmbedderConfigSchema>;
/**
 * Compile Knowledge Request
 *
 * CompileKnowledgeRequest for KnowledgeInterface.CompileKnowledge
 */
export declare const CompileKnowledgeRequestSchema: z.ZodObject<{
    credentials: z.ZodOptional<z.ZodObject<{
        inworldApiKey: z.ZodOptional<z.ZodString>;
        inworldJwt: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>>;
    file: z.ZodOptional<z.ZodObject<{
        content: z.ZodString;
        type: z.ZodEnum<{
            TYPE_PDF: "TYPE_PDF";
            TYPE_TXT: "TYPE_TXT";
            TYPE_UNSPECIFIED: "TYPE_UNSPECIFIED";
        }>;
    }, z.core.$strip>>;
    knowledgeId: z.ZodString;
    records: z.ZodOptional<z.ZodObject<{
        records: z.ZodOptional<z.ZodArray<z.ZodString>>;
    }, z.core.$strip>>;
}, z.core.$strip>;
/**
 * Compile Knowledge Request
 *
 * CompileKnowledgeRequest for KnowledgeInterface.CompileKnowledge
 *
 * @property {Credentials} [credentials] - Optional credentials for authenticating with remote knowledge services. Only used by remote knowledge clients. Local clients ignore this field.
 * @property {File} [file] - File to compile into knowledge.
 * @property {string} knowledgeId - Knowledge ID to compile into.
 * @property {KnowledgeRecords} [records] - Vector of string records to compile.
 */
export type CompileKnowledgeRequest = z.infer<typeof CompileKnowledgeRequestSchema>;
/**
 * Get Knowledge Request
 *
 * GetKnowledgeRequest for KnowledgeInterface.GetKnowledge
 */
export declare const GetKnowledgeRequestSchema: z.ZodObject<{
    credentials: z.ZodOptional<z.ZodObject<{
        inworldApiKey: z.ZodOptional<z.ZodString>;
        inworldJwt: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>>;
    ids: z.ZodArray<z.ZodString>;
    retrievalConfig: z.ZodOptional<z.ZodObject<{
        threshold: z.ZodNumber;
        topK: z.ZodNumber;
    }, z.core.$strip>>;
    searchQuery: z.ZodString;
}, z.core.$strip>;
/**
 * Get Knowledge Request
 *
 * GetKnowledgeRequest for KnowledgeInterface.GetKnowledge
 *
 * @property {Credentials} [credentials] - Optional credentials for authenticating with remote knowledge services. Only used by remote knowledge clients. Local clients ignore this field.
 * @property {string[]} ids - IDs of the knowledge collections to retrieve from.
 * @property {RetrievalConfig} [retrievalConfig] - Configuration for the knowledge retrieval when using local knowledge. For remote knowledge - this is ignored.
 * @property {string} searchQuery - Search query string.
 */
export type GetKnowledgeRequest = z.infer<typeof GetKnowledgeRequestSchema>;
/**
 * Knowledge Compile Config
 *
 * KnowledgeCompileConfig represents the configuration for compiling knowledge.
 */
export declare const KnowledgeCompileConfigSchema: z.ZodObject<{
    parsingConfig: z.ZodObject<{
        maxCharsPerChunk: z.ZodNumber;
        maxChunksPerDocument: z.ZodNumber;
    }, z.core.$strip>;
}, z.core.$strip>;
/**
 * Knowledge Compile Config
 *
 * KnowledgeCompileConfig represents the configuration for compiling knowledge.
 *
 * @property {ParsingConfig} parsingConfig - Parsing configuration.
 */
export type KnowledgeCompileConfig = z.infer<typeof KnowledgeCompileConfigSchema>;
/**
 * Remote Knowledge Config
 *
 * RemoteKnowledgeConfig specifies the parameters for initializing a remote knowledge system.
 */
export declare const RemoteKnowledgeConfigSchema: z.ZodObject<{
    apiKey: z.ZodString;
    defaultTimeout: z.ZodOptional<z.ZodString>;
    endpointOverride: z.ZodOptional<z.ZodString>;
    knowledgeCompileConfig: z.ZodObject<{
        parsingConfig: z.ZodObject<{
            maxCharsPerChunk: z.ZodNumber;
            maxChunksPerDocument: z.ZodNumber;
        }, z.core.$strip>;
    }, z.core.$strip>;
    language: z.ZodOptional<z.ZodObject<{
        code: z.ZodString;
        locale: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>>;
}, z.core.$strip>;
/**
 * Remote Knowledge Config
 *
 * RemoteKnowledgeConfig specifies the parameters for initializing a remote knowledge system.
 *
 * @property {string} apiKey - Inworld API key for authentication.
 * @property {Duration} [defaultTimeout] - Default timeout for the request.
 * @property {string} [endpointOverride] - Endpoint override.
 * @property {KnowledgeCompileConfig} knowledgeCompileConfig - Configuration for knowledge compilation.
 * @property {Language} [language] - Language for knowledge processing.
 */
export type RemoteKnowledgeConfig = z.infer<typeof RemoteKnowledgeConfigSchema>;
/**
 * Text Generation Config
 *
 * TextGenerationConfig represents parameters to control text generation.
 */
export declare const TextGenerationConfigSchema: z.ZodObject<{
    frequencyPenalty: z.ZodOptional<z.ZodNumber>;
    logitBias: z.ZodOptional<z.ZodArray<z.ZodObject<{
        biasValue: z.ZodNumber;
        tokenId: z.ZodString;
    }, z.core.$strip>>>;
    maxNewTokens: z.ZodOptional<z.ZodNumber>;
    maxPromptLength: z.ZodOptional<z.ZodNumber>;
    presencePenalty: z.ZodOptional<z.ZodNumber>;
    repetitionPenalty: z.ZodOptional<z.ZodNumber>;
    seed: z.ZodOptional<z.ZodNumber>;
    stopSequences: z.ZodOptional<z.ZodArray<z.ZodString>>;
    temperature: z.ZodOptional<z.ZodNumber>;
    topP: z.ZodOptional<z.ZodNumber>;
}, z.core.$strip>;
/**
 * Text Generation Config
 *
 * TextGenerationConfig represents parameters to control text generation.
 *
 * @property {number} [frequencyPenalty]
 * @property {LogitBias[]} [logitBias]
 * @property {number} [maxNewTokens]
 * @property {number} [maxPromptLength]
 * @property {number} [presencePenalty]
 * @property {number} [repetitionPenalty]
 * @property {number} [seed]
 * @property {string[]} [stopSequences]
 * @property {number} [temperature]
 * @property {number} [topP]
 */
export type TextGenerationConfig = z.infer<typeof TextGenerationConfigSchema>;
/**
 * Content Item
 *
 * ContentItem represents a single content item in a message.
 */
export declare const ContentItemSchema: z.ZodObject<{
    image: z.ZodOptional<z.ZodObject<{
        detail: z.ZodOptional<z.ZodPipe<z.ZodUnion<readonly [z.ZodEnum<{
            auto: "auto";
            high: "high";
            low: "low";
        }>]>, z.ZodTransform<string, "auto" | "high" | "low">>>;
        url: z.ZodString;
    }, z.core.$strip>>;
    text: z.ZodOptional<z.ZodString>;
}, z.core.$strip>;
/**
 * Content Item
 *
 * ContentItem represents a single content item in a message.
 *
 * @property {ImageUrl} [image]
 * @property {string} [text]
 */
export type ContentItem = z.infer<typeof ContentItemSchema>;
/**
 * Tool Choice
 *
 * ToolChoice controls which (if any) tool is called by the model.
 */
export declare const ToolChoiceSchema: z.ZodObject<{
    function: z.ZodOptional<z.ZodObject<{
        name: z.ZodString;
        type: z.ZodString;
    }, z.core.$strip>>;
    type: z.ZodString;
    value: z.ZodOptional<z.ZodString>;
}, z.core.$strip>;
/**
 * Tool Choice
 *
 * ToolChoice controls which (if any) tool is called by the model.
 *
 * @property {FunctionChoice} [function]
 * @property {string} type
 * @property {string} [value]
 */
export type ToolChoice = z.infer<typeof ToolChoiceSchema>;
/**
 * Generate Content Request
 *
 * GenerateContentRequest for LLMInterface.GenerateContent
 */
export declare const GenerateContentRequestSchema: z.ZodObject<{
    config: z.ZodOptional<z.ZodObject<{
        frequencyPenalty: z.ZodOptional<z.ZodNumber>;
        logitBias: z.ZodOptional<z.ZodArray<z.ZodObject<{
            biasValue: z.ZodNumber;
            tokenId: z.ZodString;
        }, z.core.$strip>>>;
        maxNewTokens: z.ZodOptional<z.ZodNumber>;
        maxPromptLength: z.ZodOptional<z.ZodNumber>;
        presencePenalty: z.ZodOptional<z.ZodNumber>;
        repetitionPenalty: z.ZodOptional<z.ZodNumber>;
        seed: z.ZodOptional<z.ZodNumber>;
        stopSequences: z.ZodOptional<z.ZodArray<z.ZodString>>;
        temperature: z.ZodOptional<z.ZodNumber>;
        topP: z.ZodOptional<z.ZodNumber>;
    }, z.core.$strip>>;
    credentials: z.ZodOptional<z.ZodObject<{
        inworldApiKey: z.ZodOptional<z.ZodString>;
        inworldJwt: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>>;
    prompt: z.ZodString;
}, z.core.$strip>;
/**
 * Generate Content Request
 *
 * GenerateContentRequest for LLMInterface.GenerateContent
 *
 * @property {TextGenerationConfig} [config] - Optional LLM configuration override
 * @property {Credentials} [credentials] - Optional credentials for authenticating with remote LLM providers.
 * @property {string} prompt - Text prompt for content generation
 */
export type GenerateContentRequest = z.infer<typeof GenerateContentRequestSchema>;
/**
 * Model Info
 *
 * Complete information about an LLM model
 */
export declare const ModelInfoSchema: z.ZodObject<{
    benchmarks: z.ZodOptional<z.ZodObject<{
        codingIndex: z.ZodOptional<z.ZodNumber>;
        intelligenceIndex: z.ZodOptional<z.ZodNumber>;
        mathIndex: z.ZodOptional<z.ZodNumber>;
    }, z.core.$strip>>;
    modelId: z.ZodObject<{
        modelName: z.ZodOptional<z.ZodString>;
        provider: z.ZodString;
    }, z.core.$strip>;
    performance: z.ZodOptional<z.ZodObject<{
        medianOutputTokensPerSecond: z.ZodOptional<z.ZodNumber>;
        medianTimeToFirstAnswerToken: z.ZodOptional<z.ZodNumber>;
        medianTimeToFirstTokenSeconds: z.ZodOptional<z.ZodNumber>;
    }, z.core.$strip>>;
    pricing: z.ZodOptional<z.ZodObject<{
        completion: z.ZodOptional<z.ZodNumber>;
        image: z.ZodOptional<z.ZodNumber>;
        internalReasoning: z.ZodOptional<z.ZodNumber>;
        prompt: z.ZodOptional<z.ZodNumber>;
        request: z.ZodOptional<z.ZodNumber>;
        webSearch: z.ZodOptional<z.ZodNumber>;
    }, z.core.$strip>>;
    spec: z.ZodOptional<z.ZodObject<{
        contextLength: z.ZodOptional<z.ZodNumber>;
        description: z.ZodOptional<z.ZodString>;
        inputModalities: z.ZodOptional<z.ZodArray<z.ZodString>>;
        maxCompletionTokens: z.ZodOptional<z.ZodNumber>;
        outputModalities: z.ZodOptional<z.ZodArray<z.ZodString>>;
        supportedParameters: z.ZodOptional<z.ZodArray<z.ZodString>>;
    }, z.core.$strip>>;
}, z.core.$strip>;
/**
 * Model Info
 *
 * Complete information about an LLM model
 *
 * @property {LLMBenchmarks} [benchmarks] - Benchmark scores
 * @property {ModelId} modelId - Model identifier
 * @property {LLMPerformance} [performance] - Performance metrics
 * @property {LLMPricing} [pricing] - Pricing information
 * @property {LLMSpec} [spec] - Model specifications
 */
export type ModelInfo = z.infer<typeof ModelInfoSchema>;
export declare const LocalLlmConfigSchema: z.ZodObject<{
    defaultConfig: z.ZodObject<{
        frequencyPenalty: z.ZodOptional<z.ZodNumber>;
        logitBias: z.ZodOptional<z.ZodArray<z.ZodObject<{
            biasValue: z.ZodNumber;
            tokenId: z.ZodString;
        }, z.core.$strip>>>;
        maxNewTokens: z.ZodOptional<z.ZodNumber>;
        maxPromptLength: z.ZodOptional<z.ZodNumber>;
        presencePenalty: z.ZodOptional<z.ZodNumber>;
        repetitionPenalty: z.ZodOptional<z.ZodNumber>;
        seed: z.ZodOptional<z.ZodNumber>;
        stopSequences: z.ZodOptional<z.ZodArray<z.ZodString>>;
        temperature: z.ZodOptional<z.ZodNumber>;
        topP: z.ZodOptional<z.ZodNumber>;
    }, z.core.$strip>;
    device: z.ZodObject<{
        index: z.ZodNumber;
        type: z.ZodPipe<z.ZodUnion<readonly [z.ZodEnum<{
            CPU: "CPU";
            CUDA: "CUDA";
            Metal: "Metal";
            ROCm: "ROCm";
        }>]>, z.ZodTransform<string, "CPU" | "CUDA" | "Metal" | "ROCm">>;
    }, z.core.$strip>;
    modelPath: z.ZodString;
}, z.core.$strip>;
export type LocalLlmConfig = z.infer<typeof LocalLlmConfigSchema>;
export declare const RemoteLlmConfigSchema: z.ZodObject<{
    apiKey: z.ZodString;
    defaultConfig: z.ZodObject<{
        frequencyPenalty: z.ZodOptional<z.ZodNumber>;
        logitBias: z.ZodOptional<z.ZodArray<z.ZodObject<{
            biasValue: z.ZodNumber;
            tokenId: z.ZodString;
        }, z.core.$strip>>>;
        maxNewTokens: z.ZodOptional<z.ZodNumber>;
        maxPromptLength: z.ZodOptional<z.ZodNumber>;
        presencePenalty: z.ZodOptional<z.ZodNumber>;
        repetitionPenalty: z.ZodOptional<z.ZodNumber>;
        seed: z.ZodOptional<z.ZodNumber>;
        stopSequences: z.ZodOptional<z.ZodArray<z.ZodString>>;
        temperature: z.ZodOptional<z.ZodNumber>;
        topP: z.ZodOptional<z.ZodNumber>;
    }, z.core.$strip>;
    defaultTimeout: z.ZodOptional<z.ZodString>;
    endpointOverride: z.ZodOptional<z.ZodString>;
    modelName: z.ZodString;
    provider: z.ZodString;
}, z.core.$strip>;
export type RemoteLlmConfig = z.infer<typeof RemoteLlmConfigSchema>;
/**
 * MCP Session Creation Config
 *
 * MCPSessionCreationConfig configuration for creating an MCP session.
 */
export declare const MCPSessionCreationConfigSchema: z.ZodObject<{
    endpoint: z.ZodString;
    httpConfig: z.ZodOptional<z.ZodObject<{
        apiKey: z.ZodString;
        defaultTimeout: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>>;
    paragonConfig: z.ZodOptional<z.ZodObject<{
        defaultTimeout: z.ZodOptional<z.ZodString>;
        jwtToken: z.ZodString;
    }, z.core.$strip>>;
    stdioConfig: z.ZodOptional<z.ZodObject<{
        env: z.ZodRecord<z.ZodString, z.ZodString>;
    }, z.core.$strip>>;
    transport: z.ZodString;
}, z.core.$strip>;
/**
 * MCP Session Creation Config
 *
 * MCPSessionCreationConfig configuration for creating an MCP session.
 *
 * @property {string} endpoint - The endpoint for the MCP service.
 * @property {MCPHttpConfig} [httpConfig] - HTTP transport configuration.
 * @property {ParagonApiConfig} [paragonConfig] - Paragon API transport configuration.
 * @property {MCPStdioConfig} [stdioConfig] - Stdio transport configuration.
 * @property {string} transport - The transport protocol to use (e.g., "http", "stdio").
 */
export type MCPSessionCreationConfig = z.infer<typeof MCPSessionCreationConfigSchema>;
/**
 * Text Classifier Config
 *
 * TextClassifierConfig configuration for text classification.
 */
export declare const TextClassifierConfigSchema: z.ZodObject<{
    classes: z.ZodArray<z.ZodObject<{
        classLabel: z.ZodString;
        threshold: z.ZodNumber;
    }, z.core.$strip>>;
}, z.core.$strip>;
/**
 * Text Classifier Config
 *
 * TextClassifierConfig configuration for text classification.
 *
 * @property {ClassThreshold[]} classes - List of classes with their detection thresholds.
 */
export type TextClassifierConfig = z.infer<typeof TextClassifierConfigSchema>;
/**
 * Extract Entities Response
 *
 * Entity Extractor Interface Response Wrapper ExtractEntitiesResponse for EntityExtractorInterface.ExtractEntities
 */
export declare const ExtractEntitiesResponseSchema: z.ZodObject<{
    matches: z.ZodArray<z.ZodObject<{
        entityName: z.ZodString;
        ruleName: z.ZodString;
        text: z.ZodString;
    }, z.core.$strip>>;
}, z.core.$strip>;
/**
 * Extract Entities Response
 *
 * Entity Extractor Interface Response Wrapper ExtractEntitiesResponse for EntityExtractorInterface.ExtractEntities
 *
 * @property {EntityMatch[]} matches - List of entity matches found in the text. Empty if no entities were found.
 */
export type ExtractEntitiesResponse = z.infer<typeof ExtractEntitiesResponseSchema>;
/**
 * Llm Matcher Config
 *
 * LlmMatcherConfig configuration for LLM-based intent matching.
 */
export declare const LLMMatcherConfigSchema: z.ZodObject<{
    embeddingSimilarityThreshold: z.ZodOptional<z.ZodNumber>;
    generationConfig: z.ZodOptional<z.ZodObject<{
        frequencyPenalty: z.ZodOptional<z.ZodNumber>;
        logitBias: z.ZodOptional<z.ZodArray<z.ZodObject<{
            biasValue: z.ZodNumber;
            tokenId: z.ZodString;
        }, z.core.$strip>>>;
        maxNewTokens: z.ZodOptional<z.ZodNumber>;
        maxPromptLength: z.ZodOptional<z.ZodNumber>;
        presencePenalty: z.ZodOptional<z.ZodNumber>;
        repetitionPenalty: z.ZodOptional<z.ZodNumber>;
        seed: z.ZodOptional<z.ZodNumber>;
        stopSequences: z.ZodOptional<z.ZodArray<z.ZodString>>;
        temperature: z.ZodOptional<z.ZodNumber>;
        topP: z.ZodOptional<z.ZodNumber>;
    }, z.core.$strip>>;
    maxEmbeddingMatchesForLlm: z.ZodOptional<z.ZodNumber>;
    promptTemplate: z.ZodString;
}, z.core.$strip>;
/**
 * Llm Matcher Config
 *
 * LlmMatcherConfig configuration for LLM-based intent matching.
 *
 * @property {number} [embeddingSimilarityThreshold] - Optional minimum similarity threshold for phrases to be included in prompt.
 * @property {TextGenerationConfig} [generationConfig] - Configuration for LLM text generation.
 * @property {number} [maxEmbeddingMatchesForLlm] - Optional maximum number of embedding matches to include in the LLM prompt.
 * @property {string} promptTemplate - Prompt template for intent matching.
 */
export type LLMMatcherConfig = z.infer<typeof LLMMatcherConfigSchema>;
/**
 * Keyword Matcher Response
 *
 * KeywordMatcherResponse response from a keyword matching operation.
 */
export declare const KeywordMatcherResponseSchema: z.ZodObject<{
    matches: z.ZodArray<z.ZodObject<{
        groupName: z.ZodString;
        keyword: z.ZodString;
    }, z.core.$strip>>;
}, z.core.$strip>;
/**
 * Keyword Matcher Response
 *
 * KeywordMatcherResponse response from a keyword matching operation.
 *
 * @property {KeywordMatch[]} matches - Information about each matched keyword. Empty if no keywords were found.
 */
export type KeywordMatcherResponse = z.infer<typeof KeywordMatcherResponseSchema>;
/**
 * Entity
 *
 * Entity a custom entity category that can be extracted from text.
 */
export declare const EntitySchema: z.ZodObject<{
    name: z.ZodString;
    rules: z.ZodArray<z.ZodObject<{
        displayName: z.ZodString;
        name: z.ZodString;
        synonyms: z.ZodOptional<z.ZodArray<z.ZodString>>;
    }, z.core.$strip>>;
}, z.core.$strip>;
/**
 * Entity
 *
 * Entity a custom entity category that can be extracted from text.
 *
 * @property {string} name - Unique ID of the entity.
 * @property {DictionaryRule[]} rules - List of rules for the entity.
 */
export type Entity = z.infer<typeof EntitySchema>;
/**
 * Device
 *
 * Device represents a local computation resource that can be used for model inference.
 */
export declare const DeviceSchema: z.ZodObject<{
    index: z.ZodNumber;
    info: z.ZodObject<{
        freeMemoryBytes: z.ZodNumber;
        name: z.ZodString;
        timestamp: z.ZodCoercedDate<unknown>;
        totalMemoryBytes: z.ZodNumber;
    }, z.core.$strip>;
    type: z.ZodPipe<z.ZodUnion<readonly [z.ZodEnum<{
        CPU: "CPU";
        CUDA: "CUDA";
        Metal: "Metal";
        ROCm: "ROCm";
    }>]>, z.ZodTransform<string, "CPU" | "CUDA" | "Metal" | "ROCm">>;
}, z.core.$strip>;
/**
 * Device
 *
 * Device represents a local computation resource that can be used for model inference.
 *
 * @property {number} index - Index of the device in the list of available devices.
 * @property {DeviceInfo} info - Information about the device.
 * @property {'CPU' | 'CUDA' | 'Metal' | 'ROCm'} type - Device Type. Type of the device.
 * @remarks type allowed values: "CPU", "CUDA", "Metal", "ROCm"
 */
export type Device = z.infer<typeof DeviceSchema>;
/**
 * Organic Result
 *
 * Represents a single organic search result
 */
export declare const OrganicResultSchema: z.ZodObject<{
    attributes: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
    date: z.ZodOptional<z.ZodString>;
    link: z.ZodOptional<z.ZodString>;
    position: z.ZodOptional<z.ZodNumber>;
    sitelinks: z.ZodOptional<z.ZodArray<z.ZodObject<{
        link: z.ZodOptional<z.ZodString>;
        title: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>>>;
    snippet: z.ZodOptional<z.ZodString>;
    title: z.ZodOptional<z.ZodString>;
}, z.core.$strip>;
/**
 * Organic Result
 *
 * Represents a single organic search result
 *
 * @property {Record<string, unknown>} [attributes] - Additional attributes as key-value pairs
 * @property {string} [date] - Date of the result
 * @property {string} [link] - The URL of the search result
 * @property {number} [position] - The position in search results (1-based)
 * @property {Sitelink[]} [sitelinks] - Sitelinks for the result
 * @property {string} [snippet] - A snippet/description of the search result
 * @property {string} [title] - The title of the search result
 */
export type OrganicResult = z.infer<typeof OrganicResultSchema>;
export declare const LocalAecFilterConfigSchema: z.ZodObject<{
    defaultConfig: z.ZodObject<{}, z.core.$strip>;
    device: z.ZodObject<{
        index: z.ZodNumber;
        type: z.ZodPipe<z.ZodUnion<readonly [z.ZodEnum<{
            CPU: "CPU";
            CUDA: "CUDA";
            Metal: "Metal";
            ROCm: "ROCm";
        }>]>, z.ZodTransform<string, "CPU" | "CUDA" | "Metal" | "ROCm">>;
    }, z.core.$strip>;
}, z.core.$strip>;
export type LocalAecFilterConfig = z.infer<typeof LocalAecFilterConfigSchema>;
/**
 * Detect Silence Request
 *
 * VAD Interface Request Wrapper DetectSilenceRequest for VADInterface.DetectSilence
 */
export declare const DetectSilenceRequestSchema: z.ZodObject<{
    audioBytes: z.ZodString;
    config: z.ZodOptional<z.ZodObject<{
        speechThreshold: z.ZodNumber;
    }, z.core.$strip>>;
    sampleRate: z.ZodNumber;
}, z.core.$strip>;
/**
 * Detect Silence Request
 *
 * VAD Interface Request Wrapper DetectSilenceRequest for VADInterface.DetectSilence
 *
 * @property {string} audioBytes - Audio bytes to analyze for silence
 * @property {VoiceActivityDetectionConfig} [config] - Optional VAD configuration override
 * @property {number} sampleRate - Sample rate of the audio
 */
export type DetectSilenceRequest = z.infer<typeof DetectSilenceRequestSchema>;
/**
 * Audio Chunk
 *
 * AudioChunk represents a single audio chunk with timing information.
 */
export declare const AudioChunkSchema: z.ZodObject<{
    data: z.ZodOptional<z.ZodCustom<Float32Array<ArrayBuffer>, Float32Array<ArrayBuffer>>>;
    sampleRate: z.ZodNumber;
    timestamps: z.ZodOptional<z.ZodArray<z.ZodObject<{
        endTime: z.ZodNumber;
        startTime: z.ZodNumber;
        token: z.ZodString;
    }, z.core.$strip>>>;
}, z.core.$strip>;
/**
 * Audio Chunk
 *
 * AudioChunk represents a single audio chunk with timing information.
 *
 * @property {string} data - Raw audio data as bytes (unified format).
 * @property {number} sampleRate - Sample rate in Hz.
 * @property {AudioChunkTimestamp[]} [timestamps] - Optional timing information for tokens in this chunk.
 */
export type AudioChunk = z.infer<typeof AudioChunkSchema>;
/**
 * Detect Voice Activity Request
 *
 * VAD Interface Request Wrapper DetectVoiceActivityRequest for VADInterface.DetectVoiceActivity
 */
export declare const DetectVoiceActivityRequestSchema: z.ZodObject<{
    audioChunk: z.ZodObject<{
        data: z.ZodOptional<z.ZodCustom<Float32Array<ArrayBuffer>, Float32Array<ArrayBuffer>>>;
        sampleRate: z.ZodNumber;
        timestamps: z.ZodOptional<z.ZodArray<z.ZodObject<{
            endTime: z.ZodNumber;
            startTime: z.ZodNumber;
            token: z.ZodString;
        }, z.core.$strip>>>;
    }, z.core.$strip>;
    config: z.ZodOptional<z.ZodObject<{
        speechThreshold: z.ZodNumber;
    }, z.core.$strip>>;
}, z.core.$strip>;
/**
 * Detect Voice Activity Request
 *
 * VAD Interface Request Wrapper DetectVoiceActivityRequest for VADInterface.DetectVoiceActivity
 *
 * @property {AudioChunk} audioChunk - Audio chunk to analyze
 * @property {VoiceActivityDetectionConfig} [config] - Optional VAD configuration override
 */
export type DetectVoiceActivityRequest = z.infer<typeof DetectVoiceActivityRequestSchema>;
/**
 * Filter Audio Request
 *
 * AEC Interface Request Wrapper FilterAudioRequest for AECInterface.FilterAudio
 */
export declare const FilterAudioRequestSchema: z.ZodObject<{
    config: z.ZodOptional<z.ZodObject<{}, z.core.$strip>>;
    microphoneChunk: z.ZodObject<{
        data: z.ZodOptional<z.ZodCustom<Float32Array<ArrayBuffer>, Float32Array<ArrayBuffer>>>;
        sampleRate: z.ZodNumber;
        timestamps: z.ZodOptional<z.ZodArray<z.ZodObject<{
            endTime: z.ZodNumber;
            startTime: z.ZodNumber;
            token: z.ZodString;
        }, z.core.$strip>>>;
    }, z.core.$strip>;
    speakersChunk: z.ZodObject<{
        data: z.ZodOptional<z.ZodCustom<Float32Array<ArrayBuffer>, Float32Array<ArrayBuffer>>>;
        sampleRate: z.ZodNumber;
        timestamps: z.ZodOptional<z.ZodArray<z.ZodObject<{
            endTime: z.ZodNumber;
            startTime: z.ZodNumber;
            token: z.ZodString;
        }, z.core.$strip>>>;
    }, z.core.$strip>;
}, z.core.$strip>;
/**
 * Filter Audio Request
 *
 * AEC Interface Request Wrapper FilterAudioRequest for AECInterface.FilterAudio
 *
 * @property {AcousticEchoCancellationConfig} [config] - Optional AEC configuration override
 * @property {AudioChunk} microphoneChunk - Microphone audio chunk
 * @property {AudioChunk} speakersChunk - Speakers audio chunk
 */
export type FilterAudioRequest = z.infer<typeof FilterAudioRequestSchema>;
/**
 * Recognize Speech Request
 *
 * STT Interface Request Wrapper RecognizeSpeechRequest for STTInterface.RecognizeSpeech
 */
export declare const RecognizeSpeechRequestSchema: z.ZodObject<{
    audioChunk: z.ZodObject<{
        data: z.ZodOptional<z.ZodCustom<Float32Array<ArrayBuffer>, Float32Array<ArrayBuffer>>>;
        sampleRate: z.ZodNumber;
        timestamps: z.ZodOptional<z.ZodArray<z.ZodObject<{
            endTime: z.ZodNumber;
            startTime: z.ZodNumber;
            token: z.ZodString;
        }, z.core.$strip>>>;
    }, z.core.$strip>;
    config: z.ZodOptional<z.ZodObject<{
        language: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>>;
    credentials: z.ZodOptional<z.ZodObject<{
        inworldApiKey: z.ZodOptional<z.ZodString>;
        inworldJwt: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>>;
}, z.core.$strip>;
/**
 * Recognize Speech Request
 *
 * STT Interface Request Wrapper RecognizeSpeechRequest for STTInterface.RecognizeSpeech
 *
 * @property {AudioChunk} audioChunk - Audio chunk to transcribe
 * @property {SpeechRecognitionConfig} [config] - Optional STT configuration override
 * @property {Credentials} [credentials] - Optional credentials for authenticating with STT providers Only used by remote/cloud STT clients. Local clients ignore this field.
 */
export type RecognizeSpeechRequest = z.infer<typeof RecognizeSpeechRequestSchema>;
/**
 * STT Creation Config
 *
 * STTCreationConfig encapsulates the configuration for creating an STT model.
 */
export declare const STTCreationConfigSchema: z.ZodObject<{
    localConfig: z.ZodOptional<z.ZodObject<{
        defaultConfig: z.ZodObject<{
            language: z.ZodOptional<z.ZodString>;
        }, z.core.$strip>;
        device: z.ZodObject<{
            index: z.ZodNumber;
            type: z.ZodPipe<z.ZodUnion<readonly [z.ZodEnum<{
                CPU: "CPU";
                CUDA: "CUDA";
                Metal: "Metal";
                ROCm: "ROCm";
            }>]>, z.ZodTransform<string, "CPU" | "CUDA" | "Metal" | "ROCm">>;
        }, z.core.$strip>;
        modelPath: z.ZodString;
    }, z.core.$strip>>;
    remoteConfig: z.ZodOptional<z.ZodObject<{
        apiKey: z.ZodString;
        defaultConfig: z.ZodObject<{
            language: z.ZodOptional<z.ZodString>;
        }, z.core.$strip>;
        defaultTimeout: z.ZodOptional<z.ZodString>;
        endpointOverride: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>>;
}, z.core.$strip>;
/**
 * STT Creation Config
 *
 * STTCreationConfig encapsulates the configuration for creating an STT model.
 *
 * @property {LocalSTTConfig} [localConfig] - Local STT configuration.
 * @property {RemoteSTTConfig} [remoteConfig] - Remote STT configuration.
 */
export type STTCreationConfig = z.infer<typeof STTCreationConfigSchema>;
/**
 * Stream Recognize Speech Request
 *
 * Streaming STT Interface Request Wrapper StreamRecognizeSpeechRequest for StreamingSTTInterface.StreamRecognizeSpeech
 */
export declare const StreamRecognizeSpeechRequestSchema: z.ZodObject<{
    config: z.ZodOptional<z.ZodObject<{
        silenceThresholdMs: z.ZodNumber;
        speechConfig: z.ZodObject<{
            language: z.ZodOptional<z.ZodString>;
        }, z.core.$strip>;
    }, z.core.$strip>>;
    credentials: z.ZodOptional<z.ZodObject<{
        inworldApiKey: z.ZodOptional<z.ZodString>;
        inworldJwt: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>>;
}, z.core.$strip>;
/**
 * Stream Recognize Speech Request
 *
 * Streaming STT Interface Request Wrapper StreamRecognizeSpeechRequest for StreamingSTTInterface.StreamRecognizeSpeech
 *
 * @property {StreamSpeechRecognitionConfig} [config] - Optional streaming STT configuration override
 * @property {Credentials} [credentials] - Optional credentials for authenticating with STT providers
 */
export type StreamRecognizeSpeechRequest = z.infer<typeof StreamRecognizeSpeechRequestSchema>;
/**
 * StreamingSTT Creation Config
 *
 * StreamingSTTCreationConfig encapsulates the configuration for creating a streaming STT.
 */
export declare const StreamingSTTCreationConfigSchema: z.ZodObject<{
    localConfig: z.ZodOptional<z.ZodObject<{
        defaultConfig: z.ZodObject<{
            silenceThresholdMs: z.ZodNumber;
            speechConfig: z.ZodObject<{
                language: z.ZodOptional<z.ZodString>;
            }, z.core.$strip>;
        }, z.core.$strip>;
        sttDevice: z.ZodObject<{
            index: z.ZodNumber;
            type: z.ZodPipe<z.ZodUnion<readonly [z.ZodEnum<{
                CPU: "CPU";
                CUDA: "CUDA";
                Metal: "Metal";
                ROCm: "ROCm";
            }>]>, z.ZodTransform<string, "CPU" | "CUDA" | "Metal" | "ROCm">>;
        }, z.core.$strip>;
        sttModelPath: z.ZodString;
        vadDevice: z.ZodObject<{
            index: z.ZodNumber;
            type: z.ZodPipe<z.ZodUnion<readonly [z.ZodEnum<{
                CPU: "CPU";
                CUDA: "CUDA";
                Metal: "Metal";
                ROCm: "ROCm";
            }>]>, z.ZodTransform<string, "CPU" | "CUDA" | "Metal" | "ROCm">>;
        }, z.core.$strip>;
        vadModelPath: z.ZodString;
    }, z.core.$strip>>;
    remoteConfig: z.ZodOptional<z.ZodObject<{
        apiKey: z.ZodString;
        defaultConfig: z.ZodObject<{
            silenceThresholdMs: z.ZodNumber;
            speechConfig: z.ZodObject<{
                language: z.ZodOptional<z.ZodString>;
            }, z.core.$strip>;
        }, z.core.$strip>;
        defaultTimeout: z.ZodOptional<z.ZodString>;
        endpointOverride: z.ZodOptional<z.ZodString>;
        modelId: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>>;
}, z.core.$strip>;
/**
 * StreamingSTT Creation Config
 *
 * StreamingSTTCreationConfig encapsulates the configuration for creating a streaming STT.
 *
 * @property {LocalStreamingSTTConfig} [localConfig] - Local streaming STT configuration.
 * @property {RemoteStreamingSTTConfig} [remoteConfig] - Remote streaming STT configuration.
 */
export type StreamingSTTCreationConfig = z.infer<typeof StreamingSTTCreationConfigSchema>;
/**
 * Eleven Labs Speech Synthesis Config
 *
 * ElevenLabsSpeechSynthesisConfig for ElevenLabs TTS model.
 */
export declare const ElevenLabsSpeechSynthesisConfigSchema: z.ZodObject<{
    queryParams: z.ZodObject<{
        enableLogging: z.ZodOptional<z.ZodBoolean>;
        outputFormat: z.ZodEnum<{
            ELEVENLABS_OUTPUT_FORMAT_MP3_22050_32: "ELEVENLABS_OUTPUT_FORMAT_MP3_22050_32";
            ELEVENLABS_OUTPUT_FORMAT_MP3_44100_128: "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_128";
            ELEVENLABS_OUTPUT_FORMAT_MP3_44100_192: "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_192";
            ELEVENLABS_OUTPUT_FORMAT_MP3_44100_32: "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_32";
            ELEVENLABS_OUTPUT_FORMAT_MP3_44100_64: "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_64";
            ELEVENLABS_OUTPUT_FORMAT_MP3_44100_96: "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_96";
            ELEVENLABS_OUTPUT_FORMAT_UNSPECIFIED: "ELEVENLABS_OUTPUT_FORMAT_UNSPECIFIED";
        }>;
    }, z.core.$strip>;
    requestParams: z.ZodObject<{
        applyTextNormalization: z.ZodEnum<{
            ELEVENLABS_TEXT_NORMALIZATION_AUTO: "ELEVENLABS_TEXT_NORMALIZATION_AUTO";
            ELEVENLABS_TEXT_NORMALIZATION_OFF: "ELEVENLABS_TEXT_NORMALIZATION_OFF";
            ELEVENLABS_TEXT_NORMALIZATION_ON: "ELEVENLABS_TEXT_NORMALIZATION_ON";
            ELEVENLABS_TEXT_NORMALIZATION_UNSPECIFIED: "ELEVENLABS_TEXT_NORMALIZATION_UNSPECIFIED";
        }>;
        modelId: z.ZodString;
    }, z.core.$strip>;
}, z.core.$strip>;
/**
 * Eleven Labs Speech Synthesis Config
 *
 * ElevenLabsSpeechSynthesisConfig for ElevenLabs TTS model.
 *
 * @property {ElevenLabsQueryParams} queryParams - Query parameters.
 * @property {ElevenLabsRequestParams} requestParams - Request parameters.
 */
export type ElevenLabsSpeechSynthesisConfig = z.infer<typeof ElevenLabsSpeechSynthesisConfigSchema>;
/**
 * Inworld Speech Synthesis Config
 *
 * InworldSpeechSynthesisConfig for Inworld TTS model.
 */
export declare const InworldSpeechSynthesisConfigSchema: z.ZodObject<{
    inference: z.ZodObject<{
        speakingRate: z.ZodNumber;
        temperature: z.ZodNumber;
    }, z.core.$strip>;
    modelId: z.ZodOptional<z.ZodString>;
    postprocessing: z.ZodObject<{
        sampleRate: z.ZodNumber;
    }, z.core.$strip>;
    timestampType: z.ZodOptional<z.ZodEnum<{
        TIMESTAMP_TYPE_CHARACTER: "TIMESTAMP_TYPE_CHARACTER";
        TIMESTAMP_TYPE_UNSPECIFIED: "TIMESTAMP_TYPE_UNSPECIFIED";
        TIMESTAMP_TYPE_WORD: "TIMESTAMP_TYPE_WORD";
    }>>;
}, z.core.$strip>;
/**
 * Inworld Speech Synthesis Config
 *
 * InworldSpeechSynthesisConfig for Inworld TTS model.
 *
 * @property {SpeechSynthesisInferenceConfig} inference - Inference configuration.
 * @property {string} [modelId] - Model ID (v2 or inworld-tts-1). Default: v2.
 * @property {SpeechSynthesisPostprocessingConfig} postprocessing - Postprocessing configuration.
 * @property {'TIMESTAMP_TYPE_UNSPECIFIED' | 'TIMESTAMP_TYPE_WORD' | 'TIMESTAMP_TYPE_CHARACTER'} [timestampType] - Timestamp Type. Optional type of timestamp alignment to return.
 * @remarks timestampType allowed values: "TIMESTAMP_TYPE_UNSPECIFIED", "TIMESTAMP_TYPE_WORD", "TIMESTAMP_TYPE_CHARACTER"
 */
export type InworldSpeechSynthesisConfig = z.infer<typeof InworldSpeechSynthesisConfigSchema>;
/**
 * Turn Detector Creation Config
 *
 * TurnDetectorCreationConfig encapsulates the configuration for creating a turn detector.
 */
export declare const TurnDetectorCreationConfigSchema: z.ZodObject<{
    localConfig: z.ZodOptional<z.ZodObject<{
        defaultConfig: z.ZodObject<{
            threshold: z.ZodNumber;
        }, z.core.$strip>;
        device: z.ZodObject<{
            index: z.ZodNumber;
            type: z.ZodPipe<z.ZodUnion<readonly [z.ZodEnum<{
                CPU: "CPU";
                CUDA: "CUDA";
                Metal: "Metal";
                ROCm: "ROCm";
            }>]>, z.ZodTransform<string, "CPU" | "CUDA" | "Metal" | "ROCm">>;
        }, z.core.$strip>;
        modelPath: z.ZodString;
    }, z.core.$strip>>;
}, z.core.$strip>;
/**
 * Turn Detector Creation Config
 *
 * TurnDetectorCreationConfig encapsulates the configuration for creating a turn detector.
 *
 * @property {LocalTurnDetectorConfig} [localConfig] - Local turn detector configuration.
 */
export type TurnDetectorCreationConfig = z.infer<typeof TurnDetectorCreationConfigSchema>;
/**
 * VAD Creation Config
 *
 * VADCreationConfig encapsulates the configuration for creating a VAD model.
 */
export declare const VADCreationConfigSchema: z.ZodObject<{
    localConfig: z.ZodOptional<z.ZodObject<{
        defaultConfig: z.ZodObject<{
            speechThreshold: z.ZodNumber;
        }, z.core.$strip>;
        device: z.ZodObject<{
            index: z.ZodNumber;
            type: z.ZodPipe<z.ZodUnion<readonly [z.ZodEnum<{
                CPU: "CPU";
                CUDA: "CUDA";
                Metal: "Metal";
                ROCm: "ROCm";
            }>]>, z.ZodTransform<string, "CPU" | "CUDA" | "Metal" | "ROCm">>;
        }, z.core.$strip>;
        modelPath: z.ZodString;
    }, z.core.$strip>>;
}, z.core.$strip>;
/**
 * VAD Creation Config
 *
 * VADCreationConfig encapsulates the configuration for creating a VAD model.
 *
 * @property {LocalVADConfig} [localConfig] - Local VAD configuration.
 */
export type VADCreationConfig = z.infer<typeof VADCreationConfigSchema>;
/**
 * Logger Config
 *
 * LoggerConfig configures logging behavior.
 */
export declare const LoggerConfigSchema: z.ZodObject<{
    batchProcessingOpts: z.ZodOptional<z.ZodObject<{
        maxExportBatchSize: z.ZodOptional<z.ZodNumber>;
        maxQueueSize: z.ZodOptional<z.ZodNumber>;
        scheduleDelayMillis: z.ZodOptional<z.ZodNumber>;
    }, z.core.$strip>>;
    logLevel: z.ZodOptional<z.ZodEnum<{
        LOG_LEVEL_DEBUG: "LOG_LEVEL_DEBUG";
        LOG_LEVEL_ERROR: "LOG_LEVEL_ERROR";
        LOG_LEVEL_INFO: "LOG_LEVEL_INFO";
        LOG_LEVEL_TRACE: "LOG_LEVEL_TRACE";
        LOG_LEVEL_UNSPECIFIED: "LOG_LEVEL_UNSPECIFIED";
        LOG_LEVEL_WARN: "LOG_LEVEL_WARN";
    }>>;
    sinkAbslLogs: z.ZodOptional<z.ZodBoolean>;
}, z.core.$strip>;
/**
 * Logger Config
 *
 * LoggerConfig configures logging behavior.
 *
 * @property {BatchProcessingOptions} [batchProcessingOpts] - Optional batch processing options for logs.
 * @property {'LOG_LEVEL_UNSPECIFIED' | 'LOG_LEVEL_TRACE' | 'LOG_LEVEL_DEBUG' | 'LOG_LEVEL_INFO' | 'LOG_LEVEL_WARN' | 'LOG_LEVEL_ERROR'} [logLevel] - Log Level. Minimum log level to record.
 * @remarks logLevel allowed values: "LOG_LEVEL_UNSPECIFIED", "LOG_LEVEL_TRACE", "LOG_LEVEL_DEBUG", "LOG_LEVEL_INFO", "LOG_LEVEL_WARN", "LOG_LEVEL_ERROR"
 * @property {boolean} [sinkAbslLogs] - Whether to sink absl logs.
 */
export type LoggerConfig = z.infer<typeof LoggerConfigSchema>;
/**
 * Metrics Config
 *
 * MetricsConfig configures metrics collection and export.
 */
export declare const MetricsConfigSchema: z.ZodObject<{
    exportInterval: z.ZodOptional<z.ZodNumber>;
    exportTimeout: z.ZodOptional<z.ZodNumber>;
    metricCacheSize: z.ZodOptional<z.ZodNumber>;
    metrics: z.ZodOptional<z.ZodArray<z.ZodObject<{
        description: z.ZodOptional<z.ZodString>;
        metricKind: z.ZodOptional<z.ZodEnum<{
            METRIC_KIND_COUNTER: "METRIC_KIND_COUNTER";
            METRIC_KIND_GAUGE: "METRIC_KIND_GAUGE";
            METRIC_KIND_HISTOGRAM: "METRIC_KIND_HISTOGRAM";
            METRIC_KIND_UNSPECIFIED: "METRIC_KIND_UNSPECIFIED";
        }>>;
        name: z.ZodOptional<z.ZodString>;
        unit: z.ZodOptional<z.ZodString>;
        valueType: z.ZodOptional<z.ZodEnum<{
            METRIC_VALUE_TYPE_DOUBLE: "METRIC_VALUE_TYPE_DOUBLE";
            METRIC_VALUE_TYPE_INTEGER: "METRIC_VALUE_TYPE_INTEGER";
            METRIC_VALUE_TYPE_UNSPECIFIED: "METRIC_VALUE_TYPE_UNSPECIFIED";
        }>>;
    }, z.core.$strip>>>;
}, z.core.$strip>;
/**
 * Metrics Config
 *
 * MetricsConfig configures metrics collection and export.
 *
 * @property {number} [exportInterval] - Interval in milliseconds between metric exports.
 * @property {number} [exportTimeout] - Timeout in milliseconds for metric export operations.
 * @property {number} [metricCacheSize] - Maximum size of the metric cache.
 * @property {MetricConfig[]} [metrics] - List of metric configurations.
 */
export type MetricsConfig = z.infer<typeof MetricsConfigSchema>;
/**
 * Span Data
 *
 * SpanData - Represents a single span trace
 */
export declare const SpanDataSchema: z.ZodObject<{
    attributes: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
    description: z.ZodOptional<z.ZodString>;
    durationInNanos: z.ZodOptional<z.ZodNumber>;
    events: z.ZodOptional<z.ZodArray<z.ZodObject<{
        attributes: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
        name: z.ZodOptional<z.ZodString>;
        timestampInNanos: z.ZodOptional<z.ZodNumber>;
    }, z.core.$strip>>>;
    kind: z.ZodOptional<z.ZodEnum<{
        SPAN_KIND_CLIENT: "SPAN_KIND_CLIENT";
        SPAN_KIND_CONSUMER: "SPAN_KIND_CONSUMER";
        SPAN_KIND_INTERNAL: "SPAN_KIND_INTERNAL";
        SPAN_KIND_PRODUCER: "SPAN_KIND_PRODUCER";
        SPAN_KIND_SERVER: "SPAN_KIND_SERVER";
        SPAN_KIND_UNSPECIFIED: "SPAN_KIND_UNSPECIFIED";
    }>>;
    name: z.ZodOptional<z.ZodString>;
    parentSpanId: z.ZodOptional<z.ZodString>;
    spanId: z.ZodOptional<z.ZodString>;
    startTimeInNanos: z.ZodOptional<z.ZodNumber>;
    status: z.ZodOptional<z.ZodEnum<{
        SPAN_STATUS_ERROR: "SPAN_STATUS_ERROR";
        SPAN_STATUS_OK: "SPAN_STATUS_OK";
        SPAN_STATUS_UNSET: "SPAN_STATUS_UNSET";
    }>>;
    traceId: z.ZodOptional<z.ZodString>;
}, z.core.$strip>;
/**
 * Span Data
 *
 * SpanData - Represents a single span trace
 *
 * @property {Record<string, unknown>} [attributes] - Span attributes (map<string, string> - matches existing pattern)
 * @property {string} [description] - Span description
 * @property {number} [durationInNanos] - Duration in nanoseconds
 * @property {SpanEvent[]} [events] - Span events
 * @property {'SPAN_KIND_UNSPECIFIED' | 'SPAN_KIND_INTERNAL' | 'SPAN_KIND_SERVER' | 'SPAN_KIND_CLIENT' | 'SPAN_KIND_PRODUCER' | 'SPAN_KIND_CONSUMER'} [kind] - Span Kind. Span kind
 * @remarks kind allowed values: "SPAN_KIND_UNSPECIFIED", "SPAN_KIND_INTERNAL", "SPAN_KIND_SERVER", "SPAN_KIND_CLIENT", "SPAN_KIND_PRODUCER", "SPAN_KIND_CONSUMER"
 * @property {string} [name] - Span name
 * @property {string} [parentSpanId] - Parent Span ID (16 hex characters)
 * @property {string} [spanId] - Span ID (16 hex characters)
 * @property {number} [startTimeInNanos] - Start time in nanoseconds (since epoch)
 * @property {'SPAN_STATUS_UNSET' | 'SPAN_STATUS_OK' | 'SPAN_STATUS_ERROR'} [status] - Span Status. Span status
 * @remarks status allowed values: "SPAN_STATUS_UNSET", "SPAN_STATUS_OK", "SPAN_STATUS_ERROR"
 * @property {string} [traceId] - Trace ID (32 hex characters)
 */
export type SpanData = z.infer<typeof SpanDataSchema>;
/**
 * Record Metric Request
 *
 * Telemetry Interface Request Wrapper RecordMetricRequest for JsSpan.recordMetric
 */
export declare const RecordMetricRequestSchema: z.ZodObject<{
    attributes: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
    counter: z.ZodOptional<z.ZodObject<{
        doubleValue: z.ZodOptional<z.ZodNumber>;
        uint64Value: z.ZodOptional<z.ZodNumber>;
    }, z.core.$strip>>;
    gauge: z.ZodOptional<z.ZodObject<{
        doubleValue: z.ZodOptional<z.ZodNumber>;
        int64Value: z.ZodOptional<z.ZodNumber>;
    }, z.core.$strip>>;
    histogram: z.ZodOptional<z.ZodObject<{
        doubleValue: z.ZodOptional<z.ZodNumber>;
        uint64Value: z.ZodOptional<z.ZodNumber>;
    }, z.core.$strip>>;
    name: z.ZodString;
}, z.core.$strip>;
/**
 * Record Metric Request
 *
 * Telemetry Interface Request Wrapper RecordMetricRequest for JsSpan.recordMetric
 *
 * @property {Record<string, unknown>} [attributes] - Optional attributes (key-value pairs) to attach to the metric.
 * @property {CounterMetric} [counter] - Counter metric.
 * @property {GaugeMetric} [gauge] - Gauge metric.
 * @property {HistogramMetric} [histogram] - Histogram metric.
 * @property {string} name - Name of the metric to record.
 */
export type RecordMetricRequest = z.infer<typeof RecordMetricRequestSchema>;
/**
 * Text Embedder Creation Config
 *
 * TextEmbedderCreationConfig encapsulates the configuration details for creating either a local or remote embedding model.
 */
export declare const TextEmbedderCreationConfigSchema: z.ZodObject<{
    localConfig: z.ZodOptional<z.ZodObject<{
        device: z.ZodObject<{
            index: z.ZodNumber;
            type: z.ZodPipe<z.ZodUnion<readonly [z.ZodEnum<{
                CPU: "CPU";
                CUDA: "CUDA";
                Metal: "Metal";
                ROCm: "ROCm";
            }>]>, z.ZodTransform<string, "CPU" | "CUDA" | "Metal" | "ROCm">>;
        }, z.core.$strip>;
        modelPath: z.ZodString;
    }, z.core.$strip>>;
    remoteConfig: z.ZodOptional<z.ZodObject<{
        apiKey: z.ZodString;
        defaultTimeout: z.ZodOptional<z.ZodString>;
        endpointOverride: z.ZodOptional<z.ZodString>;
        modelName: z.ZodString;
        provider: z.ZodString;
    }, z.core.$strip>>;
}, z.core.$strip>;
/**
 * Text Embedder Creation Config
 *
 * TextEmbedderCreationConfig encapsulates the configuration details for creating either a local or remote embedding model.
 *
 * @property {LocalTextEmbedderConfig} [localConfig] - Local text embedder configuration.
 * @property {RemoteTextEmbedderConfig} [remoteConfig] - Remote text embedder configuration.
 */
export type TextEmbedderCreationConfig = z.infer<typeof TextEmbedderCreationConfigSchema>;
/**
 * Local Knowledge Config
 *
 * LocalKnowledgeConfig specifies the parameters for initializing a local knowledge system.
 */
export declare const LocalKnowledgeConfigSchema: z.ZodObject<{
    embedderComponentId: z.ZodString;
    knowledgeCompileConfig: z.ZodObject<{
        parsingConfig: z.ZodObject<{
            maxCharsPerChunk: z.ZodNumber;
            maxChunksPerDocument: z.ZodNumber;
        }, z.core.$strip>;
    }, z.core.$strip>;
}, z.core.$strip>;
/**
 * Local Knowledge Config
 *
 * LocalKnowledgeConfig specifies the parameters for initializing a local knowledge system.
 *
 * @property {string} embedderComponentId - Embedder component ID for registry lookup.
 * @property {KnowledgeCompileConfig} knowledgeCompileConfig - Configuration for knowledge compilation.
 */
export type LocalKnowledgeConfig = z.infer<typeof LocalKnowledgeConfigSchema>;
/**
 * Message
 *
 * Message represents a chat message in a conversation. For text-only messages, use `content`. For multimodal, use `content_items`.
 */
export declare const MessageSchema: z.ZodObject<{
    content: z.ZodOptional<z.ZodString>;
    contentItems: z.ZodOptional<z.ZodArray<z.ZodObject<{
        image: z.ZodOptional<z.ZodObject<{
            detail: z.ZodOptional<z.ZodPipe<z.ZodUnion<readonly [z.ZodEnum<{
                auto: "auto";
                high: "high";
                low: "low";
            }>]>, z.ZodTransform<string, "auto" | "high" | "low">>>;
            url: z.ZodString;
        }, z.core.$strip>>;
        text: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>>>;
    role: z.ZodString;
    toolCallId: z.ZodOptional<z.ZodString>;
    toolCalls: z.ZodOptional<z.ZodArray<z.ZodObject<{
        args: z.ZodOptional<z.ZodString>;
        id: z.ZodString;
        name: z.ZodString;
    }, z.core.$strip>>>;
}, z.core.$strip>;
/**
 * Message
 *
 * Message represents a chat message in a conversation. For text-only messages, use `content`. For multimodal, use `content_items`.
 *
 * @property {string} [content] - Text content for text-only messages.
 * @property {ContentItem[]} [contentItems] - Content items for multimodal messages (text + images). If not empty, this takes precedence over `content`.
 * @property {string} role - Message role: "system", "user", or "assistant".
 * @property {string} [toolCallId] - Tool call ID this message is responding to (for 'tool' role).
 * @property {ToolCall[]} [toolCalls] - Tool calls generated by the model.
 */
export type Message = z.infer<typeof MessageSchema>;
/**
 * Get Models Response
 *
 * GetModelsResponse for LLMInterface.GetModels
 */
export declare const GetModelsResponseSchema: z.ZodObject<{
    models: z.ZodOptional<z.ZodArray<z.ZodObject<{
        benchmarks: z.ZodOptional<z.ZodObject<{
            codingIndex: z.ZodOptional<z.ZodNumber>;
            intelligenceIndex: z.ZodOptional<z.ZodNumber>;
            mathIndex: z.ZodOptional<z.ZodNumber>;
        }, z.core.$strip>>;
        modelId: z.ZodObject<{
            modelName: z.ZodOptional<z.ZodString>;
            provider: z.ZodString;
        }, z.core.$strip>;
        performance: z.ZodOptional<z.ZodObject<{
            medianOutputTokensPerSecond: z.ZodOptional<z.ZodNumber>;
            medianTimeToFirstAnswerToken: z.ZodOptional<z.ZodNumber>;
            medianTimeToFirstTokenSeconds: z.ZodOptional<z.ZodNumber>;
        }, z.core.$strip>>;
        pricing: z.ZodOptional<z.ZodObject<{
            completion: z.ZodOptional<z.ZodNumber>;
            image: z.ZodOptional<z.ZodNumber>;
            internalReasoning: z.ZodOptional<z.ZodNumber>;
            prompt: z.ZodOptional<z.ZodNumber>;
            request: z.ZodOptional<z.ZodNumber>;
            webSearch: z.ZodOptional<z.ZodNumber>;
        }, z.core.$strip>>;
        spec: z.ZodOptional<z.ZodObject<{
            contextLength: z.ZodOptional<z.ZodNumber>;
            description: z.ZodOptional<z.ZodString>;
            inputModalities: z.ZodOptional<z.ZodArray<z.ZodString>>;
            maxCompletionTokens: z.ZodOptional<z.ZodNumber>;
            outputModalities: z.ZodOptional<z.ZodArray<z.ZodString>>;
            supportedParameters: z.ZodOptional<z.ZodArray<z.ZodString>>;
        }, z.core.$strip>>;
    }, z.core.$strip>>>;
}, z.core.$strip>;
/**
 * Get Models Response
 *
 * GetModelsResponse for LLMInterface.GetModels
 *
 * @property {ModelInfo[]} [models] - List of models matching the request filters
 */
export type GetModelsResponse = z.infer<typeof GetModelsResponseSchema>;
/**
 * LLM Creation Config
 *
 * LLMCreationConfig represents a configuration for creating new LLM.
 */
export declare const LLMCreationConfigSchema: z.ZodObject<{
    localConfig: z.ZodOptional<z.ZodObject<{
        defaultConfig: z.ZodObject<{
            frequencyPenalty: z.ZodOptional<z.ZodNumber>;
            logitBias: z.ZodOptional<z.ZodArray<z.ZodObject<{
                biasValue: z.ZodNumber;
                tokenId: z.ZodString;
            }, z.core.$strip>>>;
            maxNewTokens: z.ZodOptional<z.ZodNumber>;
            maxPromptLength: z.ZodOptional<z.ZodNumber>;
            presencePenalty: z.ZodOptional<z.ZodNumber>;
            repetitionPenalty: z.ZodOptional<z.ZodNumber>;
            seed: z.ZodOptional<z.ZodNumber>;
            stopSequences: z.ZodOptional<z.ZodArray<z.ZodString>>;
            temperature: z.ZodOptional<z.ZodNumber>;
            topP: z.ZodOptional<z.ZodNumber>;
        }, z.core.$strip>;
        device: z.ZodObject<{
            index: z.ZodNumber;
            type: z.ZodPipe<z.ZodUnion<readonly [z.ZodEnum<{
                CPU: "CPU";
                CUDA: "CUDA";
                Metal: "Metal";
                ROCm: "ROCm";
            }>]>, z.ZodTransform<string, "CPU" | "CUDA" | "Metal" | "ROCm">>;
        }, z.core.$strip>;
        modelPath: z.ZodString;
    }, z.core.$strip>>;
    remoteConfig: z.ZodOptional<z.ZodObject<{
        apiKey: z.ZodString;
        defaultConfig: z.ZodObject<{
            frequencyPenalty: z.ZodOptional<z.ZodNumber>;
            logitBias: z.ZodOptional<z.ZodArray<z.ZodObject<{
                biasValue: z.ZodNumber;
                tokenId: z.ZodString;
            }, z.core.$strip>>>;
            maxNewTokens: z.ZodOptional<z.ZodNumber>;
            maxPromptLength: z.ZodOptional<z.ZodNumber>;
            presencePenalty: z.ZodOptional<z.ZodNumber>;
            repetitionPenalty: z.ZodOptional<z.ZodNumber>;
            seed: z.ZodOptional<z.ZodNumber>;
            stopSequences: z.ZodOptional<z.ZodArray<z.ZodString>>;
            temperature: z.ZodOptional<z.ZodNumber>;
            topP: z.ZodOptional<z.ZodNumber>;
        }, z.core.$strip>;
        defaultTimeout: z.ZodOptional<z.ZodString>;
        endpointOverride: z.ZodOptional<z.ZodString>;
        modelName: z.ZodString;
        provider: z.ZodString;
    }, z.core.$strip>>;
}, z.core.$strip>;
/**
 * LLM Creation Config
 *
 * LLMCreationConfig represents a configuration for creating new LLM.
 *
 * @property {LocalLLMConfig} [localConfig] - Local LLM configuration.
 * @property {RemoteLLMConfig} [remoteConfig] - Remote LLM configuration.
 */
export type LLMCreationConfig = z.infer<typeof LLMCreationConfigSchema>;
/**
 * MCP Client Creation Config
 *
 * MCPClientCreationConfig configuration for creating an MCP client.
 */
export declare const MCPClientCreationConfigSchema: z.ZodObject<{
    sessionConfig: z.ZodObject<{
        endpoint: z.ZodString;
        httpConfig: z.ZodOptional<z.ZodObject<{
            apiKey: z.ZodString;
            defaultTimeout: z.ZodOptional<z.ZodString>;
        }, z.core.$strip>>;
        paragonConfig: z.ZodOptional<z.ZodObject<{
            defaultTimeout: z.ZodOptional<z.ZodString>;
            jwtToken: z.ZodString;
        }, z.core.$strip>>;
        stdioConfig: z.ZodOptional<z.ZodObject<{
            env: z.ZodRecord<z.ZodString, z.ZodString>;
        }, z.core.$strip>>;
        transport: z.ZodString;
    }, z.core.$strip>;
}, z.core.$strip>;
/**
 * MCP Client Creation Config
 *
 * MCPClientCreationConfig configuration for creating an MCP client.
 *
 * @property {MCPSessionCreationConfig} sessionConfig - The session configuration.
 */
export type MCPClientCreationConfig = z.infer<typeof MCPClientCreationConfigSchema>;
/**
 * Classify Text Request
 *
 * ClassifyTextRequest for TextClassifierInterface.ClassifyText
 */
export declare const ClassifyTextRequestSchema: z.ZodObject<{
    config: z.ZodOptional<z.ZodObject<{
        classes: z.ZodArray<z.ZodObject<{
            classLabel: z.ZodString;
            threshold: z.ZodNumber;
        }, z.core.$strip>>;
    }, z.core.$strip>>;
    text: z.ZodString;
}, z.core.$strip>;
/**
 * Classify Text Request
 *
 * ClassifyTextRequest for TextClassifierInterface.ClassifyText
 *
 * @property {TextClassifierConfig} [config] - Optional text classifier configuration override
 * @property {string} text - Text to classify
 */
export type ClassifyTextRequest = z.infer<typeof ClassifyTextRequestSchema>;
/**
 * Intent Matcher Config
 *
 * IntentMatcherConfig configuration for intent matching.
 */
export declare const IntentMatcherConfigSchema: z.ZodObject<{
    embedding: z.ZodOptional<z.ZodObject<{
        similarityThreshold: z.ZodNumber;
    }, z.core.$strip>>;
    llm: z.ZodOptional<z.ZodObject<{
        embeddingSimilarityThreshold: z.ZodOptional<z.ZodNumber>;
        generationConfig: z.ZodOptional<z.ZodObject<{
            frequencyPenalty: z.ZodOptional<z.ZodNumber>;
            logitBias: z.ZodOptional<z.ZodArray<z.ZodObject<{
                biasValue: z.ZodNumber;
                tokenId: z.ZodString;
            }, z.core.$strip>>>;
            maxNewTokens: z.ZodOptional<z.ZodNumber>;
            maxPromptLength: z.ZodOptional<z.ZodNumber>;
            presencePenalty: z.ZodOptional<z.ZodNumber>;
            repetitionPenalty: z.ZodOptional<z.ZodNumber>;
            seed: z.ZodOptional<z.ZodNumber>;
            stopSequences: z.ZodOptional<z.ZodArray<z.ZodString>>;
            temperature: z.ZodOptional<z.ZodNumber>;
            topP: z.ZodOptional<z.ZodNumber>;
        }, z.core.$strip>>;
        maxEmbeddingMatchesForLlm: z.ZodOptional<z.ZodNumber>;
        promptTemplate: z.ZodString;
    }, z.core.$strip>>;
    topNIntents: z.ZodOptional<z.ZodNumber>;
}, z.core.$strip>;
/**
 * Intent Matcher Config
 *
 * IntentMatcherConfig configuration for intent matching.
 *
 * @property {EmbeddingMatcherConfig} [embedding] - Optional embedding-based matching configuration.
 * @property {LLMMatcherConfig} [llm] - Optional LLM-based matching configuration.
 * @property {number} [topNIntents] - Number of top-scoring intents to return.
 */
export type IntentMatcherConfig = z.infer<typeof IntentMatcherConfigSchema>;
export declare const NerCreationConfigSchema: z.ZodObject<{
    entities: z.ZodArray<z.ZodObject<{
        name: z.ZodString;
        rules: z.ZodArray<z.ZodObject<{
            displayName: z.ZodString;
            name: z.ZodString;
            synonyms: z.ZodOptional<z.ZodArray<z.ZodString>>;
        }, z.core.$strip>>;
    }, z.core.$strip>>;
}, z.core.$strip>;
export type NerCreationConfig = z.infer<typeof NerCreationConfigSchema>;
/**
 * Google Serper Api Search Response
 *
 * GoogleSerperApiSearchResponse from GoogleSerperAPIClientInterface.Search
 */
export declare const GoogleSerperApiSearchResponseSchema: z.ZodObject<{
    credits: z.ZodOptional<z.ZodNumber>;
    knowledgeGraph: z.ZodOptional<z.ZodObject<{
        attributes: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
        description: z.ZodOptional<z.ZodString>;
        descriptionLink: z.ZodOptional<z.ZodString>;
        descriptionSource: z.ZodOptional<z.ZodString>;
        imageUrl: z.ZodOptional<z.ZodString>;
        title: z.ZodOptional<z.ZodString>;
        type: z.ZodOptional<z.ZodString>;
        website: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>>;
    organicResults: z.ZodOptional<z.ZodArray<z.ZodObject<{
        attributes: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
        date: z.ZodOptional<z.ZodString>;
        link: z.ZodOptional<z.ZodString>;
        position: z.ZodOptional<z.ZodNumber>;
        sitelinks: z.ZodOptional<z.ZodArray<z.ZodObject<{
            link: z.ZodOptional<z.ZodString>;
            title: z.ZodOptional<z.ZodString>;
        }, z.core.$strip>>>;
        snippet: z.ZodOptional<z.ZodString>;
        title: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>>>;
    peopleAlsoAsk: z.ZodOptional<z.ZodArray<z.ZodObject<{
        link: z.ZodOptional<z.ZodString>;
        question: z.ZodOptional<z.ZodString>;
        snippet: z.ZodOptional<z.ZodString>;
        title: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>>>;
    relatedSearches: z.ZodOptional<z.ZodArray<z.ZodString>>;
    topStories: z.ZodOptional<z.ZodArray<z.ZodObject<{
        date: z.ZodOptional<z.ZodString>;
        link: z.ZodOptional<z.ZodString>;
        source: z.ZodOptional<z.ZodString>;
        title: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>>>;
}, z.core.$strip>;
/**
 * Google Serper Api Search Response
 *
 * GoogleSerperApiSearchResponse from GoogleSerperAPIClientInterface.Search
 *
 * @property {number} [credits] - The credits used for the request
 * @property {KnowledgeGraph} [knowledgeGraph] - The optional knowledge graph
 * @property {OrganicResult[]} [organicResults] - The vector of search results
 * @property {PeopleAlsoAsk[]} [peopleAlsoAsk] - The vector of people also ask
 * @property {string[]} [relatedSearches] - The vector of related searches
 * @property {TopStory[]} [topStories] - The vector of top stories
 */
export type GoogleSerperApiSearchResponse = z.infer<typeof GoogleSerperApiSearchResponseSchema>;
/**
 * AEC Filter Creation Config
 *
 * AECFilterCreationConfig encapsulates the configuration for creating an AEC filter.
 */
export declare const AECFilterCreationConfigSchema: z.ZodObject<{
    localConfig: z.ZodOptional<z.ZodObject<{
        defaultConfig: z.ZodObject<{}, z.core.$strip>;
        device: z.ZodObject<{
            index: z.ZodNumber;
            type: z.ZodPipe<z.ZodUnion<readonly [z.ZodEnum<{
                CPU: "CPU";
                CUDA: "CUDA";
                Metal: "Metal";
                ROCm: "ROCm";
            }>]>, z.ZodTransform<string, "CPU" | "CUDA" | "Metal" | "ROCm">>;
        }, z.core.$strip>;
    }, z.core.$strip>>;
}, z.core.$strip>;
/**
 * AEC Filter Creation Config
 *
 * AECFilterCreationConfig encapsulates the configuration for creating an AEC filter.
 *
 * @property {LocalAECFilterConfig} [localConfig] - Local AEC filter configuration.
 */
export type AECFilterCreationConfig = z.infer<typeof AECFilterCreationConfigSchema>;
/**
 * Detect Turn Completion Request
 *
 * Turn Detector Interface Request Wrapper DetectTurnCompletionRequest for TurnDetectorInterface.DetectTurnCompletion
 */
export declare const DetectTurnCompletionRequestSchema: z.ZodObject<{
    audioChunk: z.ZodObject<{
        data: z.ZodOptional<z.ZodCustom<Float32Array<ArrayBuffer>, Float32Array<ArrayBuffer>>>;
        sampleRate: z.ZodNumber;
        timestamps: z.ZodOptional<z.ZodArray<z.ZodObject<{
            endTime: z.ZodNumber;
            startTime: z.ZodNumber;
            token: z.ZodString;
        }, z.core.$strip>>>;
    }, z.core.$strip>;
    config: z.ZodOptional<z.ZodObject<{
        threshold: z.ZodNumber;
    }, z.core.$strip>>;
}, z.core.$strip>;
/**
 * Detect Turn Completion Request
 *
 * Turn Detector Interface Request Wrapper DetectTurnCompletionRequest for TurnDetectorInterface.DetectTurnCompletion
 *
 * @property {AudioChunk} audioChunk - Audio chunk to analyze
 * @property {TurnDetectionConfig} [config] - Optional turn detection configuration override
 */
export type DetectTurnCompletionRequest = z.infer<typeof DetectTurnCompletionRequestSchema>;
/**
 * Speech Synthesis Config
 *
 * SpeechSynthesisConfig specifies the configuration for speech synthesis.
 */
export declare const SpeechSynthesisConfigSchema: z.ZodObject<{
    elevenlabsConfig: z.ZodOptional<z.ZodObject<{
        queryParams: z.ZodObject<{
            enableLogging: z.ZodOptional<z.ZodBoolean>;
            outputFormat: z.ZodEnum<{
                ELEVENLABS_OUTPUT_FORMAT_MP3_22050_32: "ELEVENLABS_OUTPUT_FORMAT_MP3_22050_32";
                ELEVENLABS_OUTPUT_FORMAT_MP3_44100_128: "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_128";
                ELEVENLABS_OUTPUT_FORMAT_MP3_44100_192: "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_192";
                ELEVENLABS_OUTPUT_FORMAT_MP3_44100_32: "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_32";
                ELEVENLABS_OUTPUT_FORMAT_MP3_44100_64: "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_64";
                ELEVENLABS_OUTPUT_FORMAT_MP3_44100_96: "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_96";
                ELEVENLABS_OUTPUT_FORMAT_UNSPECIFIED: "ELEVENLABS_OUTPUT_FORMAT_UNSPECIFIED";
            }>;
        }, z.core.$strip>;
        requestParams: z.ZodObject<{
            applyTextNormalization: z.ZodEnum<{
                ELEVENLABS_TEXT_NORMALIZATION_AUTO: "ELEVENLABS_TEXT_NORMALIZATION_AUTO";
                ELEVENLABS_TEXT_NORMALIZATION_OFF: "ELEVENLABS_TEXT_NORMALIZATION_OFF";
                ELEVENLABS_TEXT_NORMALIZATION_ON: "ELEVENLABS_TEXT_NORMALIZATION_ON";
                ELEVENLABS_TEXT_NORMALIZATION_UNSPECIFIED: "ELEVENLABS_TEXT_NORMALIZATION_UNSPECIFIED";
            }>;
            modelId: z.ZodString;
        }, z.core.$strip>;
    }, z.core.$strip>>;
    inworldConfig: z.ZodOptional<z.ZodObject<{
        inference: z.ZodObject<{
            speakingRate: z.ZodNumber;
            temperature: z.ZodNumber;
        }, z.core.$strip>;
        modelId: z.ZodOptional<z.ZodString>;
        postprocessing: z.ZodObject<{
            sampleRate: z.ZodNumber;
        }, z.core.$strip>;
        timestampType: z.ZodOptional<z.ZodEnum<{
            TIMESTAMP_TYPE_CHARACTER: "TIMESTAMP_TYPE_CHARACTER";
            TIMESTAMP_TYPE_UNSPECIFIED: "TIMESTAMP_TYPE_UNSPECIFIED";
            TIMESTAMP_TYPE_WORD: "TIMESTAMP_TYPE_WORD";
        }>>;
    }, z.core.$strip>>;
}, z.core.$strip>;
/**
 * Speech Synthesis Config
 *
 * SpeechSynthesisConfig specifies the configuration for speech synthesis.
 *
 * @property {ElevenLabsSpeechSynthesisConfig} [elevenlabsConfig] - ElevenLabs speech synthesis configuration.
 * @property {InworldSpeechSynthesisConfig} [inworldConfig] - Inworld speech synthesis configuration.
 */
export type SpeechSynthesisConfig = z.infer<typeof SpeechSynthesisConfigSchema>;
export declare const RemoteTtsConfigSchema: z.ZodObject<{
    apiKey: z.ZodString;
    defaultTimeout: z.ZodOptional<z.ZodString>;
    endpointOverride: z.ZodOptional<z.ZodString>;
    synthesisConfig: z.ZodObject<{
        elevenlabsConfig: z.ZodOptional<z.ZodObject<{
            queryParams: z.ZodObject<{
                enableLogging: z.ZodOptional<z.ZodBoolean>;
                outputFormat: z.ZodEnum<{
                    ELEVENLABS_OUTPUT_FORMAT_MP3_22050_32: "ELEVENLABS_OUTPUT_FORMAT_MP3_22050_32";
                    ELEVENLABS_OUTPUT_FORMAT_MP3_44100_128: "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_128";
                    ELEVENLABS_OUTPUT_FORMAT_MP3_44100_192: "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_192";
                    ELEVENLABS_OUTPUT_FORMAT_MP3_44100_32: "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_32";
                    ELEVENLABS_OUTPUT_FORMAT_MP3_44100_64: "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_64";
                    ELEVENLABS_OUTPUT_FORMAT_MP3_44100_96: "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_96";
                    ELEVENLABS_OUTPUT_FORMAT_UNSPECIFIED: "ELEVENLABS_OUTPUT_FORMAT_UNSPECIFIED";
                }>;
            }, z.core.$strip>;
            requestParams: z.ZodObject<{
                applyTextNormalization: z.ZodEnum<{
                    ELEVENLABS_TEXT_NORMALIZATION_AUTO: "ELEVENLABS_TEXT_NORMALIZATION_AUTO";
                    ELEVENLABS_TEXT_NORMALIZATION_OFF: "ELEVENLABS_TEXT_NORMALIZATION_OFF";
                    ELEVENLABS_TEXT_NORMALIZATION_ON: "ELEVENLABS_TEXT_NORMALIZATION_ON";
                    ELEVENLABS_TEXT_NORMALIZATION_UNSPECIFIED: "ELEVENLABS_TEXT_NORMALIZATION_UNSPECIFIED";
                }>;
                modelId: z.ZodString;
            }, z.core.$strip>;
        }, z.core.$strip>>;
        inworldConfig: z.ZodOptional<z.ZodObject<{
            inference: z.ZodObject<{
                speakingRate: z.ZodNumber;
                temperature: z.ZodNumber;
            }, z.core.$strip>;
            modelId: z.ZodOptional<z.ZodString>;
            postprocessing: z.ZodObject<{
                sampleRate: z.ZodNumber;
            }, z.core.$strip>;
            timestampType: z.ZodOptional<z.ZodEnum<{
                TIMESTAMP_TYPE_CHARACTER: "TIMESTAMP_TYPE_CHARACTER";
                TIMESTAMP_TYPE_UNSPECIFIED: "TIMESTAMP_TYPE_UNSPECIFIED";
                TIMESTAMP_TYPE_WORD: "TIMESTAMP_TYPE_WORD";
            }>>;
        }, z.core.$strip>>;
    }, z.core.$strip>;
}, z.core.$strip>;
export type RemoteTtsConfig = z.infer<typeof RemoteTtsConfigSchema>;
/**
 * Telemetry Config
 *
 * TelemetryConfig provides comprehensive telemetry configuration.
 */
export declare const TelemetryConfigSchema: z.ZodObject<{
    apiKey: z.ZodOptional<z.ZodString>;
    endpoint: z.ZodOptional<z.ZodString>;
    exporterType: z.ZodOptional<z.ZodEnum<{
        EXPORTER_TYPE_LOCAL: "EXPORTER_TYPE_LOCAL";
        EXPORTER_TYPE_REMOTE: "EXPORTER_TYPE_REMOTE";
        EXPORTER_TYPE_UNSPECIFIED: "EXPORTER_TYPE_UNSPECIFIED";
    }>>;
    flushTimeoutMs: z.ZodOptional<z.ZodNumber>;
    logger: z.ZodOptional<z.ZodObject<{
        batchProcessingOpts: z.ZodOptional<z.ZodObject<{
            maxExportBatchSize: z.ZodOptional<z.ZodNumber>;
            maxQueueSize: z.ZodOptional<z.ZodNumber>;
            scheduleDelayMillis: z.ZodOptional<z.ZodNumber>;
        }, z.core.$strip>>;
        logLevel: z.ZodOptional<z.ZodEnum<{
            LOG_LEVEL_DEBUG: "LOG_LEVEL_DEBUG";
            LOG_LEVEL_ERROR: "LOG_LEVEL_ERROR";
            LOG_LEVEL_INFO: "LOG_LEVEL_INFO";
            LOG_LEVEL_TRACE: "LOG_LEVEL_TRACE";
            LOG_LEVEL_UNSPECIFIED: "LOG_LEVEL_UNSPECIFIED";
            LOG_LEVEL_WARN: "LOG_LEVEL_WARN";
        }>>;
        sinkAbslLogs: z.ZodOptional<z.ZodBoolean>;
    }, z.core.$strip>>;
    metrics: z.ZodOptional<z.ZodObject<{
        exportInterval: z.ZodOptional<z.ZodNumber>;
        exportTimeout: z.ZodOptional<z.ZodNumber>;
        metricCacheSize: z.ZodOptional<z.ZodNumber>;
        metrics: z.ZodOptional<z.ZodArray<z.ZodObject<{
            description: z.ZodOptional<z.ZodString>;
            metricKind: z.ZodOptional<z.ZodEnum<{
                METRIC_KIND_COUNTER: "METRIC_KIND_COUNTER";
                METRIC_KIND_GAUGE: "METRIC_KIND_GAUGE";
                METRIC_KIND_HISTOGRAM: "METRIC_KIND_HISTOGRAM";
                METRIC_KIND_UNSPECIFIED: "METRIC_KIND_UNSPECIFIED";
            }>>;
            name: z.ZodOptional<z.ZodString>;
            unit: z.ZodOptional<z.ZodString>;
            valueType: z.ZodOptional<z.ZodEnum<{
                METRIC_VALUE_TYPE_DOUBLE: "METRIC_VALUE_TYPE_DOUBLE";
                METRIC_VALUE_TYPE_INTEGER: "METRIC_VALUE_TYPE_INTEGER";
                METRIC_VALUE_TYPE_UNSPECIFIED: "METRIC_VALUE_TYPE_UNSPECIFIED";
            }>>;
        }, z.core.$strip>>>;
    }, z.core.$strip>>;
    sdkName: z.ZodOptional<z.ZodString>;
    sdkVersion: z.ZodOptional<z.ZodString>;
    serviceName: z.ZodOptional<z.ZodString>;
    serviceVersion: z.ZodOptional<z.ZodString>;
    shutdownTimeoutMs: z.ZodOptional<z.ZodNumber>;
    tracer: z.ZodOptional<z.ZodObject<{
        batchProcessingOpts: z.ZodOptional<z.ZodObject<{
            maxExportBatchSize: z.ZodOptional<z.ZodNumber>;
            maxQueueSize: z.ZodOptional<z.ZodNumber>;
            scheduleDelayMillis: z.ZodOptional<z.ZodNumber>;
        }, z.core.$strip>>;
        enableSpanCapture: z.ZodOptional<z.ZodBoolean>;
        maxSpanCaptureQueueSize: z.ZodOptional<z.ZodNumber>;
        samplingRate: z.ZodOptional<z.ZodNumber>;
        spanDumpPath: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>>;
}, z.core.$strip>;
/**
 * Telemetry Config
 *
 * TelemetryConfig provides comprehensive telemetry configuration.
 *
 * @property {string} [apiKey] - API key for authentication with remote telemetry endpoint.
 * @property {string} [endpoint] - Endpoint for remote telemetry export.
 * @property {'EXPORTER_TYPE_UNSPECIFIED' | 'EXPORTER_TYPE_LOCAL' | 'EXPORTER_TYPE_REMOTE'} [exporterType] - Exporter Type. Type of exporter to use.
 * @remarks exporterType allowed values: "EXPORTER_TYPE_UNSPECIFIED", "EXPORTER_TYPE_LOCAL", "EXPORTER_TYPE_REMOTE"
 * @property {number} [flushTimeoutMs] - Timeout in milliseconds for flush operations.
 * @property {LoggerConfig} [logger] - Logger configuration.
 * @property {MetricsConfig} [metrics] - Metrics configuration.
 * @property {string} [sdkName] - Name of the SDK generating telemetry.
 * @property {string} [sdkVersion] - Version of the SDK.
 * @property {string} [serviceName] - Name of the service generating telemetry.
 * @property {string} [serviceVersion] - Version of the service.
 * @property {number} [shutdownTimeoutMs] - Timeout in milliseconds for shutdown operations.
 * @property {TracerConfig} [tracer] - Tracer configuration.
 */
export type TelemetryConfig = z.infer<typeof TelemetryConfigSchema>;
/**
 * Dequeue Span Traces Response
 *
 * DequeueSpanTracesResponse - Response for dequeueSpanTraces method
 */
export declare const DequeueSpanTracesResponseSchema: z.ZodObject<{
    spans: z.ZodOptional<z.ZodArray<z.ZodObject<{
        attributes: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
        description: z.ZodOptional<z.ZodString>;
        durationInNanos: z.ZodOptional<z.ZodNumber>;
        events: z.ZodOptional<z.ZodArray<z.ZodObject<{
            attributes: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
            name: z.ZodOptional<z.ZodString>;
            timestampInNanos: z.ZodOptional<z.ZodNumber>;
        }, z.core.$strip>>>;
        kind: z.ZodOptional<z.ZodEnum<{
            SPAN_KIND_CLIENT: "SPAN_KIND_CLIENT";
            SPAN_KIND_CONSUMER: "SPAN_KIND_CONSUMER";
            SPAN_KIND_INTERNAL: "SPAN_KIND_INTERNAL";
            SPAN_KIND_PRODUCER: "SPAN_KIND_PRODUCER";
            SPAN_KIND_SERVER: "SPAN_KIND_SERVER";
            SPAN_KIND_UNSPECIFIED: "SPAN_KIND_UNSPECIFIED";
        }>>;
        name: z.ZodOptional<z.ZodString>;
        parentSpanId: z.ZodOptional<z.ZodString>;
        spanId: z.ZodOptional<z.ZodString>;
        startTimeInNanos: z.ZodOptional<z.ZodNumber>;
        status: z.ZodOptional<z.ZodEnum<{
            SPAN_STATUS_ERROR: "SPAN_STATUS_ERROR";
            SPAN_STATUS_OK: "SPAN_STATUS_OK";
            SPAN_STATUS_UNSET: "SPAN_STATUS_UNSET";
        }>>;
        traceId: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>>>;
}, z.core.$strip>;
/**
 * Dequeue Span Traces Response
 *
 * DequeueSpanTracesResponse - Response for dequeueSpanTraces method
 *
 * @property {SpanData[]} [spans] - Array of span data traces
 */
export type DequeueSpanTracesResponse = z.infer<typeof DequeueSpanTracesResponseSchema>;
/**
 * Knowledge Creation Config
 *
 * KnowledgeCreationConfig encapsulates the configuration for creating a knowledge system.
 */
export declare const KnowledgeCreationConfigSchema: z.ZodObject<{
    localConfig: z.ZodOptional<z.ZodObject<{
        embedderComponentId: z.ZodString;
        knowledgeCompileConfig: z.ZodObject<{
            parsingConfig: z.ZodObject<{
                maxCharsPerChunk: z.ZodNumber;
                maxChunksPerDocument: z.ZodNumber;
            }, z.core.$strip>;
        }, z.core.$strip>;
    }, z.core.$strip>>;
    remoteConfig: z.ZodOptional<z.ZodObject<{
        apiKey: z.ZodString;
        defaultTimeout: z.ZodOptional<z.ZodString>;
        endpointOverride: z.ZodOptional<z.ZodString>;
        knowledgeCompileConfig: z.ZodObject<{
            parsingConfig: z.ZodObject<{
                maxCharsPerChunk: z.ZodNumber;
                maxChunksPerDocument: z.ZodNumber;
            }, z.core.$strip>;
        }, z.core.$strip>;
        language: z.ZodOptional<z.ZodObject<{
            code: z.ZodString;
            locale: z.ZodOptional<z.ZodString>;
        }, z.core.$strip>>;
    }, z.core.$strip>>;
}, z.core.$strip>;
/**
 * Knowledge Creation Config
 *
 * KnowledgeCreationConfig encapsulates the configuration for creating a knowledge system.
 *
 * @property {LocalKnowledgeConfig} [localConfig] - Local knowledge configuration.
 * @property {RemoteKnowledgeConfig} [remoteConfig] - Remote knowledge configuration.
 */
export type KnowledgeCreationConfig = z.infer<typeof KnowledgeCreationConfigSchema>;
/**
 * Generate Content Chat Request
 *
 * GenerateContentChatRequest for LLMInterface.GenerateContentChat
 */
export declare const GenerateContentChatRequestSchema: z.ZodObject<{
    config: z.ZodOptional<z.ZodObject<{
        frequencyPenalty: z.ZodOptional<z.ZodNumber>;
        logitBias: z.ZodOptional<z.ZodArray<z.ZodObject<{
            biasValue: z.ZodNumber;
            tokenId: z.ZodString;
        }, z.core.$strip>>>;
        maxNewTokens: z.ZodOptional<z.ZodNumber>;
        maxPromptLength: z.ZodOptional<z.ZodNumber>;
        presencePenalty: z.ZodOptional<z.ZodNumber>;
        repetitionPenalty: z.ZodOptional<z.ZodNumber>;
        seed: z.ZodOptional<z.ZodNumber>;
        stopSequences: z.ZodOptional<z.ZodArray<z.ZodString>>;
        temperature: z.ZodOptional<z.ZodNumber>;
        topP: z.ZodOptional<z.ZodNumber>;
    }, z.core.$strip>>;
    credentials: z.ZodOptional<z.ZodObject<{
        inworldApiKey: z.ZodOptional<z.ZodString>;
        inworldJwt: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>>;
    messages: z.ZodArray<z.ZodObject<{
        content: z.ZodOptional<z.ZodString>;
        contentItems: z.ZodOptional<z.ZodArray<z.ZodObject<{
            image: z.ZodOptional<z.ZodObject<{
                detail: z.ZodOptional<z.ZodPipe<z.ZodUnion<readonly [z.ZodEnum<{
                    auto: "auto";
                    high: "high";
                    low: "low";
                }>]>, z.ZodTransform<string, "auto" | "high" | "low">>>;
                url: z.ZodString;
            }, z.core.$strip>>;
            text: z.ZodOptional<z.ZodString>;
        }, z.core.$strip>>>;
        role: z.ZodString;
        toolCallId: z.ZodOptional<z.ZodString>;
        toolCalls: z.ZodOptional<z.ZodArray<z.ZodObject<{
            args: z.ZodOptional<z.ZodString>;
            id: z.ZodString;
            name: z.ZodString;
        }, z.core.$strip>>>;
    }, z.core.$strip>>;
    reasoning: z.ZodOptional<z.ZodObject<{
        effort: z.ZodOptional<z.ZodEnum<{
            EFFORT_HIGH: "EFFORT_HIGH";
            EFFORT_LOW: "EFFORT_LOW";
            EFFORT_MEDIUM: "EFFORT_MEDIUM";
            EFFORT_MINIMAL: "EFFORT_MINIMAL";
            EFFORT_NONE: "EFFORT_NONE";
            EFFORT_UNSPECIFIED: "EFFORT_UNSPECIFIED";
            EFFORT_XHIGH: "EFFORT_XHIGH";
        }>>;
        exclude: z.ZodOptional<z.ZodBoolean>;
        maxTokens: z.ZodOptional<z.ZodNumber>;
    }, z.core.$strip>>;
    responseFormat: z.ZodOptional<z.ZodPipe<z.ZodUnion<readonly [z.ZodEnum<{
        text: "text";
        json: "json";
        json_schema: "json_schema";
    }>]>, z.ZodTransform<string, "text" | "json" | "json_schema">>>;
    toolChoice: z.ZodOptional<z.ZodObject<{
        function: z.ZodOptional<z.ZodObject<{
            name: z.ZodString;
            type: z.ZodString;
        }, z.core.$strip>>;
        type: z.ZodString;
        value: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>>;
    tools: z.ZodOptional<z.ZodArray<z.ZodObject<{
        description: z.ZodString;
        name: z.ZodString;
        properties: z.ZodPipe<z.ZodUnion<readonly [z.ZodString, z.ZodRecord<z.ZodString, z.ZodAny>]>, z.ZodTransform<string, string | Record<string, any>>>;
    }, z.core.$strip>>>;
}, z.core.$strip>;
/**
 * Generate Content Chat Request
 *
 * GenerateContentChatRequest for LLMInterface.GenerateContentChat
 *
 * @property {TextGenerationConfig} [config] - Optional LLM configuration override
 * @property {Credentials} [credentials] - Optional credentials for authenticating with remote LLM providers.
 * @property {Message[]} messages - List of messages in the conversation
 * @property {ReasoningConfig} [reasoning] - Optional reasoning configuration for thinking models.
 * @property {'text' | 'json' | 'json_schema'} [responseFormat] - Response Format. Optional response format specification
 * @remarks responseFormat allowed values: "text", "json", "json_schema"
 * @property {ToolChoice} [toolChoice] - Optional tool choice configuration
 * @property {Tool[]} [tools] - Optional tools for the model to use
 */
export type GenerateContentChatRequest = z.infer<typeof GenerateContentChatRequestSchema>;
/**
 * Synthesize Speech Request
 *
 * TTS Interface Request Wrapper SynthesizeSpeechRequest for TTSInterface.SynthesizeSpeech
 */
export declare const SynthesizeSpeechRequestSchema: z.ZodObject<{
    config: z.ZodOptional<z.ZodObject<{
        elevenlabsConfig: z.ZodOptional<z.ZodObject<{
            queryParams: z.ZodObject<{
                enableLogging: z.ZodOptional<z.ZodBoolean>;
                outputFormat: z.ZodEnum<{
                    ELEVENLABS_OUTPUT_FORMAT_MP3_22050_32: "ELEVENLABS_OUTPUT_FORMAT_MP3_22050_32";
                    ELEVENLABS_OUTPUT_FORMAT_MP3_44100_128: "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_128";
                    ELEVENLABS_OUTPUT_FORMAT_MP3_44100_192: "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_192";
                    ELEVENLABS_OUTPUT_FORMAT_MP3_44100_32: "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_32";
                    ELEVENLABS_OUTPUT_FORMAT_MP3_44100_64: "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_64";
                    ELEVENLABS_OUTPUT_FORMAT_MP3_44100_96: "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_96";
                    ELEVENLABS_OUTPUT_FORMAT_UNSPECIFIED: "ELEVENLABS_OUTPUT_FORMAT_UNSPECIFIED";
                }>;
            }, z.core.$strip>;
            requestParams: z.ZodObject<{
                applyTextNormalization: z.ZodEnum<{
                    ELEVENLABS_TEXT_NORMALIZATION_AUTO: "ELEVENLABS_TEXT_NORMALIZATION_AUTO";
                    ELEVENLABS_TEXT_NORMALIZATION_OFF: "ELEVENLABS_TEXT_NORMALIZATION_OFF";
                    ELEVENLABS_TEXT_NORMALIZATION_ON: "ELEVENLABS_TEXT_NORMALIZATION_ON";
                    ELEVENLABS_TEXT_NORMALIZATION_UNSPECIFIED: "ELEVENLABS_TEXT_NORMALIZATION_UNSPECIFIED";
                }>;
                modelId: z.ZodString;
            }, z.core.$strip>;
        }, z.core.$strip>>;
        inworldConfig: z.ZodOptional<z.ZodObject<{
            inference: z.ZodObject<{
                speakingRate: z.ZodNumber;
                temperature: z.ZodNumber;
            }, z.core.$strip>;
            modelId: z.ZodOptional<z.ZodString>;
            postprocessing: z.ZodObject<{
                sampleRate: z.ZodNumber;
            }, z.core.$strip>;
            timestampType: z.ZodOptional<z.ZodEnum<{
                TIMESTAMP_TYPE_CHARACTER: "TIMESTAMP_TYPE_CHARACTER";
                TIMESTAMP_TYPE_UNSPECIFIED: "TIMESTAMP_TYPE_UNSPECIFIED";
                TIMESTAMP_TYPE_WORD: "TIMESTAMP_TYPE_WORD";
            }>>;
        }, z.core.$strip>>;
    }, z.core.$strip>>;
    credentials: z.ZodOptional<z.ZodObject<{
        inworldApiKey: z.ZodOptional<z.ZodString>;
        inworldJwt: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>>;
    text: z.ZodString;
    voice: z.ZodObject<{
        id: z.ZodString;
        language: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>;
}, z.core.$strip>;
/**
 * Synthesize Speech Request
 *
 * TTS Interface Request Wrapper SynthesizeSpeechRequest for TTSInterface.SynthesizeSpeech
 *
 * @property {SpeechSynthesisConfig} [config] - Optional TTS configuration override
 * @property {Credentials} [credentials] - Optional credentials for authenticating with TTS providers Only used by remote/cloud TTS clients. Local clients ignore this field.
 * @property {string} text - Text to synthesize into speech
 * @property {Voice} voice - Voice configuration for synthesis
 */
export type SynthesizeSpeechRequest = z.infer<typeof SynthesizeSpeechRequestSchema>;
/**
 * TTS Creation Config
 *
 * TTSCreationConfig encapsulates the configuration for creating a TTS model.
 */
export declare const TTSCreationConfigSchema: z.ZodObject<{
    remoteConfig: z.ZodOptional<z.ZodObject<{
        apiKey: z.ZodString;
        defaultTimeout: z.ZodOptional<z.ZodString>;
        endpointOverride: z.ZodOptional<z.ZodString>;
        synthesisConfig: z.ZodObject<{
            elevenlabsConfig: z.ZodOptional<z.ZodObject<{
                queryParams: z.ZodObject<{
                    enableLogging: z.ZodOptional<z.ZodBoolean>;
                    outputFormat: z.ZodEnum<{
                        ELEVENLABS_OUTPUT_FORMAT_MP3_22050_32: "ELEVENLABS_OUTPUT_FORMAT_MP3_22050_32";
                        ELEVENLABS_OUTPUT_FORMAT_MP3_44100_128: "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_128";
                        ELEVENLABS_OUTPUT_FORMAT_MP3_44100_192: "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_192";
                        ELEVENLABS_OUTPUT_FORMAT_MP3_44100_32: "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_32";
                        ELEVENLABS_OUTPUT_FORMAT_MP3_44100_64: "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_64";
                        ELEVENLABS_OUTPUT_FORMAT_MP3_44100_96: "ELEVENLABS_OUTPUT_FORMAT_MP3_44100_96";
                        ELEVENLABS_OUTPUT_FORMAT_UNSPECIFIED: "ELEVENLABS_OUTPUT_FORMAT_UNSPECIFIED";
                    }>;
                }, z.core.$strip>;
                requestParams: z.ZodObject<{
                    applyTextNormalization: z.ZodEnum<{
                        ELEVENLABS_TEXT_NORMALIZATION_AUTO: "ELEVENLABS_TEXT_NORMALIZATION_AUTO";
                        ELEVENLABS_TEXT_NORMALIZATION_OFF: "ELEVENLABS_TEXT_NORMALIZATION_OFF";
                        ELEVENLABS_TEXT_NORMALIZATION_ON: "ELEVENLABS_TEXT_NORMALIZATION_ON";
                        ELEVENLABS_TEXT_NORMALIZATION_UNSPECIFIED: "ELEVENLABS_TEXT_NORMALIZATION_UNSPECIFIED";
                    }>;
                    modelId: z.ZodString;
                }, z.core.$strip>;
            }, z.core.$strip>>;
            inworldConfig: z.ZodOptional<z.ZodObject<{
                inference: z.ZodObject<{
                    speakingRate: z.ZodNumber;
                    temperature: z.ZodNumber;
                }, z.core.$strip>;
                modelId: z.ZodOptional<z.ZodString>;
                postprocessing: z.ZodObject<{
                    sampleRate: z.ZodNumber;
                }, z.core.$strip>;
                timestampType: z.ZodOptional<z.ZodEnum<{
                    TIMESTAMP_TYPE_CHARACTER: "TIMESTAMP_TYPE_CHARACTER";
                    TIMESTAMP_TYPE_UNSPECIFIED: "TIMESTAMP_TYPE_UNSPECIFIED";
                    TIMESTAMP_TYPE_WORD: "TIMESTAMP_TYPE_WORD";
                }>>;
            }, z.core.$strip>>;
        }, z.core.$strip>;
    }, z.core.$strip>>;
}, z.core.$strip>;
/**
 * TTS Creation Config
 *
 * TTSCreationConfig encapsulates the configuration for creating a TTS model.
 *
 * @property {RemoteTTSConfig} [remoteConfig] - Remote TTS configuration.
 */
export type TTSCreationConfig = z.infer<typeof TTSCreationConfigSchema>;
/**
 * Configure Telemetry Request
 *
 * Telemetry Interface Request Wrapper ConfigureTelemetryRequest for telemetry.configureTelemetry
 */
export declare const ConfigureTelemetryRequestSchema: z.ZodObject<{
    config: z.ZodOptional<z.ZodObject<{
        apiKey: z.ZodOptional<z.ZodString>;
        endpoint: z.ZodOptional<z.ZodString>;
        exporterType: z.ZodOptional<z.ZodEnum<{
            EXPORTER_TYPE_LOCAL: "EXPORTER_TYPE_LOCAL";
            EXPORTER_TYPE_REMOTE: "EXPORTER_TYPE_REMOTE";
            EXPORTER_TYPE_UNSPECIFIED: "EXPORTER_TYPE_UNSPECIFIED";
        }>>;
        flushTimeoutMs: z.ZodOptional<z.ZodNumber>;
        logger: z.ZodOptional<z.ZodObject<{
            batchProcessingOpts: z.ZodOptional<z.ZodObject<{
                maxExportBatchSize: z.ZodOptional<z.ZodNumber>;
                maxQueueSize: z.ZodOptional<z.ZodNumber>;
                scheduleDelayMillis: z.ZodOptional<z.ZodNumber>;
            }, z.core.$strip>>;
            logLevel: z.ZodOptional<z.ZodEnum<{
                LOG_LEVEL_DEBUG: "LOG_LEVEL_DEBUG";
                LOG_LEVEL_ERROR: "LOG_LEVEL_ERROR";
                LOG_LEVEL_INFO: "LOG_LEVEL_INFO";
                LOG_LEVEL_TRACE: "LOG_LEVEL_TRACE";
                LOG_LEVEL_UNSPECIFIED: "LOG_LEVEL_UNSPECIFIED";
                LOG_LEVEL_WARN: "LOG_LEVEL_WARN";
            }>>;
            sinkAbslLogs: z.ZodOptional<z.ZodBoolean>;
        }, z.core.$strip>>;
        metrics: z.ZodOptional<z.ZodObject<{
            exportInterval: z.ZodOptional<z.ZodNumber>;
            exportTimeout: z.ZodOptional<z.ZodNumber>;
            metricCacheSize: z.ZodOptional<z.ZodNumber>;
            metrics: z.ZodOptional<z.ZodArray<z.ZodObject<{
                description: z.ZodOptional<z.ZodString>;
                metricKind: z.ZodOptional<z.ZodEnum<{
                    METRIC_KIND_COUNTER: "METRIC_KIND_COUNTER";
                    METRIC_KIND_GAUGE: "METRIC_KIND_GAUGE";
                    METRIC_KIND_HISTOGRAM: "METRIC_KIND_HISTOGRAM";
                    METRIC_KIND_UNSPECIFIED: "METRIC_KIND_UNSPECIFIED";
                }>>;
                name: z.ZodOptional<z.ZodString>;
                unit: z.ZodOptional<z.ZodString>;
                valueType: z.ZodOptional<z.ZodEnum<{
                    METRIC_VALUE_TYPE_DOUBLE: "METRIC_VALUE_TYPE_DOUBLE";
                    METRIC_VALUE_TYPE_INTEGER: "METRIC_VALUE_TYPE_INTEGER";
                    METRIC_VALUE_TYPE_UNSPECIFIED: "METRIC_VALUE_TYPE_UNSPECIFIED";
                }>>;
            }, z.core.$strip>>>;
        }, z.core.$strip>>;
        sdkName: z.ZodOptional<z.ZodString>;
        sdkVersion: z.ZodOptional<z.ZodString>;
        serviceName: z.ZodOptional<z.ZodString>;
        serviceVersion: z.ZodOptional<z.ZodString>;
        shutdownTimeoutMs: z.ZodOptional<z.ZodNumber>;
        tracer: z.ZodOptional<z.ZodObject<{
            batchProcessingOpts: z.ZodOptional<z.ZodObject<{
                maxExportBatchSize: z.ZodOptional<z.ZodNumber>;
                maxQueueSize: z.ZodOptional<z.ZodNumber>;
                scheduleDelayMillis: z.ZodOptional<z.ZodNumber>;
            }, z.core.$strip>>;
            enableSpanCapture: z.ZodOptional<z.ZodBoolean>;
            maxSpanCaptureQueueSize: z.ZodOptional<z.ZodNumber>;
            samplingRate: z.ZodOptional<z.ZodNumber>;
            spanDumpPath: z.ZodOptional<z.ZodString>;
        }, z.core.$strip>>;
    }, z.core.$strip>>;
    simpleConfig: z.ZodOptional<z.ZodObject<{
        serviceName: z.ZodOptional<z.ZodString>;
        serviceVersion: z.ZodOptional<z.ZodString>;
    }, z.core.$strip>>;
}, z.core.$strip>;
/**
 * Configure Telemetry Request
 *
 * Telemetry Interface Request Wrapper ConfigureTelemetryRequest for telemetry.configureTelemetry
 *
 * @property {TelemetryConfig} [config] - Full telemetry configuration.
 * @property {SimpleTelemetryConfig} [simpleConfig] - Simple telemetry configuration.
 */
export type ConfigureTelemetryRequest = z.infer<typeof ConfigureTelemetryRequestSchema>;
export declare function isDeviceType(obj: unknown): obj is DeviceType;
export declare function isFileType(obj: unknown): obj is FileType;
export declare function isImageDetail(obj: unknown): obj is ImageDetail;
export declare function isEffort(obj: unknown): obj is Effort;
export declare function isResponseFormat(obj: unknown): obj is ResponseFormat;
export declare function isElevenLabsOutputFormat(obj: unknown): obj is ElevenLabsOutputFormat;
export declare function isElevenLabsTextNormalization(obj: unknown): obj is ElevenLabsTextNormalization;
export declare function isTimestampType(obj: unknown): obj is TimestampType;
export declare function isTurnStatus(obj: unknown): obj is TurnStatus;
export declare function isExporterType(obj: unknown): obj is ExporterType;
export declare function isLogLevel(obj: unknown): obj is LogLevel;
export declare function isMetricKind(obj: unknown): obj is MetricKind;
export declare function isMetricValueType(obj: unknown): obj is MetricValueType;
export declare function isSpanKind(obj: unknown): obj is SpanKind;
export declare function isSpanStatus(obj: unknown): obj is SpanStatus;
export declare function isCredentials(obj: unknown): obj is Credentials;
export declare function isEmbedResponse(obj: unknown): obj is EmbedResponse;
export declare function isEmbedRequest(obj: unknown): obj is EmbedRequest;
export declare function isDeviceSelection(obj: unknown): obj is DeviceSelection;
export declare function isRemoteTextEmbedderConfig(obj: unknown): obj is RemoteTextEmbedderConfig;
export declare function isFile(obj: unknown): obj is File;
export declare function isKnowledgeRecords(obj: unknown): obj is KnowledgeRecords;
export declare function isCompileKnowledgeResponse(obj: unknown): obj is CompileKnowledgeResponse;
export declare function isRetrievalConfig(obj: unknown): obj is RetrievalConfig;
export declare function isGetKnowledgeResponse(obj: unknown): obj is GetKnowledgeResponse;
export declare function isParsingConfig(obj: unknown): obj is ParsingConfig;
export declare function isLanguage(obj: unknown): obj is Language;
export declare function isRemoveKnowledgeRequest(obj: unknown): obj is RemoveKnowledgeRequest;
export declare function isLogitBias(obj: unknown): obj is LogitBias;
export declare function isImageUrl(obj: unknown): obj is ImageUrl;
export declare function isToolCall(obj: unknown): obj is ToolCall;
export declare function isReasoningConfig(obj: unknown): obj is ReasoningConfig;
export declare function isFunctionChoice(obj: unknown): obj is FunctionChoice;
export declare function isTool(obj: unknown): obj is Tool;
export declare function isGetModelsRequest(obj: unknown): obj is GetModelsRequest;
export declare function isLLMBenchmarks(obj: unknown): obj is LLMBenchmarks;
export declare function isModelId(obj: unknown): obj is ModelId;
export declare function isLLMPerformance(obj: unknown): obj is LLMPerformance;
export declare function isLLMPricing(obj: unknown): obj is LLMPricing;
export declare function isLLMSpec(obj: unknown): obj is LLMSpec;
export declare function isToolCallResult(obj: unknown): obj is ToolCallResult;
export declare function isToolList(obj: unknown): obj is ToolList;
export declare function isMCPHttpConfig(obj: unknown): obj is MCPHttpConfig;
export declare function isParagonApiConfig(obj: unknown): obj is ParagonApiConfig;
export declare function isMCPStdioConfig(obj: unknown): obj is MCPStdioConfig;
export declare function isClassThreshold(obj: unknown): obj is ClassThreshold;
export declare function isClassifyTextResponse(obj: unknown): obj is ClassifyTextResponse;
export declare function isEntityMatch(obj: unknown): obj is EntityMatch;
export declare function isIntent(obj: unknown): obj is Intent;
export declare function isEmbeddingMatcherConfig(obj: unknown): obj is EmbeddingMatcherConfig;
export declare function isKeywordGroup(obj: unknown): obj is KeywordGroup;
export declare function isKeywordMatch(obj: unknown): obj is KeywordMatch;
export declare function isDictionaryRule(obj: unknown): obj is DictionaryRule;
export declare function isTextClassifierCreationConfig(obj: unknown): obj is TextClassifierCreationConfig;
export declare function isDeviceInfo(obj: unknown): obj is DeviceInfo;
export declare function isGoogleSerperApiClientCreationConfig(obj: unknown): obj is GoogleSerperApiClientCreationConfig;
export declare function isGoogleSerperApiSearchRequest(obj: unknown): obj is GoogleSerperApiSearchRequest;
export declare function isKnowledgeGraph(obj: unknown): obj is KnowledgeGraph;
export declare function isSitelink(obj: unknown): obj is Sitelink;
export declare function isPeopleAlsoAsk(obj: unknown): obj is PeopleAlsoAsk;
export declare function isTopStory(obj: unknown): obj is TopStory;
export declare function isAcousticEchoCancellationConfig(obj: unknown): obj is AcousticEchoCancellationConfig;
export declare function isVoiceActivityDetectionConfig(obj: unknown): obj is VoiceActivityDetectionConfig;
export declare function isAudioChunkTimestamp(obj: unknown): obj is AudioChunkTimestamp;
export declare function isTurnDetectionConfig(obj: unknown): obj is TurnDetectionConfig;
export declare function isSpeechRecognitionConfig(obj: unknown): obj is SpeechRecognitionConfig;
export declare function isLocalSttConfig(obj: unknown): obj is LocalSttConfig;
export declare function isRemoteSttConfig(obj: unknown): obj is RemoteSttConfig;
export declare function isStreamSpeechRecognitionConfig(obj: unknown): obj is StreamSpeechRecognitionConfig;
export declare function isStreamSpeechRecognitionResponse(obj: unknown): obj is StreamSpeechRecognitionResponse;
export declare function isLocalStreamingSttConfig(obj: unknown): obj is LocalStreamingSttConfig;
export declare function isRemoteStreamingSttConfig(obj: unknown): obj is RemoteStreamingSttConfig;
export declare function isElevenLabsQueryParams(obj: unknown): obj is ElevenLabsQueryParams;
export declare function isElevenLabsRequestParams(obj: unknown): obj is ElevenLabsRequestParams;
export declare function isSpeechSynthesisInferenceConfig(obj: unknown): obj is SpeechSynthesisInferenceConfig;
export declare function isSpeechSynthesisPostprocessingConfig(obj: unknown): obj is SpeechSynthesisPostprocessingConfig;
export declare function isVoice(obj: unknown): obj is Voice;
export declare function isLocalTurnDetectorConfig(obj: unknown): obj is LocalTurnDetectorConfig;
export declare function isTurnPrediction(obj: unknown): obj is TurnPrediction;
export declare function isLocalVadConfig(obj: unknown): obj is LocalVadConfig;
export declare function isBatchProcessingOptions(obj: unknown): obj is BatchProcessingOptions;
export declare function isMetricConfig(obj: unknown): obj is MetricConfig;
export declare function isTracerConfig(obj: unknown): obj is TracerConfig;
export declare function isSimpleTelemetryConfig(obj: unknown): obj is SimpleTelemetryConfig;
export declare function isSpanEvent(obj: unknown): obj is SpanEvent;
export declare function isLogMessageRequest(obj: unknown): obj is LogMessageRequest;
export declare function isCounterMetric(obj: unknown): obj is CounterMetric;
export declare function isGaugeMetric(obj: unknown): obj is GaugeMetric;
export declare function isHistogramMetric(obj: unknown): obj is HistogramMetric;
export declare function isEmbedBatchRequest(obj: unknown): obj is EmbedBatchRequest;
export declare function isEmbedBatchResponse(obj: unknown): obj is EmbedBatchResponse;
export declare function isLocalTextEmbedderConfig(obj: unknown): obj is LocalTextEmbedderConfig;
export declare function isCompileKnowledgeRequest(obj: unknown): obj is CompileKnowledgeRequest;
export declare function isGetKnowledgeRequest(obj: unknown): obj is GetKnowledgeRequest;
export declare function isKnowledgeCompileConfig(obj: unknown): obj is KnowledgeCompileConfig;
export declare function isRemoteKnowledgeConfig(obj: unknown): obj is RemoteKnowledgeConfig;
export declare function isTextGenerationConfig(obj: unknown): obj is TextGenerationConfig;
export declare function isContentItem(obj: unknown): obj is ContentItem;
export declare function isToolChoice(obj: unknown): obj is ToolChoice;
export declare function isGenerateContentRequest(obj: unknown): obj is GenerateContentRequest;
export declare function isModelInfo(obj: unknown): obj is ModelInfo;
export declare function isLocalLlmConfig(obj: unknown): obj is LocalLlmConfig;
export declare function isRemoteLlmConfig(obj: unknown): obj is RemoteLlmConfig;
export declare function isMCPSessionCreationConfig(obj: unknown): obj is MCPSessionCreationConfig;
export declare function isTextClassifierConfig(obj: unknown): obj is TextClassifierConfig;
export declare function isExtractEntitiesResponse(obj: unknown): obj is ExtractEntitiesResponse;
export declare function isLLMMatcherConfig(obj: unknown): obj is LLMMatcherConfig;
export declare function isKeywordMatcherResponse(obj: unknown): obj is KeywordMatcherResponse;
export declare function isEntity(obj: unknown): obj is Entity;
export declare function isDevice(obj: unknown): obj is Device;
export declare function isOrganicResult(obj: unknown): obj is OrganicResult;
export declare function isLocalAecFilterConfig(obj: unknown): obj is LocalAecFilterConfig;
export declare function isDetectSilenceRequest(obj: unknown): obj is DetectSilenceRequest;
export declare function isAudioChunk(obj: unknown): obj is AudioChunk;
export declare function isDetectVoiceActivityRequest(obj: unknown): obj is DetectVoiceActivityRequest;
export declare function isFilterAudioRequest(obj: unknown): obj is FilterAudioRequest;
export declare function isRecognizeSpeechRequest(obj: unknown): obj is RecognizeSpeechRequest;
export declare function isSTTCreationConfig(obj: unknown): obj is STTCreationConfig;
export declare function isStreamRecognizeSpeechRequest(obj: unknown): obj is StreamRecognizeSpeechRequest;
export declare function isStreamingSTTCreationConfig(obj: unknown): obj is StreamingSTTCreationConfig;
export declare function isElevenLabsSpeechSynthesisConfig(obj: unknown): obj is ElevenLabsSpeechSynthesisConfig;
export declare function isInworldSpeechSynthesisConfig(obj: unknown): obj is InworldSpeechSynthesisConfig;
export declare function isTurnDetectorCreationConfig(obj: unknown): obj is TurnDetectorCreationConfig;
export declare function isVADCreationConfig(obj: unknown): obj is VADCreationConfig;
export declare function isLoggerConfig(obj: unknown): obj is LoggerConfig;
export declare function isMetricsConfig(obj: unknown): obj is MetricsConfig;
export declare function isSpanData(obj: unknown): obj is SpanData;
export declare function isRecordMetricRequest(obj: unknown): obj is RecordMetricRequest;
export declare function isTextEmbedderCreationConfig(obj: unknown): obj is TextEmbedderCreationConfig;
export declare function isLocalKnowledgeConfig(obj: unknown): obj is LocalKnowledgeConfig;
export declare function isMessage(obj: unknown): obj is Message;
export declare function isGetModelsResponse(obj: unknown): obj is GetModelsResponse;
export declare function isLLMCreationConfig(obj: unknown): obj is LLMCreationConfig;
export declare function isMCPClientCreationConfig(obj: unknown): obj is MCPClientCreationConfig;
export declare function isClassifyTextRequest(obj: unknown): obj is ClassifyTextRequest;
export declare function isIntentMatcherConfig(obj: unknown): obj is IntentMatcherConfig;
export declare function isNerCreationConfig(obj: unknown): obj is NerCreationConfig;
export declare function isGoogleSerperApiSearchResponse(obj: unknown): obj is GoogleSerperApiSearchResponse;
export declare function isAECFilterCreationConfig(obj: unknown): obj is AECFilterCreationConfig;
export declare function isDetectTurnCompletionRequest(obj: unknown): obj is DetectTurnCompletionRequest;
export declare function isSpeechSynthesisConfig(obj: unknown): obj is SpeechSynthesisConfig;
export declare function isRemoteTtsConfig(obj: unknown): obj is RemoteTtsConfig;
export declare function isTelemetryConfig(obj: unknown): obj is TelemetryConfig;
export declare function isDequeueSpanTracesResponse(obj: unknown): obj is DequeueSpanTracesResponse;
export declare function isKnowledgeCreationConfig(obj: unknown): obj is KnowledgeCreationConfig;
export declare function isGenerateContentChatRequest(obj: unknown): obj is GenerateContentChatRequest;
export declare function isSynthesizeSpeechRequest(obj: unknown): obj is SynthesizeSpeechRequest;
export declare function isTTSCreationConfig(obj: unknown): obj is TTSCreationConfig;
export declare function isConfigureTelemetryRequest(obj: unknown): obj is ConfigureTelemetryRequest;
