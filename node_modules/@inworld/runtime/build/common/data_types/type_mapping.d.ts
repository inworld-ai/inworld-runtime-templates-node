import { AudioChunkStream, ContentStream, SpeechChunkStream, TextStream, TTSOutputStream } from '../stream';
import { Audio } from './api/audio';
import { ClassificationResult } from './api/classification_result';
import { Custom } from './api/custom';
import { GoalAdvancementRequest } from './api/goal_advancement_request';
import { GoalAdvancementResponse } from './api/goal_advancement_response';
import { KnowledgeRecords } from './api/knowledge_records';
import { ListToolsResponse } from './api/list_tools_response';
import { LLMChatRequest } from './api/llm_chat_request';
import { LLMChatResponse } from './api/llm_chat_response';
import { MatchedIntents } from './api/matched_intents';
import { MatchedKeywords } from './api/matched_keywords';
import { MultimodalContent } from './api/multimodal_content';
import { SafetyResult } from './api/safety_result';
import { ToolCallResponse } from './api/tool_call_response';
import { TTSRequest } from './api/tts_request';
import { Content } from './graph_types';
import * as GraphTypes from './graph_types';
import { GraphError } from './graph_types';
export { GraphTypes };
/**
 * Represents a custom-typed pointer to any structure.
 * This is a virtual TypeScript type that provides type safety without runtime
 * overhead. At runtime, this will just be the raw object, but TypeScript will
 * understand the structure.
 *
 * @template T - The TypeScript type of the data structure
 *
 * @example
 * ```typescript
 * function process(input: Custom<{internalFields: string}>) {
 *   // TypeScript understands the structure
 *   console.log(input.internalFields);
 * }
 * ```
 */
/**
 * Type guards for CustomNodeInputTypes to enable easy type checking and
 * switch-case patterns. These functions help distinguish between different
 * types in graph output streams.
 */
export declare namespace GraphTypesTypeGuards {
    function isString(value: CustomNodeInputTypes): value is string;
    function isCustom<T extends Object = any>(value: CustomNodeInputTypes): value is Custom<T>;
    function isClassificationResult(value: CustomNodeInputTypes): value is ClassificationResult;
    function isContent(value: CustomNodeInputTypes): value is Content;
    function isGoalAdvancement(value: CustomNodeInputTypes): value is GoalAdvancementResponse;
    function isGoalAdvancementResponse(value: CustomNodeInputTypes): value is GoalAdvancementResponse;
    function isGoalAdvancementRequest(value: CustomNodeInputTypes): value is GoalAdvancementRequest;
    function isKnowledgeRecords(value: CustomNodeInputTypes): value is KnowledgeRecords;
    function isListToolsResponse(value: CustomNodeInputTypes): value is ListToolsResponse;
    function isLLMChatRequest(value: CustomNodeInputTypes): value is LLMChatRequest;
    function isLLMChatResponse(value: CustomNodeInputTypes): value is LLMChatResponse;
    function isTTSRequest(value: CustomNodeInputTypes): value is TTSRequest;
    function isMatchedIntents(value: CustomNodeInputTypes): value is MatchedIntents;
    function isMatchedKeywords(value: CustomNodeInputTypes): value is MatchedKeywords;
    function isSafetyResult(value: CustomNodeInputTypes): value is SafetyResult;
    function isToolCallResponse(value: CustomNodeInputTypes): value is ToolCallResponse;
    function isTextStream(value: CustomNodeInputTypes): value is TextStream;
    function isContentStream(value: CustomNodeInputTypes): value is ContentStream;
    function isTTSOutputStream(value: CustomNodeInputTypes): value is TTSOutputStream;
    function isSpeechChunkStream(value: CustomNodeInputTypes): value is SpeechChunkStream;
    function isAudioChunkStream(value: CustomNodeInputTypes): value is AudioChunkStream;
    function isAudio(value: CustomNodeInputTypes): value is Audio;
    function isMultimodalContent(value: CustomNodeInputTypes): value is MultimodalContent;
    function isGraphError(value: CustomNodeInputTypes): value is GraphError;
}
/**
 * Helper function to get a human-readable type name for CustomNodeInputTypes
 */
export declare function getTypeName(value: CustomNodeInputTypes): CustomNodeInputTypeName;
/**
 * Collection of potential input types for a custom node.
 */
export type CustomNodeInputTypes = GraphTypes.ClassificationResult | GraphTypes.Content | GraphTypes.GoalAdvancementResponse | GraphTypes.KnowledgeRecords | GraphTypes.ListToolsResponse | GraphTypes.LLMChatRequest | GraphTypes.LLMChatResponse | GraphTypes.TTSRequest | GraphTypes.MatchedIntents | GraphTypes.MatchedKeywords | GraphTypes.SafetyResult | GraphTypes.ToolCallResponse | GraphTypes.TextStream | GraphTypes.ContentStream | GraphTypes.TTSOutputStream | GraphTypes.SpeechChunkStream | GraphTypes.AudioChunkStream | GraphTypes.Audio | GraphTypes.Custom<any> | string;
/**
 * Collection of potential output types for a custom node.
 */
export type CustomNodeOutputTypes = string | GraphTypes.LLMChatRequest | GraphTypes.LLMChatResponse | GraphTypes.TTSRequest | GraphTypes.TextStream | GraphTypes.SpeechChunkStream | GraphTypes.AudioChunkStream | GraphTypes.TTSOutputStream | GraphTypes.ListToolsResponse | GraphTypes.ToolCallResponse | GraphTypes.MultimodalContent | GraphTypes.Custom<any>;
export type JsNonNullishSerializableTypes = string | number | boolean | BigInt | Array<any> | Record<string, any>;
export type RuntimeAllowedType = CustomNodeOutputTypes | CustomNodeInputTypes | JsNonNullishSerializableTypes;
export type CustomNodeInputTypeName = 'string' | 'ClassificationResult' | 'Content' | 'GoalAdvancement' | 'KnowledgeRecords' | 'ListToolsResponse' | 'LLMChatRequest' | 'LLMChatResponse' | 'TTSRequest' | 'MatchedIntents' | 'MatchedKeywords' | 'SafetyResult' | 'MemoryState' | 'ToolCallResponse' | 'TextStream' | 'ContentStream' | 'TTSOutputStream' | 'SpeechChunkStream' | 'AudioChunkStream' | 'Custom' | 'Error';
/**
 * Type guard to check if a value is a non-nullish serializable JS type
 */
export declare function isJsNonNullishSerializable(value: any): value is JsNonNullishSerializableTypes;
