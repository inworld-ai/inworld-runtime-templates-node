"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CallbackRegistry = void 0;
exports.registerCustomNodeType = registerCustomNodeType;
exports.registerCustomEdgeCondition = registerCustomEdgeCondition;
const zod_to_json_schema_1 = require("zod-to-json-schema");
const custom_1 = require("../../../common/data_types/api/custom");
const inworld_1 = require("../../../internal/error/inworld");
const node_api_1 = require("../../../internal/node_api");
const from_external_1 = require("../../utils/from_external");
const to_external_1 = require("../../utils/to_external");
const process_context_Impl_1 = require("./process_context_Impl");
/**
 * Registry for custom node types and edge conditions.
 * Uses the new registerCallbacks API internally while maintaining backward compatibility.
 */
class CallbackRegistry {
    constructor() {
        this.nodeCallbacks = new Map();
        this.nodeExecutionConfigs = new Map();
        this.nodeSchemas = new Map();
        this.conditionCallbacks = new Map();
        this.registeredNodes = new Set();
        this.registeredConditions = new Set();
    }
    static getInstance() {
        if (!CallbackRegistry.instance) {
            CallbackRegistry.instance = new CallbackRegistry();
        }
        return CallbackRegistry.instance;
    }
    /**
     * Registers a custom node type with the new API.
     */
    registerNode({ type, id, processFunction, streamType = 'BaseData', executionConfig, }) {
        if (this.registeredNodes.has(type)) {
            throw new inworld_1.InworldError(`Custom node type '${type}' is already registered`);
        }
        this.nodeExecutionConfigs.set(id, executionConfig);
        const registryInstance = this;
        const nodeCallback = async function (context, ...argsInputs) {
            try {
                const executionConfig = registryInstance.nodeExecutionConfigs.get(context.nodeId);
                const schemaDefinition = registryInstance.nodeSchemas.get(context.nodeId);
                const processContext = new process_context_Impl_1.ProcessContextImpl(context, executionConfig);
                const inputs = Array.isArray(argsInputs)
                    ? argsInputs.length > 1
                        ? argsInputs.map(from_external_1.fromExternal)
                        : [(0, from_external_1.fromExternal)(argsInputs[0])]
                    : [(0, from_external_1.fromExternal)(argsInputs)];
                const normalizedInputs = applyInputSchema(schemaDefinition, inputs);
                const result = await processFunction(processContext, ...normalizedInputs);
                const validatedResult = applyOutputSchema(schemaDefinition, result, type);
                // If result is a generator, attach the streamType metadata before conversion
                // toExternal will automatically wrap the generator and convert yielded values
                if (isAsyncGenerator(validatedResult)) {
                    Object.assign(validatedResult, { type: streamType });
                }
                return (0, to_external_1.toExternal)(validatedResult);
            }
            catch (error) {
                throw new inworld_1.InworldError(`Custom node '${type}' failed: ${error.message}`, error.stack);
            }
        };
        this.nodeCallbacks.set(type, Object.assign(nodeCallback, { type: streamType }));
        this.registeredNodes.add(type);
        this.flushRegistrations();
    }
    /**
     * Registers a custom edge condition
     */
    registerCondition(id, condition) {
        if (this.registeredConditions.has(id)) {
            throw new inworld_1.InworldError(`Edge condition '${id}' is already registered`);
        }
        const conditionCallback = async (_context, // EdgeConditionCallback doesn't use context,
        input) => {
            try {
                const result = await condition((0, from_external_1.fromExternal)(input));
                return Boolean(result);
            }
            catch (error) {
                // eslint-disable-next-line no-console
                console.warn(`Edge condition '${id}' error:`, error);
                return false;
            }
        };
        this.conditionCallbacks.set(id, conditionCallback);
        this.registeredConditions.add(id);
        this.flushRegistrations();
    }
    registerNodeExecutionConfig(id, executionConfig) {
        return this.nodeExecutionConfigs.set(id, executionConfig);
    }
    hasRegisteredNode(type) {
        return this.registeredNodes.has(type);
    }
    registerNodeSchema(id, schemaDefinition) {
        if (schemaDefinition) {
            this.nodeSchemas.set(id, schemaDefinition);
            return;
        }
        this.nodeSchemas.delete(id);
    }
    /**
     * Registers all callbacks with the C++ API using the new registerCallbacks function.
     */
    flushRegistrations() {
        const callbacks = {};
        // Convert Maps to Records for the API
        if (this.nodeCallbacks.size > 0) {
            callbacks.nodes = Object.fromEntries(this.nodeCallbacks);
        }
        if (this.conditionCallbacks.size > 0) {
            callbacks.conditions = Object.fromEntries(this.conditionCallbacks);
        }
        // Only register if we have callbacks
        if (callbacks.nodes || callbacks.conditions) {
            try {
                (0, node_api_1.registerCallbacks)(callbacks);
            }
            catch (error) {
                throw new inworld_1.InworldError(`Failed to register callbacks: ${error.message}`);
            }
        }
    }
    /**
     * Unregisters a node type.
     */
    unregisterNode(type) {
        this.nodeCallbacks.delete(type);
        this.registeredNodes.delete(type);
    }
    /**
     * Unregisters an edge condition.
     */
    unregisterCondition(id) {
        this.conditionCallbacks.delete(id);
        this.registeredConditions.delete(id);
    }
    /**
     * Clears all registered callbacks.
     */
    clear() {
        this.nodeCallbacks.clear();
        this.conditionCallbacks.clear();
        this.registeredNodes.clear();
        this.registeredConditions.clear();
        this.nodeSchemas.clear();
    }
    /**
     * Destroys the singleton instance.
     */
    static destroy() {
        if (CallbackRegistry.instance) {
            CallbackRegistry.instance.clear();
            CallbackRegistry.instance = null;
        }
    }
}
exports.CallbackRegistry = CallbackRegistry;
function applyInputSchema(schemaDefinition, inputs) {
    if (!(schemaDefinition === null || schemaDefinition === void 0 ? void 0 : schemaDefinition.input)) {
        return inputs;
    }
    const schema = schemaDefinition.input;
    if (Array.isArray(schema)) {
        return inputs.map((input, index) => {
            const inputSchema = schema[index];
            if (!inputSchema) {
                return input;
            }
            return inputSchema.parse(unwrapCustomValue(input));
        });
    }
    if (!inputs.length) {
        return inputs;
    }
    const [firstInput, ...rest] = inputs;
    const parsed = schema.parse(unwrapCustomValue(firstInput));
    return [parsed, ...rest];
}
function applyOutputSchema(schemaDefinition, result, nodeType) {
    if (!(schemaDefinition === null || schemaDefinition === void 0 ? void 0 : schemaDefinition.output)) {
        return result;
    }
    if (isAsyncGenerator(result)) {
        return result;
    }
    const outputSchema = schemaDefinition.output;
    const valueToValidate = unwrapCustomValue(result);
    const parsed = outputSchema.parse(valueToValidate !== null && valueToValidate !== void 0 ? valueToValidate : {});
    const schemaJson = safeConvertSchemaToJson(outputSchema, `${nodeType}Output`);
    if (result instanceof custom_1.CustomData) {
        return new custom_1.CustomData({
            value: parsed,
            schema: schemaJson !== null && schemaJson !== void 0 ? schemaJson : result.getSchema(),
        });
    }
    return new custom_1.CustomData({
        value: parsed,
        schema: schemaJson !== null && schemaJson !== void 0 ? schemaJson : undefined,
    });
}
function unwrapCustomValue(value) {
    if (value instanceof custom_1.CustomData) {
        return value.getValue();
    }
    return value;
}
function safeConvertSchemaToJson(schema, name) {
    try {
        const jsonSchema = (0, zod_to_json_schema_1.zodToJsonSchema)(schema, name);
        return jsonSchema;
    }
    catch (error) {
        // eslint-disable-next-line no-console
        console.warn(`Failed to convert Zod schema to JSON schema for ${name}:`, error);
        return undefined;
    }
}
function isAsyncGenerator(value) {
    return (value !== null &&
        typeof value === 'object' &&
        typeof value[Symbol.asyncIterator] ===
            'function');
}
/**
 * Registers a custom node type for use in graph configurations.
 *
 * @param type - The type name to register (e.g., 'CustomTextProcessor')
 * @param id
 * @param processFunction - Function that processes node inputs
 * @param streamType - Optional stream type for generator outputs (e.g., 'Audio', 'Text', 'BaseData')
 * @param executionConfig
 * @returns Reference to the registered node type
 * @throws InworldError if registration fails
 *
 * @example
 * ```typescript
 * import { registerCustomNodeType, ProcessContext } from '@inworld/runtime/graph';
 *
 * const nodeRef = registerCustomNodeType(
 *   'MyCustomNode',
 *   (context: ProcessContext, input: string): string => {
 *     return input.toUpperCase();
 *   },
 *   'Text' // Optional: specify stream type for generators
 * );
 * ```
 */
function registerCustomNodeType(type, id, processFunction, streamType = 'BaseData', executionConfig) {
    const registry = CallbackRegistry.getInstance();
    registry.registerNode({
        type,
        id,
        processFunction,
        streamType,
        executionConfig,
    });
    return {
        typeName: type,
    };
}
/**
 * Registers a custom edge condition for conditional graph execution.
 *
 * @param id - Unique identifier for the edge condition
 * @param condition - Function that determines if edge should be traversed
 * @returns Reference to the registered edge condition
 * @throws InworldError if registration fails
 *
 * @example
 * ```typescript
 * import { registerCustomEdgeCondition } from '@inworld/runtime/graph';
 *
 * const conditionRef = registerCustomEdgeCondition(
 *   'isPositiveNumber',
 *   (input: any): boolean => {
 *     return typeof input === 'number' && input > 0;
 *   }
 * );
 * ```
 */
function registerCustomEdgeCondition(id, condition) {
    const registry = CallbackRegistry.getInstance();
    registry.registerCondition(id, condition);
    return {
        id,
    };
}
