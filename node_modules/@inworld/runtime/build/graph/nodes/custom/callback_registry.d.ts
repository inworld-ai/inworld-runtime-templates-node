import { CustomNodeInputTypes, CustomNodeOutputTypes } from '../../../common/data_types/type_mapping';
import type { CustomNodeSchemaDefinition } from '../../dsl/types/custom_node_schema';
import { ExecutionConfig } from '../NodeExecutionConfig';
import { CustomEdgeConditionReference, CustomNodeTypeReference } from '../types';
import { ProcessContext } from './process_context_Impl';
import { EdgeConditionCallback } from './types';
/**
 * Type for custom node process function.
 * Receives ProcessContext and variable number of inputs, returns output or Promise<output>.
 */
type ProcessFunction = (context: ProcessContext, ...inputs: any[]) => any | Promise<any>;
/**
 * Registry for custom node types and edge conditions.
 * Uses the new registerCallbacks API internally while maintaining backward compatibility.
 */
export declare class CallbackRegistry {
    private static instance;
    private nodeCallbacks;
    private nodeExecutionConfigs;
    private nodeSchemas;
    private conditionCallbacks;
    private registeredNodes;
    private registeredConditions;
    private constructor();
    static getInstance(): CallbackRegistry;
    /**
     * Registers a custom node type with the new API.
     */
    registerNode({ type, id, processFunction, streamType, executionConfig, }: {
        type: string;
        id: string;
        processFunction: ProcessFunction;
        streamType: string;
        executionConfig?: ExecutionConfig;
    }): void;
    /**
     * Registers a custom edge condition
     */
    registerCondition(id: string, condition: EdgeConditionCallback): void;
    registerNodeExecutionConfig(id: string, executionConfig: ExecutionConfig): Map<string, ExecutionConfig<Record<string, any>>>;
    hasRegisteredNode(type: string): boolean;
    registerNodeSchema(id: string, schemaDefinition?: CustomNodeSchemaDefinition): void;
    /**
     * Registers all callbacks with the C++ API using the new registerCallbacks function.
     */
    private flushRegistrations;
    /**
     * Unregisters a node type.
     */
    unregisterNode(type: string): void;
    /**
     * Unregisters an edge condition.
     */
    unregisterCondition(id: string): void;
    /**
     * Clears all registered callbacks.
     */
    clear(): void;
    /**
     * Destroys the singleton instance.
     */
    static destroy(): void;
}
/**
 * Registers a custom node type for use in graph configurations.
 *
 * @param type - The type name to register (e.g., 'CustomTextProcessor')
 * @param id
 * @param processFunction - Function that processes node inputs
 * @param streamType - Optional stream type for generator outputs (e.g., 'Audio', 'Text', 'BaseData')
 * @param executionConfig
 * @returns Reference to the registered node type
 * @throws InworldError if registration fails
 *
 * @example
 * ```typescript
 * import { registerCustomNodeType, ProcessContext } from '@inworld/runtime/graph';
 *
 * const nodeRef = registerCustomNodeType(
 *   'MyCustomNode',
 *   (context: ProcessContext, input: string): string => {
 *     return input.toUpperCase();
 *   },
 *   'Text' // Optional: specify stream type for generators
 * );
 * ```
 */
export declare function registerCustomNodeType(type: string, id: string, processFunction: (context: ProcessContext, ...inputs: CustomNodeInputTypes[]) => CustomNodeOutputTypes | Promise<CustomNodeOutputTypes>, streamType?: string, executionConfig?: ExecutionConfig): CustomNodeTypeReference;
/**
 * Registers a custom edge condition for conditional graph execution.
 *
 * @param id - Unique identifier for the edge condition
 * @param condition - Function that determines if edge should be traversed
 * @returns Reference to the registered edge condition
 * @throws InworldError if registration fails
 *
 * @example
 * ```typescript
 * import { registerCustomEdgeCondition } from '@inworld/runtime/graph';
 *
 * const conditionRef = registerCustomEdgeCondition(
 *   'isPositiveNumber',
 *   (input: any): boolean => {
 *     return typeof input === 'number' && input > 0;
 *   }
 * );
 * ```
 */
export declare function registerCustomEdgeCondition(id: string, condition: EdgeConditionCallback): CustomEdgeConditionReference;
export {};
