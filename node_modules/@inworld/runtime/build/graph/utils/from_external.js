"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fromExternal = fromExternal;
const audio_1 = require("../../common/data_types/api/audio");
const classification_result_1 = require("../../common/data_types/api/classification_result");
const custom_1 = require("../../common/data_types/api/custom");
const data_stream_with_metadata_1 = require("../../common/data_types/api/data_stream_with_metadata");
const goal_advancement_response_1 = require("../../common/data_types/api/goal_advancement_response");
const graph_error_1 = require("../../common/data_types/api/graph_error");
const knowledge_records_1 = require("../../common/data_types/api/knowledge_records");
const list_tools_response_1 = require("../../common/data_types/api/list_tools_response");
const llm_chat_request_1 = require("../../common/data_types/api/llm_chat_request");
const llm_chat_response_1 = require("../../common/data_types/api/llm_chat_response");
const llm_chat_routing_request_1 = require("../../common/data_types/api/llm_chat_routing_request");
const matched_intents_1 = require("../../common/data_types/api/matched_intents");
const matched_keywords_1 = require("../../common/data_types/api/matched_keywords");
const safety_result_1 = require("../../common/data_types/api/safety_result");
const tool_call_request_1 = require("../../common/data_types/api/tool_call_request");
const tool_call_response_1 = require("../../common/data_types/api/tool_call_response");
const tts_request_1 = require("../../common/data_types/api/tts_request");
const graph_types_1 = require("../../common/data_types/graph_types");
const stream_1 = require("../../common/stream");
const inworld_1 = require("../../internal/error/inworld");
const pb_1 = require("../../internal/pb");
const types_1 = require("../../internal/types");
/**
 * @internal
 * Converts WrappedType (PbBaseType) to RuntimeAllowedType.
 * Handles protobuf-based data types with proper type conversion.
 *
 * @param value - The wrapped protobuf value to convert
 * @returns Appropriate wrapper instance or null if conversion fails
 */
function convertPbToCustomType(value) {
    var _a, _b;
    if (!(0, pb_1.isPbBaseType)(value)) {
        return null;
    }
    const determinedType = pb_1.PbType.of(value);
    if ((0, pb_1.isPbStreamBaseType)(value)) {
        switch (determinedType) {
            case 'llmChatResponse': {
                return stream_1.ContentStream.fromExternal(value._stream);
            }
            case 'llmCompletionResponse': {
                return stream_1.TextStream.fromExternal(value._stream);
            }
            case 'dataStreamWithMetadata': {
                // Unpack metadata from protobuf and create DataStreamWithMetadata
                const metadata = pb_1.PbType.unpackDataStreamWithMetadata(value);
                // Add elementType from stream if available
                const streamType = (_a = value._stream) === null || _a === void 0 ? void 0 : _a.type;
                if (!metadata.elementType && streamType) {
                    metadata.elementType = streamType;
                }
                return new data_stream_with_metadata_1.DataStreamWithMetadata(value._stream, metadata);
            }
            default:
                break;
        }
    }
    switch (determinedType) {
        case 'audio': {
            const result = pb_1.PbType.unpackAudio(value);
            return new audio_1.Audio({
                data: Array.from(result.data),
                sampleRate: result.sampleRate,
            });
        }
        case 'llmChatResponse': {
            const response = pb_1.PbType.unpackLLMChatResponse(value);
            return new llm_chat_response_1.LLMChatResponse({
                content: response.content,
                finishReason: response.finishReason,
                metadata: response.metadata,
                modelName: response.modelName,
                stream: response.stream,
                toolCalls: response.toolCalls,
                usage: response.usage,
            });
        }
        case 'llmCompletionResponse':
            const response = pb_1.PbType.unpackLLMCompletionResponse(value);
            return new graph_types_1.Content({ content: response.content });
        case 'text':
            return pb_1.PbType.unpackText(value);
        case 'json':
            return pb_1.PbType.unpackJson(value);
        case 'ttsOutput':
            return pb_1.PbType.unpackTTSOutput(value);
        case 'safetyResult': {
            const result = pb_1.PbType.unpackSafetyResult(value);
            return new safety_result_1.SafetyResult({
                isSafe: result.isSafe,
                text: result.text,
            });
        }
        case 'matchedKeywords': {
            const result = pb_1.PbType.unpackMatchedKeywords(value);
            return new matched_keywords_1.MatchedKeywords(result.keywords);
        }
        case 'classificationResult': {
            const result = pb_1.PbType.unpackClassificationResult(value);
            return new classification_result_1.ClassificationResult(result);
        }
        case 'knowledgeRecords': {
            const result = pb_1.PbType.unpackKnowledgeRecords(value);
            return new knowledge_records_1.KnowledgeRecords(result);
        }
        case 'customData': {
            const result = pb_1.PbType.unpackCustomData(value);
            return new custom_1.CustomData({
                value: (_b = result.value) !== null && _b !== void 0 ? _b : {},
                schema: result.schema,
            });
        }
        case 'error': {
            const result = pb_1.PbType.unpackGraphError(value);
            return new graph_error_1.GraphError(result.message, result.code);
        }
        case 'matchedIntents': {
            const result = pb_1.PbType.unpackMatchedIntents(value);
            return new matched_intents_1.MatchedIntents(result.intents);
        }
        case 'goalAdvancementResponse': {
            const result = pb_1.PbType.unpackGoalAdvancement(value);
            return new goal_advancement_response_1.GoalAdvancementResponse({
                activatedGoals: result.activatedGoals,
                completedGoals: result.completedGoals,
                currentGoals: result.currentGoals,
                beliefState: (result === null || result === void 0 ? void 0 : result.beliefState) || '',
            });
        }
        case 'toolCallRequest': {
            const result = pb_1.PbType.unpackToolCallRequest(value);
            return new tool_call_request_1.ToolCallRequest(result.toolCalls);
        }
        case 'listToolsResponse': {
            const result = pb_1.PbType.unpackListToolsResponse(value);
            return new list_tools_response_1.ListToolsResponse({
                tools: result.tools,
            });
        }
        case 'llmChatRequest': {
            const result = pb_1.PbType.unpackLLMChatRequest(value);
            return new llm_chat_request_1.LLMChatRequest({
                messages: result.messages,
                tools: result.tools,
                responseFormat: result.responseFormat,
            });
        }
        case 'llmChatRoutingRequest': {
            const result = pb_1.PbType.unpackLLMChatRoutingRequest(value);
            return new llm_chat_routing_request_1.LLMChatRoutingRequest({
                messages: result.messages,
                modelId: result.modelId,
                modelSelection: result.modelSelection,
                promptVariables: result.promptVariables,
                responseFormat: result.responseFormat,
                strategy: result.strategy,
                stream: result.stream,
                textGenerationConfig: result.textGenerationConfig,
                toolChoice: result.toolChoice,
                tools: result.tools,
            });
        }
        case 'toolCallResponse': {
            const result = pb_1.PbType.unpackToolCallResponse(value);
            return new tool_call_response_1.ToolCallResponse(result);
        }
        case 'any':
            return pb_1.PbType.unpackAny(value);
        case 'dataStreamWithMetadata': {
            // Non-streaming case (e.g., in condition evaluations) - return just metadata
            const metadata = pb_1.PbType.unpackDataStreamWithMetadata(value);
            return metadata;
        }
        default:
            // eslint-disable-next-line no-console
            console.warn(`Unknown pb type: ${determinedType}, returning raw value`);
            return value;
    }
}
/**
 * @internal
 * Converts an addon TaggedType to appropriate CustomNodeInputTypes wrapper
 * instances. Handles both regular data types and streaming types with _stream
 * fields.
 *
 * @returns Appropriate wrapper instance or null if conversion fails
 * @param value
 */
function fromExternal(value) {
    if ((0, pb_1.isPbBaseType)(value)) {
        const result = convertPbToCustomType(value);
        if (result !== null) {
            return result;
        }
        throw new Error('Wrong use case for datatype');
    }
    if (!value || typeof value !== 'object' || !value.type) {
        return value;
    }
    // All others should be stream types
    const taggedStreamType = value;
    const { type, data } = taggedStreamType;
    if (!((0, types_1.isStreamingTaggedType)(taggedStreamType) && taggedStreamType._stream)) {
        // No stream (e.g., in edge conditions) - return just the metadata as a
        // plain object Edge conditions only need metadata to make routing decisions
        return (data === null || data === void 0 ? void 0 : data.metadata) || data || {};
    }
    switch (type) {
        case 'TTSRequest':
            return tts_request_1.TTSRequest.withStream(stream_1.TextStream.fromExternal(taggedStreamType._stream), data === null || data === void 0 ? void 0 : data.voice);
        case 'ContentStream':
            return stream_1.ContentStream.fromExternal(taggedStreamType._stream);
        case 'TextStream':
            return stream_1.TextStream.fromExternal(taggedStreamType._stream);
        case 'MultimodalContentStream':
            return stream_1.MultimodalContentStream.fromExternal(taggedStreamType._stream);
        case 'TTSOutputStream':
            return stream_1.TTSOutputStream.fromExternal(taggedStreamType._stream);
        case 'SpeechChunkStream':
            return stream_1.SpeechChunkStream.fromExternal(taggedStreamType._stream);
        case 'AudioChunkStream':
            return stream_1.AudioChunkStream.fromExternal(taggedStreamType._stream);
        case 'LLMChatResponse': {
            return stream_1.ContentStream.fromExternal(taggedStreamType._stream);
        }
        case 'LLMCompletionResponse':
            return stream_1.TextStream.fromExternal(taggedStreamType._stream);
        case 'DataStream':
            // Wrap the stream based on its type
            switch (taggedStreamType._stream.type) {
                case 'TTSOutput':
                    return stream_1.TTSOutputStream.fromExternal(taggedStreamType._stream);
                case 'Content':
                    return stream_1.ContentStream.fromExternal(taggedStreamType._stream);
                case 'MultimodalContent':
                    return stream_1.MultimodalContentStream.fromExternal(taggedStreamType._stream);
                case 'Audio':
                    return stream_1.AudioChunkStream.fromExternal(taggedStreamType._stream);
                case 'Text':
                case 'String':
                default:
                    // For Text and String streams, wrap in TextStream
                    return stream_1.TextStream.fromExternal(taggedStreamType._stream);
            }
        case 'DataStreamWithMetadata':
            // Has stream - return full DataStreamWithMetadata
            const streamType = taggedStreamType._stream.type;
            const metadata = (data === null || data === void 0 ? void 0 : data.metadata) || {};
            // Add streamType to metadata if not already present
            // This documents what type of elements the stream contains
            if (!metadata.elementType && streamType) {
                metadata.elementType = streamType;
            }
            return new data_stream_with_metadata_1.DataStreamWithMetadata(taggedStreamType._stream, metadata);
        default:
            throw new inworld_1.InworldError(`Unhandled case for stream type: ${type}`, value);
    }
}
