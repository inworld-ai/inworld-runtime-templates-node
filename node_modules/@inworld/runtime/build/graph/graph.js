"use strict";
var __esDecorate = (this && this.__esDecorate) || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
    function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
    var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
    var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
    var _, done = false;
    for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
        var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
        if (kind === "accessor") {
            if (result === void 0) continue;
            if (result === null || typeof result !== "object") throw new TypeError("Object expected");
            if (_ = accept(result.get)) descriptor.get = _;
            if (_ = accept(result.set)) descriptor.set = _;
            if (_ = accept(result.init)) initializers.unshift(_);
        }
        else if (_ = accept(result)) {
            if (kind === "field") initializers.unshift(_);
            else descriptor[key] = _;
        }
    }
    if (target) Object.defineProperty(target, contextIn.name, descriptor);
    done = true;
};
var __runInitializers = (this && this.__runInitializers) || function (thisArg, initializers, value) {
    var useValue = arguments.length > 2;
    for (var i = 0; i < initializers.length; i++) {
        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
    }
    return useValue ? value : void 0;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Graph = void 0;
const uuid_1 = require("uuid");
const internal_1 = __importDefault(require("../internal/decorators/internal"));
const default_1 = require("../internal/default");
const inworld_1 = require("../internal/error/inworld");
const node_api_1 = require("../internal/node_api");
const pb_1 = require("../internal/pb");
const auth_1 = require("../internal/utils/auth");
const assert_1 = __importDefault(require("../internal/utils/type/assert"));
const GraphOutputStream_1 = require("./GraphOutputStream");
const GraphSchemaValidator_1 = __importDefault(require("./GraphSchemaValidator"));
const to_external_1 = require("./utils/to_external");
const isGraphOptions = (options) => {
    return (typeof options === 'object' && options !== null && 'jsonConfig' in options);
};
/**
 * Represents a graph that can be executed.
 */
let Graph = (() => {
    var _a;
    let _graph_decorators;
    let _graph_initializers = [];
    let _graph_extraInitializers = [];
    let _graphInitialization_decorators;
    let _graphInitialization_initializers = [];
    let _graphInitialization_extraInitializers = [];
    return _a = class Graph {
            /**
             * Creates a new Graph instance.
             *
             * @param options
             */
            constructor(options) {
                this.options = options;
                this.jsonConfig = '';
                this.graph = __runInitializers(this, _graph_initializers, void 0);
                this.graphInitialization = (__runInitializers(this, _graph_extraInitializers), __runInitializers(this, _graphInitialization_initializers, void 0));
                this.graphId = __runInitializers(this, _graphInitialization_extraInitializers);
                (0, assert_1.default)(isGraphOptions(this.options), 'Invalid graph options');
                GraphSchemaValidator_1.default.validate(options === null || options === void 0 ? void 0 : options.jsonConfig);
                this.jsonConfig = this.options.jsonConfig;
                this.graphId = JSON.parse(this.jsonConfig).main.id;
                const authEndpoint = (0, auth_1.getAuthEndpointFromEnv)();
                (0, assert_1.default)(authEndpoint, 'INWORLD_ENDPOINT is not set');
                const substitutions = Object.assign({ INWORLD_API_KEY: this.options.apiKey || '' }, this.options.substitutions);
                const graphRequest = pb_1.graphMethods.createGraphRequest({
                    specJson: this.jsonConfig,
                    substitutions,
                    featureFlagConfig: {
                        enabled: this.options.enableRemoteConfig,
                        flagdAddress: authEndpoint,
                        evaluationMode: default_1.Default.featureFlag.evaluationMode,
                        pollIntervalMs: default_1.Default.featureFlag.pollIntervalMs,
                    },
                });
                this.graphInitialization = (0, node_api_1.createGraph)(graphRequest);
            }
            /**
             * Executes the compiled graph with user context.
             *
             * @param input - Input data as a native JS object
             * @param context - Execution context containing optional parameters
             * @param context.executionId - Unique identifier for this execution. If not provided, a UUID v7 will be generated
             * @param context.userContext - User context for this execution, use that to target experiments and a/b tests
             * @param context.dataStoreContent - Initial data store content. Datastore would later be injected into each execution of the custom node.
             * @param context.dataToStore - Alias for dataStoreContent following proto naming; takes precedence when both are provided.
             * @param context.userCredentials - Optional user credentials used when executing the graph.
             * @returns {ExecutionResult}
             * @throws {@link InworldError} If execution ID is empty
             * @public
             */
            async start(input, { dataStoreContent, dataToStore, executionId: providedExecutionId, userContext, userCredentials, } = {}) {
                if (this.graphInitialization) {
                    this.graph = await this.graphInitialization;
                    this.graphInitialization = undefined;
                }
                let executionId = providedExecutionId !== null && providedExecutionId !== void 0 ? providedExecutionId : (0, uuid_1.v7)();
                executionId = executionId.trim();
                if (executionId === '') {
                    throw new inworld_1.InworldError('Execution ID cannot be empty');
                }
                const taggedInput = (0, to_external_1.toExternal)(input);
                const storePrefillSource = dataToStore !== null && dataToStore !== void 0 ? dataToStore : dataStoreContent;
                let dataStorePrefill;
                if (storePrefillSource) {
                    const entries = Object.entries(storePrefillSource);
                    if (entries.length > 0) {
                        dataStorePrefill = {};
                        for (const [key, value] of entries) {
                            const convertedValue = (0, to_external_1.toExternal)(value);
                            if (!(0, pb_1.isPbBaseType)(convertedValue)) {
                                throw new inworld_1.InworldError(`Data store entry "${key}" must be serializable to a DataContainer.`);
                            }
                            dataStorePrefill[key] = convertedValue;
                        }
                    }
                }
                const startRequest = pb_1.graphMethods.createStartExecutionRequest({
                    executionContext: {
                        executionId,
                        userContext: userContext
                            ? {
                                attributes: userContext.attributes,
                                targetingKey: userContext.targetingKey,
                            }
                            : undefined,
                        userCredentials,
                        dataToStore: dataStorePrefill,
                    },
                });
                let jsExecution;
                try {
                    jsExecution = await this.graph.start(taggedInput, startRequest);
                }
                catch (error) {
                    throw new inworld_1.InworldError(error);
                }
                const graphOutputStream = new GraphOutputStream_1.GraphOutputStream(jsExecution);
                graphOutputStream.setOnFinished(async () => {
                    // eslint-disable-next-line no-console
                    console.debug('GraphOutputStream finished');
                });
                return {
                    variantName: jsExecution.variant,
                    outputStream: graphOutputStream,
                    executionId,
                };
            }
            /**
             * Returns the JSON configuration of the graph.
             *
             * @returns The JSON configuration of the graph
             */
            toJSON() {
                return this.jsonConfig;
            }
            /**
             * Stops the graph executor.
             */
            async stop() {
                await this.graph.stop();
            }
            /**
             * Cancel the execution
             */
            async cancelExecution(id) {
                await this.graph.cancelExecution(id);
            }
            /**
             * Gets the unique identifier for this graph.
             *
             * @returns The graph's unique ID
             */
            getGraphId() {
                return this.graphId;
            }
            /**
             * Generate a visualization of the graph structure.
             *
             * Creates a visual representation of the graph in PNG format.
             * This method requires Graphviz to be installed on the system.
             *
             * @param outputPath - Path where the PNG visualization should be saved
             * @returns Promise that resolves when visualization is complete
             * @throws {@link InworldError} If visualization fails or Graphviz is not installed
             */
            async visualize(outputPath) {
                if (this.graphInitialization) {
                    this.graph = await this.graphInitialization;
                    this.graphInitialization = undefined;
                }
                if (!this.graph) {
                    throw new inworld_1.InworldError('Graph not initialized');
                }
                try {
                    await this.graph.visualize(outputPath);
                }
                catch (error) {
                    throw new inworld_1.InworldError(`Failed to visualize graph: ${error}`);
                }
            }
        },
        (() => {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _graph_decorators = [internal_1.default];
            _graphInitialization_decorators = [internal_1.default];
            __esDecorate(null, null, _graph_decorators, { kind: "field", name: "graph", static: false, private: false, access: { has: obj => "graph" in obj, get: obj => obj.graph, set: (obj, value) => { obj.graph = value; } }, metadata: _metadata }, _graph_initializers, _graph_extraInitializers);
            __esDecorate(null, null, _graphInitialization_decorators, { kind: "field", name: "graphInitialization", static: false, private: false, access: { has: obj => "graphInitialization" in obj, get: obj => obj.graphInitialization, set: (obj, value) => { obj.graphInitialization = value; } }, metadata: _metadata }, _graphInitialization_initializers, _graphInitialization_extraInitializers);
            if (_metadata) Object.defineProperty(_a, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        })(),
        _a;
})();
exports.Graph = Graph;
