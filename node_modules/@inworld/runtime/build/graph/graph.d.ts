import type { Credentials } from '../common/api/library';
import { UserContextInterface } from '../common/data_types/common';
import { GraphOutputStream } from './GraphOutputStream';
/**
 * Result of a single execution of the graph.
 * It contains the output stream and the execution ID.
 *
 * @param variantName - Variant of the graph that was executed
 * @param outputStream - Output stream of the execution
 * @param executionId - Unique identifier for this execution
 */
export interface ExecutionResult {
    variantName: string;
    outputStream: GraphOutputStream;
    executionId: string;
}
/**
 * Context for the single execution of the graph.
 * It is used to pass optional parameters to the graph execution.
 * It is not required to pass all of the parameters, only the ones that are needed.
 */
export interface ExecutionContext {
    executionId?: string;
    userContext?: UserContextInterface;
    dataStoreContent?: Record<string, any>;
    /**
     * Optional alias for dataStoreContent that matches proto naming.
     * If both dataStoreContent and dataToStore are provided, dataToStore takes precedence.
     */
    dataToStore?: Record<string, any>;
    userCredentials?: Credentials;
}
export type GraphOptions = {
    jsonConfig: string;
    enableRemoteConfig?: boolean;
    apiKey?: string;
    substitutions?: Record<string, string>;
};
/**
 * Represents a graph that can be executed.
 */
export declare class Graph {
    private options;
    private jsonConfig;
    private graph;
    private graphInitialization;
    private graphId;
    /**
     * Creates a new Graph instance.
     *
     * @param options
     */
    constructor(options: GraphOptions);
    /**
     * Executes the compiled graph with user context.
     *
     * @param input - Input data as a native JS object
     * @param context - Execution context containing optional parameters
     * @param context.executionId - Unique identifier for this execution. If not provided, a UUID v7 will be generated
     * @param context.userContext - User context for this execution, use that to target experiments and a/b tests
     * @param context.dataStoreContent - Initial data store content. Datastore would later be injected into each execution of the custom node.
     * @param context.dataToStore - Alias for dataStoreContent following proto naming; takes precedence when both are provided.
     * @param context.userCredentials - Optional user credentials used when executing the graph.
     * @returns {ExecutionResult}
     * @throws {@link InworldError} If execution ID is empty
     * @public
     */
    start(input: any, { dataStoreContent, dataToStore, executionId: providedExecutionId, userContext, userCredentials, }?: ExecutionContext): Promise<ExecutionResult>;
    /**
     * Returns the JSON configuration of the graph.
     *
     * @returns The JSON configuration of the graph
     */
    toJSON(): string;
    /**
     * Stops the graph executor.
     */
    stop(): Promise<void>;
    /**
     * Cancel the execution
     */
    cancelExecution(id: string): Promise<void>;
    /**
     * Gets the unique identifier for this graph.
     *
     * @returns The graph's unique ID
     */
    getGraphId(): string;
    /**
     * Generate a visualization of the graph structure.
     *
     * Creates a visual representation of the graph in PNG format.
     * This method requires Graphviz to be installed on the system.
     *
     * @param outputPath - Path where the PNG visualization should be saved
     * @returns Promise that resolves when visualization is complete
     * @throws {@link InworldError} If visualization fails or Graphviz is not installed
     */
    visualize(outputPath: string): Promise<void>;
}
