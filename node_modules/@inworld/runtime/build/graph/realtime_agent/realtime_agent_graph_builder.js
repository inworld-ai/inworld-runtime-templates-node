"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RealtimeAgentGraphBuilder = void 0;
exports.buildRealtimeAgentGraph = buildRealtimeAgentGraph;
const remote_llm_component_1 = require("../dsl/components/remote_llm_component");
const remote_tts_component_1 = require("../dsl/components/remote_tts_component");
const graph_builder_1 = require("../dsl/graph_builder");
const realtime_agent_1 = require("../dsl/nodes/realtime_agent");
const transform_node_1 = require("../dsl/nodes/transform_node");
const DEFAULT_VAD_COMPONENT_ID = 'local_vad';
const DEFAULT_TURN_DETECTOR_COMPONENT_ID = 'local_turn_detector';
const DEFAULT_INWORLD_STT_COMPONENT_ID = 'inworld_stt';
const DEFAULT_GROQ_STT_COMPONENT_ID = 'groq_stt';
const DEFAULT_LLM_COMPONENT_ID = 'inworld_llm';
const DEFAULT_TTS_COMPONENT_ID = 'inworld_tts';
const DEFAULT_AGENT_PROMPT_SUB_KEY = 'AGENT_PROMPT';
const DEFAULT_VAD_MODEL_PATH_SUB_KEY = 'VAD_MODEL_PATH';
const DEFAULT_TURN_DETECTOR_MODEL_PATH_SUB_KEY = 'TURN_DETECTOR_MODEL_PATH';
const DEFAULT_GROQ_API_KEY_SUB_KEY = 'GROQ_API_KEY';
/**
 * Graph builder that assembles the builtin realtime agent pipeline.
 *
 * @remarks
 * The resulting graph matches the C++ blueprint shape (nodes/edges/conditions),
 * but lets you pass substitutions and a few safe overrides.
 *
 * @example
 * ```typescript
 * import { RealtimeAgentGraphBuilder } from '@inworld/runtime/graph';
 *
 * const agentPrompt = "User: {{user_query}}\\nA:";
 *
 * const g = new RealtimeAgentGraphBuilder({
 *   id: 'my-realtime-agent',
 *   apiKey: process.env.INWORLD_API_KEY,
 *   substitutions: {
 *     AGENT_PROMPT: agentPrompt,
 *     VAD_MODEL_PATH: '/path/to/vad.onnx',
 *     TURN_DETECTOR_MODEL_PATH: '/path/to/turn_detector.onnx',
 *     GROQ_API_KEY: process.env.GROQ_API_KEY ?? '',
 *   },
 * }).build();
 * ```
 */
class RealtimeAgentGraphBuilder extends graph_builder_1.GraphBuilder {
    /**
     * Creates a new {@link RealtimeAgentGraphBuilder} instance and assembles
     * the builtin realtime agent pipeline.
     *
     * @param {RealtimeAgentGraphBuilderProps} opts - Builder configuration.
     */
    constructor(opts) {
        var _a;
        const mergedSubstitutions = mergeRealtimeAgentSubstitutions(opts);
        super(Object.assign(Object.assign({}, opts), { enableRemoteConfig: (_a = opts.enableRemoteConfig) !== null && _a !== void 0 ? _a : false, substitutions: mergedSubstitutions }));
        this.buildRealtimeAgentPipeline(opts);
    }
    buildRealtimeAgentPipeline(opts) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        // Components --------------------------------------------------------------
        // Local VAD component (raw JSON)
        this.addComponent(makeLocalVadComponent(DEFAULT_VAD_COMPONENT_ID, opts));
        // Local turn detector component (raw JSON)
        this.addComponent(makeLocalTurnDetectorComponent(DEFAULT_TURN_DETECTOR_COMPONENT_ID, opts));
        // Groq STT component (raw JSON) - requires respecting GROQ api key placeholder
        this.addComponent(makeGroqSttComponent(DEFAULT_GROQ_STT_COMPONENT_ID));
        // Inworld STT component (raw JSON)
        this.addComponent(makeInworldSttComponent(DEFAULT_INWORLD_STT_COMPONENT_ID));
        // LLM component (DSL component)
        const llmComponent = new remote_llm_component_1.RemoteLLMComponent({
            id: DEFAULT_LLM_COMPONENT_ID,
            provider: 'groq',
            modelName: 'llama-3.3-70b-versatile',
            defaultConfig: {
                maxNewTokens: 160,
                maxPromptLength: 8000,
                temperature: 0.7,
                topP: 0.95,
                repetitionPenalty: 1.0,
                frequencyPenalty: 0.0,
                presencePenalty: 0.0,
                stopSequences: ['\n\n'],
            },
        });
        this.addComponent(llmComponent);
        // TTS component (DSL component)
        const ttsComponent = new remote_tts_component_1.RemoteTTSComponent({
            id: DEFAULT_TTS_COMPONENT_ID,
            synthesisConfig: {
                type: 'inworld',
                config: {
                    modelId: 'inworld-tts-1',
                    postprocessing: { sampleRate: 16000 },
                    inference: { temperature: 0.8, speakingRate: 1.0 },
                },
            },
        });
        this.addComponent(ttsComponent);
        // Nodes ------------------------------------------------------------------
        // Use raw node configs for builtin nodes where the DSL wrappers emit extra default fields.
        // This keeps the emitted JSON aligned with the C++ blueprint.
        const inputProxyNode = {
            id: 'input_proxy_node',
            type: 'ProxyNode',
        };
        this.addNode(inputProxyNode);
        const interruptionEventOutputTemplate = (_b = (_a = opts.overrides) === null || _a === void 0 ? void 0 : _a.interruptionEventOutputTemplate) !== null && _b !== void 0 ? _b : "{'is_interruption': input.is_interruption}";
        const interruptionEventNode = new transform_node_1.TransformNode({
            id: 'interruption_event_node',
            reportToClient: true,
            outputType: 'Json',
            outputTemplate: interruptionEventOutputTemplate,
        });
        this.addNode(interruptionEventNode);
        const slicer = new realtime_agent_1.RealtimeAgentInputSlicerNode({
            id: 'input_slicer_node',
            vadComponentId: (_d = (_c = opts.inputSlicer) === null || _c === void 0 ? void 0 : _c.vadComponentId) !== null && _d !== void 0 ? _d : DEFAULT_VAD_COMPONENT_ID,
            turnDetectorComponentId: (_f = (_e = opts.inputSlicer) === null || _e === void 0 ? void 0 : _e.turnDetectorComponentId) !== null && _f !== void 0 ? _f : DEFAULT_TURN_DETECTOR_COMPONENT_ID,
            maxSpeechDurationPerTurnMs: (_g = opts.inputSlicer) === null || _g === void 0 ? void 0 : _g.maxSpeechDurationPerTurnMs,
            maxSilenceToFinishTurnMs: (_h = opts.inputSlicer) === null || _h === void 0 ? void 0 : _h.maxSilenceToFinishTurnMs,
            sampleRate: (_j = opts.inputSlicer) === null || _j === void 0 ? void 0 : _j.sampleRate,
        });
        this.addNode(slicer);
        const audioExtractor = new realtime_agent_1.RealtimeAgentAudioExtractorNode({
            id: 'audio_extractor_node',
        });
        this.addNode(audioExtractor);
        // STT node (raw JSON) to reference groq_stt component id directly
        const selectedSttComponentId = (_k = opts.sttComponentId) !== null && _k !== void 0 ? _k : DEFAULT_GROQ_STT_COMPONENT_ID;
        const sttNode = {
            id: 'stt_node',
            type: 'STTNode',
            execution_config: {
                type: 'STTNodeExecutionConfig',
                properties: {
                    stt_component_id: selectedSttComponentId,
                },
            },
        };
        this.addNode(sttNode);
        const interactionInfo = new realtime_agent_1.RealtimeAgentInteractionInfoNode({
            id: 'interaction_info_node',
            reportToClient: true,
        });
        this.addNode(interactionInfo);
        const interactionQueue = new realtime_agent_1.RealtimeAgentInteractionQueueNode({
            id: 'interaction_queue_node',
        });
        this.addNode(interactionQueue);
        const promptVariables = new realtime_agent_1.RealtimeAgentPromptVariablesNode({
            id: 'prompt_variables_node',
        });
        this.addNode(promptVariables);
        const llmNode = {
            id: 'llm_node',
            type: 'LLMChatNode',
            execution_config: {
                type: 'LLMChatNodeExecutionConfig',
                properties: {
                    llm_component_id: DEFAULT_LLM_COMPONENT_ID,
                    stream: true,
                    text_generation_config: {
                        max_new_tokens: 160,
                        max_prompt_length: 200,
                        temperature: 0.75,
                        top_p: 0.9,
                        repetition_penalty: 1.01,
                        frequency_penalty: 0.0,
                        presence_penalty: 0.0,
                        stop_sequences: ['\n\n'],
                    },
                    message_templates: [
                        {
                            role: 'user',
                            // TextContentItem with Jinja template in the text field
                            content: [
                                { type: 'text', text: `{{${DEFAULT_AGENT_PROMPT_SUB_KEY}}}` },
                            ],
                        },
                    ],
                },
            },
        };
        this.addNode(llmNode);
        const stateUpdater = new realtime_agent_1.RealtimeAgentStateUpdaterNode({
            id: 'state_updater_node',
        });
        this.addNode(stateUpdater);
        const textChunking = {
            id: 'text_chunking_node',
            type: 'TextChunkingNode',
            execution_config: {
                type: 'TextChunkingNodeExecutionConfig',
                properties: {},
            },
        };
        this.addNode(textChunking);
        const ttsNode = {
            id: 'tts_node',
            type: 'TTSNode',
            execution_config: {
                type: 'TTSNodeExecutionConfig',
                properties: {
                    tts_component_id: DEFAULT_TTS_COMPONENT_ID,
                    voice: {
                        id: (_l = opts.voiceId) !== null && _l !== void 0 ? _l : 'Dennis',
                        language_code: (_m = opts.voiceLanguageCode) !== null && _m !== void 0 ? _m : 'en-US',
                    },
                    synthesis_config: {
                        type: 'inworld',
                        config: {
                            model_id: 'inworld-tts-1',
                            postprocessing: {
                                sample_rate: 24000,
                            },
                            inference: {
                                temperature: 1.1,
                                speaking_rate: 1.0,
                            },
                        },
                    },
                },
            },
        };
        this.addNode(ttsNode);
        const ttsFirstChunk = new realtime_agent_1.RealtimeAgentTtsFirstChunkCheckingNode({
            id: 'tts_first_chunk_checking_node',
            reportToClient: true,
        });
        this.addNode(ttsFirstChunk);
        const textExtractor = {
            id: 'text_extractor_node',
            type: 'TransformNode',
            creation_config: {
                type: 'TransformNodeCreationConfig',
                properties: {
                    output_type: 'Text',
                    output_template: {
                        value: 'input.text_input',
                    },
                },
            },
        };
        this.addNode(textExtractor);
        // Edges ------------------------------------------------------------------
        this.addEdge('input_proxy_node', 'input_slicer_node');
        this.addEdge('input_slicer_node', 'input_slicer_node', {
            optional: true,
            loop: true,
            conditionExpression: 'input.is_running == true',
        });
        this.addEdge('input_slicer_node', 'interruption_event_node', {
            conditionExpression: 'input.is_interruption == true',
        });
        this.addEdge('input_slicer_node', 'audio_extractor_node', {
            conditionExpression: 'input.is_running == true && !input.is_interruption && input.is_text_input == false',
        });
        this.addEdge('input_slicer_node', 'text_extractor_node', {
            conditionExpression: 'input.is_text_input == true',
        });
        this.addEdge('audio_extractor_node', 'stt_node');
        this.addEdge('input_slicer_node', 'interaction_info_node', {
            conditionExpression: 'input.is_running && (input.is_text_input || !input.is_interruption)',
        });
        this.addEdge('text_extractor_node', 'interaction_info_node', {
            optional: true,
        });
        this.addEdge('stt_node', 'interaction_info_node', {
            optional: true,
        });
        this.addEdge('interaction_info_node', 'interaction_queue_node');
        this.addEdge('interaction_queue_node', 'prompt_variables_node', {
            conditionExpression: "has(input.value) && input.value != ''",
        });
        this.addEdge('prompt_variables_node', 'llm_node');
        this.addEdge('llm_node', 'text_chunking_node');
        this.addEdge('text_chunking_node', 'tts_node');
        this.addEdge('text_chunking_node', 'state_updater_node');
        this.addEdge('tts_node', 'tts_first_chunk_checking_node');
        this.addEdge('tts_first_chunk_checking_node', 'state_updater_node');
        this.addEdge('state_updater_node', 'interaction_queue_node', {
            loop: true,
            optional: true,
        });
        this.setStartNode(inputProxyNode);
        this.setEndNode('state_updater_node');
    }
}
exports.RealtimeAgentGraphBuilder = RealtimeAgentGraphBuilder;
/**
 * Builds a realtime agent graph and returns a {@link Graph} ready for execution.
 *
 * @param {BuildRealtimeAgentGraphProps} props - Graph builder configuration.
 * @returns {Graph} Built graph instance.
 */
function buildRealtimeAgentGraph(props) {
    return new RealtimeAgentGraphBuilder(props).build();
}
function mergeRealtimeAgentSubstitutions(opts) {
    var _a;
    const base = (_a = opts.substitutions) !== null && _a !== void 0 ? _a : {};
    const merged = Object.assign({}, base);
    // Apply convenience substitution values only when the key is not already provided
    if (opts.agentPrompt !== undefined &&
        merged[DEFAULT_AGENT_PROMPT_SUB_KEY] === undefined) {
        merged[DEFAULT_AGENT_PROMPT_SUB_KEY] = opts.agentPrompt;
    }
    if (opts.vadModelPath !== undefined &&
        merged[DEFAULT_VAD_MODEL_PATH_SUB_KEY] === undefined) {
        merged[DEFAULT_VAD_MODEL_PATH_SUB_KEY] = opts.vadModelPath;
    }
    if (opts.turnDetectorModelPath !== undefined &&
        merged[DEFAULT_TURN_DETECTOR_MODEL_PATH_SUB_KEY] === undefined) {
        merged[DEFAULT_TURN_DETECTOR_MODEL_PATH_SUB_KEY] =
            opts.turnDetectorModelPath;
    }
    if (opts.groqApiKey !== undefined &&
        merged[DEFAULT_GROQ_API_KEY_SUB_KEY] === undefined) {
        merged[DEFAULT_GROQ_API_KEY_SUB_KEY] = opts.groqApiKey;
    }
    return merged;
}
function makeLocalVadComponent(id, _opts) {
    const modelPath = `{{${DEFAULT_VAD_MODEL_PATH_SUB_KEY}}}`;
    return {
        id,
        type: 'VADInterface',
        creation_config: {
            type: 'LocalVADConfig',
            properties: {
                model_path: modelPath,
                device: {
                    type: 'CPU',
                    index: -1,
                    info: {
                        name: 'CPU',
                        timestamp: 0,
                        free_memory_bytes: 0,
                        total_memory_bytes: 0,
                    },
                },
                default_config: {
                    speech_threshold: 0.5,
                },
            },
        },
    };
}
function makeLocalTurnDetectorComponent(id, _opts) {
    const modelPath = `{{${DEFAULT_TURN_DETECTOR_MODEL_PATH_SUB_KEY}}}`;
    return {
        id,
        type: 'TurnDetectorInterface',
        creation_config: {
            type: 'LocalTurnDetectorConfig',
            properties: {
                model_path: modelPath,
                device: {
                    type: 'CPU',
                    index: -1,
                    info: {
                        name: 'CPU',
                        timestamp: 0,
                        free_memory_bytes: 0,
                        total_memory_bytes: 0,
                    },
                },
                default_config: {
                    threshold: 0.5,
                },
            },
        },
    };
}
function makeGroqSttComponent(id) {
    return {
        id,
        type: 'STTInterface',
        creation_config: {
            type: 'RemoteSTTConfig',
            properties: {
                service: 'groq',
                config: {
                    api_key: `{{${DEFAULT_GROQ_API_KEY_SUB_KEY}}}`,
                    model_id: 'whisper-large-v3',
                    default_config: {
                        language_code: 'en-US',
                    },
                    default_timeout: 30,
                },
            },
        },
    };
}
function makeInworldSttComponent(id) {
    return {
        id,
        type: 'STTInterface',
        creation_config: {
            type: 'RemoteSTTConfig',
            properties: {
                service: 'inworld',
                config: {
                    api_key: '{{INWORLD_API_KEY}}',
                    model_id: 'groq/whisper-large-v3',
                    default_config: {
                        language_code: 'en-US',
                    },
                    default_timeout: 30,
                },
            },
        },
    };
}
