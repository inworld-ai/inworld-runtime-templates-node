import { GraphTypes } from '../common/data_types/type_mapping';
import { CustomNodeInputTypes } from '../common/data_types/type_mapping';
type ProcessResponseHandler<T> = (value: T) => void | Promise<void>;
/**
 * Represents a response from a graph output stream.
 * This class contains all possible data types that can be returned
 * from graph nodes during execution. Each type serves a specific purpose
 * in the graph processing pipeline.
 */
export declare class GraphOutputStreamResponse<T extends CustomNodeInputTypes = CustomNodeInputTypes> {
    data: T;
    done: boolean;
    /**
     * Optional callback to call when response processing is complete
     * @internal
     */
    private onProcessingComplete?;
    /**
     * Creates a new GraphOutputStreamResponse instance.
     *
     * @param data - The graph output stream data, if available
     * @param done - Whether the graph has finished executing. When true, indicates that
     *               the graph execution has completed and no more data will be streamed.
     */
    constructor(data: T, done?: boolean);
    get typeName(): import("../common/data_types/type_mapping").CustomNodeInputTypeName;
    /**
     * Sets a callback to be called when response processing is complete.
     * This is called after all handlers in processResponse have finished executing.
     *
     * @param callback - Function to call when processing is complete
     * @internal
     */
    setOnProcessingComplete(callback: () => void): void;
    isString(): this is GraphOutputStreamResponse<string>;
    isCustom(): this is GraphOutputStreamResponse<GraphTypes.Custom<object>>;
    isClassificationResult(): this is GraphOutputStreamResponse<GraphTypes.ClassificationResult>;
    isContent(): this is GraphOutputStreamResponse<GraphTypes.Content>;
    isGoalAdvancement(): this is GraphOutputStreamResponse<GraphTypes.GoalAdvancementResponse>;
    isAudio(): this is GraphOutputStreamResponse<GraphTypes.Audio>;
    isKnowledgeRecords(): this is GraphOutputStreamResponse<GraphTypes.KnowledgeRecords>;
    isListToolsResponse(): this is GraphOutputStreamResponse<GraphTypes.ListToolsResponse>;
    isLLMChatRequest(): this is GraphOutputStreamResponse<GraphTypes.LLMChatRequest>;
    isMatchedIntents(): this is GraphOutputStreamResponse<GraphTypes.MatchedIntents>;
    isMatchedKeywords(): this is GraphOutputStreamResponse<GraphTypes.MatchedKeywords>;
    isSafetyResult(): this is GraphOutputStreamResponse<GraphTypes.SafetyResult>;
    isToolCallResponse(): this is GraphOutputStreamResponse<GraphTypes.ToolCallResponse>;
    isTextStream(): this is GraphOutputStreamResponse<GraphTypes.TextStream>;
    isContentStream(): this is GraphOutputStreamResponse<GraphTypes.ContentStream>;
    isTTSOutputStream(): this is GraphOutputStreamResponse<GraphTypes.TTSOutputStream>;
    isSpeechChunkStream(): this is GraphOutputStreamResponse<GraphTypes.SpeechChunkStream>;
    isGraphError(): this is GraphOutputStreamResponse<GraphTypes.GraphError>;
    isLLMChatResponse(): this is GraphOutputStreamResponse<GraphTypes.LLMChatResponse>;
    /**
     * Processes the graph output stream response with type safety using a visitor pattern.
     * This function makes it easy to handle different response types in a switch-like pattern.
     *
     * @param handlers - Object containing handler functions for each type
     * @returns The result from the appropriate handler
     *
     * @example
     * ```typescript
     * const result = response.visit({
     *   string: (text) => `Got text: ${text}`,
     *   Custom: (custom) => `Got custom data: ${JSON.stringify(custom)}`,
     *   TextStream: async (stream) => {
     *     // Handle stream...
     *     return "Processed stream";
     *   },
     *   // Add other handlers as needed
     *   default: (value) => {
     *     console.log(`Unknown type received from stream.`);
     *   },
     * });
     * ```
     */
    processResponse(handlers: {
        string?: ProcessResponseHandler<string>;
        Custom?: ProcessResponseHandler<GraphTypes.Custom<object>>;
        ClassificationResult?: ProcessResponseHandler<GraphTypes.ClassificationResult>;
        Content?: ProcessResponseHandler<GraphTypes.Content | GraphTypes.LLMChatResponse>;
        LLMChatResponse?: ProcessResponseHandler<GraphTypes.LLMChatResponse>;
        GoalAdvancement?: ProcessResponseHandler<GraphTypes.GoalAdvancementResponse>;
        KnowledgeRecords?: ProcessResponseHandler<GraphTypes.KnowledgeRecords>;
        ListToolsResponse?: ProcessResponseHandler<GraphTypes.ListToolsResponse>;
        LLMChatRequest?: ProcessResponseHandler<GraphTypes.LLMChatRequest>;
        MatchedIntents?: ProcessResponseHandler<GraphTypes.MatchedIntents>;
        MatchedKeywords?: ProcessResponseHandler<GraphTypes.MatchedKeywords>;
        SafetyResult?: ProcessResponseHandler<GraphTypes.SafetyResult>;
        ToolCallResponse?: ProcessResponseHandler<GraphTypes.ToolCallResponse>;
        TextStream?: ProcessResponseHandler<GraphTypes.TextStream>;
        ContentStream?: ProcessResponseHandler<GraphTypes.ContentStream>;
        TTSOutputStream?: ProcessResponseHandler<GraphTypes.TTSOutputStream>;
        SpeechChunkStream?: ProcessResponseHandler<GraphTypes.SpeechChunkStream>;
        Audio?: ProcessResponseHandler<GraphTypes.Audio>;
        error?: ProcessResponseHandler<GraphTypes.GraphError>;
        done?: ProcessResponseHandler<void>;
        default?: ProcessResponseHandler<CustomNodeInputTypes>;
    }): Promise<void>;
}
export {};
