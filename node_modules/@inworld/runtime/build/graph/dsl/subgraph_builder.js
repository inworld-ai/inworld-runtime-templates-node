"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.SubgraphBuilder = void 0;
const nodes_1 = require("../nodes");
const abstract_component_1 = require("./components/abstract_component");
const abstract_node_1 = require("./nodes/abstract_node");
/**
 * Builder class for creating subgraphs with a fluent API.
 * Subgraphs are reusable graph components that can be referenced by other graphs.
 *
 * @example
 * ```typescript
 * const subgraph = new SubgraphBuilder('my_subgraph')
 *   .addParameter({ name: 'user_input', type: 'string' })
 *   .addNode(intentNode)
 *   .addNode(llmNode)
 *   .addEdge(intentNode, llmNode)
 *   .setStartNode(intentNode)
 *   .setEndNode(llmNode)
 *   .build();
 * ```
 */
class SubgraphBuilder {
    /**
     * Creates a new subgraph builder with the specified ID.
     *
     * @constructor
     * @param {string} id - Unique identifier for the subgraph
     */
    constructor(id) {
        this[_a] = [];
        this.nodes = [];
        this.edges = [];
        this.subgraph = {
            id,
        };
    }
    /**
     * Adds a parameter to the subgraph that can be passed from the parent graph.
     *
     * @param {Object} config - Parameter configuration
     * @param {string} config.name - Parameter name
     * @param {string} config.type - Parameter type ('string', 'number', 'integer', 'boolean')
     *
     * @returns {SubgraphBuilder} The builder instance for method chaining
     */
    addParameter(config) {
        if (!this.subgraph.parameters) {
            this.subgraph.parameters = [];
        }
        this.subgraph.parameters.push(config);
        return this;
    }
    addComponent(component) {
        this[abstract_node_1.INTERNAL_COMPONENTS].push(component);
        return this;
    }
    /**
     * Adds multiple parameters to the subgraph at once.
     *
     * @param {Array<Object>} parameters - Array of parameter configurations
     * @param {string} parameters[].name - Parameter name
     * @param {string} parameters[].type - Parameter type ('string', 'number', 'integer', 'boolean')
     *
     * @returns {SubgraphBuilder} The builder instance for method chaining
     */
    addParameters(parameters) {
        parameters.forEach((param) => this.addParameter(param));
        return this;
    }
    /**
     * Adds a node to the subgraph.
     *
     * @param {AbstractNode} node - Node to add to the subgraph
     * @returns {SubgraphBuilder} The builder instance for method chaining
     */
    addNode(node) {
        if (node instanceof abstract_node_1.AbstractNode) {
            return this.addClassNode(node);
        }
        this.nodes.push(node);
        return this;
    }
    addClassNode(node) {
        const graphConfigNode = node[abstract_node_1.TO_GRAPH_CONFIG_NODE]();
        const components = node[abstract_node_1.INTERNAL_COMPONENTS];
        components.forEach((component) => {
            const graphConfigComponent = component[abstract_component_1.TO_GRAPH_CONFIG_COMPONENT]();
            this.addComponent(graphConfigComponent);
        });
        this.nodes.push(graphConfigNode);
        return this;
    }
    /**
     * Adds an edge connecting two nodes in the subgraph.
     *
     * @param {AbstractNode} fromNode - Source node or node ID
     * @param {AbstractNode} toNode - Destination node or node ID
     * @param {Object} [options] - Optional edge configuration
     * @param {string} [options.conditionExpression] - CEL expression for conditional execution
     * @param {CustomEdgeConditionReference | EdgeConditionCallback} [options.conditionRef] - Reference to a custom edge condition or a callback to register one
     * @param {boolean} [options.optional] - Whether the edge is optional
     * @param {boolean} [options.loop] - Whether the edge creates a loop
     *
     * @returns {SubgraphBuilder} The builder instance for method chaining
     */
    addEdge(fromNode, toNode, options) {
        const fromId = typeof fromNode === 'string' ? fromNode : fromNode.id;
        const toId = typeof toNode === 'string' ? toNode : toNode.id;
        const edge = {
            from_node: fromId,
            to_node: toId,
        };
        if (options === null || options === void 0 ? void 0 : options.conditionExpression) {
            edge.condition_expression = options.conditionExpression;
        }
        else if (options === null || options === void 0 ? void 0 : options.conditionRef) {
            if ('id' in options.conditionRef) {
                edge.condition_id = options.conditionRef.id;
            }
            else {
                const id = (0, nodes_1.registerCustomEdgeCondition)(`custom-condition-from-${fromId}-to-${toId}`, options.conditionRef).id;
                this.addComponent({
                    id,
                    type: id,
                });
                edge.condition_id = id;
            }
        }
        if ((options === null || options === void 0 ? void 0 : options.optional) !== undefined) {
            edge.optional = options.optional;
        }
        if ((options === null || options === void 0 ? void 0 : options.loop) !== undefined) {
            edge.loop = options.loop;
        }
        this.edges.push(edge);
        return this;
    }
    /**
     * Sets the start node of the subgraph (subgraphs can only have one start node).
     *
     * @param {AbstractNode} node - Start node or node ID
     * @returns {SubgraphBuilder} The builder instance for method chaining
     */
    setStartNode(node) {
        const nodeId = typeof node === 'string' ? node : node.id;
        this.startNode = nodeId;
        return this;
    }
    /**
     * Sets the end node of the subgraph (subgraphs can only have one end node).
     *
     * @param {AbstractNode} node - End node or node ID
     * @returns {SubgraphBuilder} The builder instance for method chaining
     */
    setEndNode(node) {
        const nodeId = typeof node === 'string' ? node : node.id;
        this.endNode = nodeId;
        return this;
    }
    /**
     * Builds and returns the final subgraph configuration.
     *
     * @returns {Subgraph} The completed subgraph configuration
     * @throws {Error} If the subgraph has no nodes
     */
    build() {
        // Ensure we have at least one node
        if (this.nodes.length === 0) {
            throw new Error('Subgraph must have at least one node');
        }
        this.subgraph.nodes = this.nodes;
        this.subgraph.edges = this.edges.length > 0 ? this.edges : undefined;
        this.subgraph.start_nodes = this.startNode ? [this.startNode] : undefined;
        this.subgraph.end_nodes = this.endNode ? [this.endNode] : undefined;
        return this.subgraph;
    }
}
exports.SubgraphBuilder = SubgraphBuilder;
_a = abstract_node_1.INTERNAL_COMPONENTS;
