import * as z from 'zod';
import { Camelize } from './constants';
import { CooldownConfig, FallbackConfig, NodeErrorConfig, RetryConfig } from './graph_config_schema';
/**
 * Type for error status codes (uppercase standard format).
 */
type StatusCode = 'OK' | 'CANCELLED' | 'UNKNOWN' | 'INVALID_ARGUMENT' | 'DEADLINE_EXCEEDED' | 'NOT_FOUND' | 'ALREADY_EXISTS' | 'PERMISSION_DENIED' | 'RESOURCE_EXHAUSTED' | 'FAILED_PRECONDITION' | 'ABORTED' | 'OUT_OF_RANGE' | 'UNIMPLEMENTED' | 'INTERNAL' | 'UNAVAILABLE' | 'DATA_LOSS' | 'UNAUTHENTICATED';
/**
 * Schema for error status codes with flexible input formats.
 *
 * Accepts PascalCase (e.g., 'Unavailable') or UPPERCASE (e.g., 'UNAVAILABLE') values.
 *
 * @type {z.ZodType<ErrorStatusCode>}
 *
 * @example
 * ```typescript
 * StatusCodeSchema.parse('Unavailable');  // Valid
 * StatusCodeSchema.parse('UNAVAILABLE');  // Also valid
 * ```
 */
export declare const StatusCodeSchema: z.ZodType<StatusCode>;
export declare enum ErrorStatusCode {
    Ok = "OK",
    Cancelled = "CANCELLED",
    Unknown = "UNKNOWN",
    InvalidArgument = "INVALID_ARGUMENT",
    DeadlineExceeded = "DEADLINE_EXCEEDED",
    NotFound = "NOT_FOUND",
    AlreadyExists = "ALREADY_EXISTS",
    PermissionDenied = "PERMISSION_DENIED",
    ResourceExhausted = "RESOURCE_EXHAUSTED",
    FailedPrecondition = "FAILED_PRECONDITION",
    Aborted = "ABORTED",
    OutOfRange = "OUT_OF_RANGE",
    Unimplemented = "UNIMPLEMENTED",
    Internal = "Internal",
    Unavailable = "UNAVAILABLE",
    DataLoss = "DATA_LOSS",
    Unauthenticated = "UNAUTHENTICATED"
}
/**
 * Default set of non-retryable error codes.
 * These errors are typically permanent and won't be fixed by retrying.
 */
export declare const DEFAULT_IGNORED_ERRORS: ErrorStatusCode[];
/**
 * Zod schema for retry configuration (snake_case version).
 * Retries are non-stateful and happen within a single execution.
 */
export declare const RetryConfigSchema: z.ZodPipe<z.ZodObject<{
    maxAttempts: z.ZodOptional<z.ZodNumber>;
    handleErrors: z.ZodOptional<z.ZodArray<z.ZodType<StatusCode, unknown, z.core.$ZodTypeInternals<StatusCode, unknown>>>>;
    ignoreErrors: z.ZodOptional<z.ZodArray<z.ZodType<StatusCode, unknown, z.core.$ZodTypeInternals<StatusCode, unknown>>>>;
}, z.core.$strip>, z.ZodTransform<Record<string, any>, {
    maxAttempts?: number;
    handleErrors?: StatusCode[];
    ignoreErrors?: StatusCode[];
}>>;
/**
 * Zod schema for circuit breaker cooldown configuration (snake_case version).
 * Implements circuit breaker pattern to prevent repeated attempts on persistently failing nodes.
 */
export declare const CooldownConfigSchema: z.ZodPipe<z.ZodObject<{
    minConsecutiveFailures: z.ZodOptional<z.ZodNumber>;
    cooldownDuration: z.ZodOptional<z.ZodPipe<z.ZodUnion<readonly [z.ZodString, z.ZodNumber]>, z.ZodTransform<string, string | number>>>;
}, z.core.$strip>, z.ZodTransform<Record<string, any>, {
    minConsecutiveFailures?: number;
    cooldownDuration?: string;
}>>;
/**
 * Zod schema for fallback configuration (snake_case version).
 * Fallbacks are stateful and persist across executions.
 */
export declare const FallbackConfigSchema: z.ZodPipe<z.ZodObject<{
    nodeId: z.ZodString;
    handleErrors: z.ZodOptional<z.ZodArray<z.ZodType<StatusCode, unknown, z.core.$ZodTypeInternals<StatusCode, unknown>>>>;
    ignoreErrors: z.ZodOptional<z.ZodArray<z.ZodType<StatusCode, unknown, z.core.$ZodTypeInternals<StatusCode, unknown>>>>;
    cooldown: z.ZodOptional<z.ZodPipe<z.ZodObject<{
        minConsecutiveFailures: z.ZodOptional<z.ZodNumber>;
        cooldownDuration: z.ZodOptional<z.ZodPipe<z.ZodUnion<readonly [z.ZodString, z.ZodNumber]>, z.ZodTransform<string, string | number>>>;
    }, z.core.$strip>, z.ZodTransform<Record<string, any>, {
        minConsecutiveFailures?: number;
        cooldownDuration?: string;
    }>>>;
}, z.core.$strip>, z.ZodTransform<Record<string, any>, {
    nodeId: string;
    handleErrors?: StatusCode[];
    ignoreErrors?: StatusCode[];
    cooldown?: Record<string, any>;
}>>;
/**
 * Zod schema for comprehensive node error handling configuration (snake_case version).
 * Supports three-tier failure handling:
 * 1. Retries (non-stateful, per execution)
 * 2. Fallbacks (stateful, persist across executions)
 * 3. Circuit breaker (cooldown to skip failing nodes)
 */
export declare const NodeErrorConfigSchema: z.ZodPipe<z.ZodObject<{
    retries: z.ZodOptional<z.ZodArray<z.ZodPipe<z.ZodObject<{
        maxAttempts: z.ZodOptional<z.ZodNumber>;
        handleErrors: z.ZodOptional<z.ZodArray<z.ZodType<StatusCode, unknown, z.core.$ZodTypeInternals<StatusCode, unknown>>>>;
        ignoreErrors: z.ZodOptional<z.ZodArray<z.ZodType<StatusCode, unknown, z.core.$ZodTypeInternals<StatusCode, unknown>>>>;
    }, z.core.$strip>, z.ZodTransform<Record<string, any>, {
        maxAttempts?: number;
        handleErrors?: StatusCode[];
        ignoreErrors?: StatusCode[];
    }>>>>;
    fallbacks: z.ZodOptional<z.ZodArray<z.ZodPipe<z.ZodObject<{
        nodeId: z.ZodString;
        handleErrors: z.ZodOptional<z.ZodArray<z.ZodType<StatusCode, unknown, z.core.$ZodTypeInternals<StatusCode, unknown>>>>;
        ignoreErrors: z.ZodOptional<z.ZodArray<z.ZodType<StatusCode, unknown, z.core.$ZodTypeInternals<StatusCode, unknown>>>>;
        cooldown: z.ZodOptional<z.ZodPipe<z.ZodObject<{
            minConsecutiveFailures: z.ZodOptional<z.ZodNumber>;
            cooldownDuration: z.ZodOptional<z.ZodPipe<z.ZodUnion<readonly [z.ZodString, z.ZodNumber]>, z.ZodTransform<string, string | number>>>;
        }, z.core.$strip>, z.ZodTransform<Record<string, any>, {
            minConsecutiveFailures?: number;
            cooldownDuration?: string;
        }>>>;
    }, z.core.$strip>, z.ZodTransform<Record<string, any>, {
        nodeId: string;
        handleErrors?: StatusCode[];
        ignoreErrors?: StatusCode[];
        cooldown?: Record<string, any>;
    }>>>>;
    cooldown: z.ZodOptional<z.ZodPipe<z.ZodObject<{
        minConsecutiveFailures: z.ZodOptional<z.ZodNumber>;
        cooldownDuration: z.ZodOptional<z.ZodPipe<z.ZodUnion<readonly [z.ZodString, z.ZodNumber]>, z.ZodTransform<string, string | number>>>;
    }, z.core.$strip>, z.ZodTransform<Record<string, any>, {
        minConsecutiveFailures?: number;
        cooldownDuration?: string;
    }>>>;
}, z.core.$strip>, z.ZodTransform<Record<string, any>, {
    retries?: Record<string, any>[];
    fallbacks?: Record<string, any>[];
    cooldown?: Record<string, any>;
}>>;
export type ErrorHandlingConfig = z.infer<typeof NodeErrorConfigSchema>;
/**
 * Validates a retry configuration (snake_case version).
 *
 * @param {unknown} config - The configuration to validate
 * @returns {RetryConfig} The validated retry configuration
 * @throws {z.ZodError} If validation fails
 */
export declare function validateRetryConfig(config: unknown): RetryConfig;
/**
 * Validates a cooldown configuration (snake_case version).
 *
 * @param {unknown} config - The configuration to validate
 * @returns {CooldownConfig} The validated cooldown configuration
 * @throws {z.ZodError} If validation fails
 */
export declare function validateCooldownConfig(config: unknown): CooldownConfig;
/**
 * Validates a fallback configuration (snake_case version).
 *
 * @param {unknown} config - The configuration to validate
 * @returns {FallbackConfig} The validated fallback configuration
 * @throws {z.ZodError} If validation fails
 */
export declare function validateFallbackConfig(config: unknown): FallbackConfig;
/**
 * Validates a node error configuration (snake_case version).
 *
 * @param {unknown} config - The configuration to validate
 * @returns {NodeErrorConfig} The validated node error configuration
 * @throws {z.ZodError} If validation fails
 */
export declare function validateNodeErrorConfig(config: unknown): NodeErrorConfig;
export declare const toGraphConfig: (value: ErrorHandlingConfig) => Camelize<NodeErrorConfig>;
export {};
