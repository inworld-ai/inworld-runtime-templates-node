"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.toGraphConfig = exports.NodeErrorConfigSchema = exports.FallbackConfigSchema = exports.CooldownConfigSchema = exports.RetryConfigSchema = exports.DEFAULT_IGNORED_ERRORS = exports.ErrorStatusCode = exports.StatusCodeSchema = void 0;
exports.validateRetryConfig = validateRetryConfig;
exports.validateCooldownConfig = validateCooldownConfig;
exports.validateFallbackConfig = validateFallbackConfig;
exports.validateNodeErrorConfig = validateNodeErrorConfig;
const z = __importStar(require("zod"));
const duration_1 = require("../../common/data_types/duration");
const camelToSnake = (str) => str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
/**
 * Schema for error status codes with flexible input formats.
 *
 * Accepts PascalCase (e.g., 'Unavailable') or UPPERCASE (e.g., 'UNAVAILABLE') values.
 *
 * @type {z.ZodType<ErrorStatusCode>}
 *
 * @example
 * ```typescript
 * StatusCodeSchema.parse('Unavailable');  // Valid
 * StatusCodeSchema.parse('UNAVAILABLE');  // Also valid
 * ```
 */
exports.StatusCodeSchema = z
    .union([
    z.enum([
        'Ok',
        'Cancelled',
        'Unknown',
        'InvalidArgument',
        'DeadlineExceeded',
        'NotFound',
        'AlreadyExists',
        'PermissionDenied',
        'ResourceExhausted',
        'FailedPrecondition',
        'Aborted',
        'OutOfRange',
        'Unimplemented',
        'Internal',
        'Unavailable',
        'DataLoss',
        'Unauthenticated',
    ]),
    z.enum([
        'OK',
        'CANCELLED',
        'UNKNOWN',
        'INVALID_ARGUMENT',
        'DEADLINE_EXCEEDED',
        'NOT_FOUND',
        'ALREADY_EXISTS',
        'PERMISSION_DENIED',
        'RESOURCE_EXHAUSTED',
        'FAILED_PRECONDITION',
        'ABORTED',
        'OUT_OF_RANGE',
        'UNIMPLEMENTED',
        'INTERNAL',
        'UNAVAILABLE',
        'DATA_LOSS',
        'UNAUTHENTICATED',
    ]),
])
    .transform((val) => {
    const mapping = {
        Ok: 'OK',
        Cancelled: 'CANCELLED',
        Unknown: 'UNKNOWN',
        InvalidArgument: 'INVALID_ARGUMENT',
        DeadlineExceeded: 'DEADLINE_EXCEEDED',
        NotFound: 'NOT_FOUND',
        AlreadyExists: 'ALREADY_EXISTS',
        PermissionDenied: 'PERMISSION_DENIED',
        ResourceExhausted: 'RESOURCE_EXHAUSTED',
        FailedPrecondition: 'FAILED_PRECONDITION',
        Aborted: 'ABORTED',
        OutOfRange: 'OUT_OF_RANGE',
        Unimplemented: 'UNIMPLEMENTED',
        Internal: 'INTERNAL',
        Unavailable: 'UNAVAILABLE',
        DataLoss: 'DATA_LOSS',
        Unauthenticated: 'UNAUTHENTICATED',
    };
    return (mapping[val] || val);
});
var ErrorStatusCode;
(function (ErrorStatusCode) {
    ErrorStatusCode["Ok"] = "OK";
    ErrorStatusCode["Cancelled"] = "CANCELLED";
    ErrorStatusCode["Unknown"] = "UNKNOWN";
    ErrorStatusCode["InvalidArgument"] = "INVALID_ARGUMENT";
    ErrorStatusCode["DeadlineExceeded"] = "DEADLINE_EXCEEDED";
    ErrorStatusCode["NotFound"] = "NOT_FOUND";
    ErrorStatusCode["AlreadyExists"] = "ALREADY_EXISTS";
    ErrorStatusCode["PermissionDenied"] = "PERMISSION_DENIED";
    ErrorStatusCode["ResourceExhausted"] = "RESOURCE_EXHAUSTED";
    ErrorStatusCode["FailedPrecondition"] = "FAILED_PRECONDITION";
    ErrorStatusCode["Aborted"] = "ABORTED";
    ErrorStatusCode["OutOfRange"] = "OUT_OF_RANGE";
    ErrorStatusCode["Unimplemented"] = "UNIMPLEMENTED";
    ErrorStatusCode["Internal"] = "Internal";
    ErrorStatusCode["Unavailable"] = "UNAVAILABLE";
    ErrorStatusCode["DataLoss"] = "DATA_LOSS";
    ErrorStatusCode["Unauthenticated"] = "UNAUTHENTICATED";
})(ErrorStatusCode || (exports.ErrorStatusCode = ErrorStatusCode = {}));
/**
 * Default set of non-retryable error codes.
 * These errors are typically permanent and won't be fixed by retrying.
 */
exports.DEFAULT_IGNORED_ERRORS = [
    ErrorStatusCode.InvalidArgument,
    ErrorStatusCode.NotFound,
    ErrorStatusCode.PermissionDenied,
    ErrorStatusCode.Unauthenticated,
    ErrorStatusCode.FailedPrecondition,
    ErrorStatusCode.OutOfRange,
];
/**
 * Zod schema for retry configuration (snake_case version).
 * Retries are non-stateful and happen within a single execution.
 */
exports.RetryConfigSchema = z
    .object({
    /**
     * Maximum number of execution attempts (includes initial attempt).
     * For example, max_attempts=3 means 1 initial + 2 retries.
     * @default 1
     */
    maxAttempts: z.number().int().min(1).optional(),
    /**
     * Whitelist: only consider these specific error codes for retry.
     * If empty, all errors are considered (unless filtered by ignore_errors).
     * @default []
     */
    handleErrors: z.array(exports.StatusCodeSchema).optional(),
    /**
     * Blacklist: exclude these errors from retry.
     * Defaults to DEFAULT_IGNORED_ERRORS (typical non-retryable errors).
     * If explicitly set, it REPLACES the default (not appends).
     * Applied after handle_errors filter.
     * @default DEFAULT_IGNORED_ERRORS
     */
    ignoreErrors: z.array(exports.StatusCodeSchema).optional(),
})
    .transform((data) => {
    const transformed = {};
    for (const key in data) {
        transformed[camelToSnake(key)] = data[key];
    }
    return transformed;
});
/**
 * Zod schema for circuit breaker cooldown configuration (snake_case version).
 * Implements circuit breaker pattern to prevent repeated attempts on persistently failing nodes.
 */
exports.CooldownConfigSchema = z
    .object({
    /**
     * Number of consecutive failures before entering cooldown state.
     * @minimum 1
     */
    minConsecutiveFailures: z.number().int().min(1).optional(),
    /**
     * Duration to skip the node after entering cooldown (e.g., '10s', '1m').
     * After this period, the node enters "half-open" state and is tried once.
     */
    cooldownDuration: duration_1.DurationSchema.optional(),
})
    .transform((data) => {
    const transformed = {};
    for (const key in data) {
        transformed[camelToSnake(key)] = data[key];
    }
    return transformed;
});
/**
 * Zod schema for fallback configuration (snake_case version).
 * Fallbacks are stateful and persist across executions.
 */
exports.FallbackConfigSchema = z
    .object({
    /**
     * ID of the fallback node to route to when primary fails.
     */
    nodeId: z.string(),
    /**
     * Whitelist: only consider these specific error codes for fallback.
     * If empty, all errors are considered (unless filtered by ignore_errors).
     * @default []
     */
    handleErrors: z.array(exports.StatusCodeSchema).optional(),
    /**
     * Blacklist: exclude these errors from fallback.
     * Defaults to DEFAULT_IGNORED_ERRORS (typical non-retryable errors).
     * If explicitly set, it REPLACES the default (not appends).
     * Applied after handle_errors filter.
     */
    ignoreErrors: z.array(exports.StatusCodeSchema).optional(),
    /**
     * Optional per-fallback cooldown configuration.
     * If not specified, uses the common cooldown from NodeErrorConfig.
     */
    cooldown: exports.CooldownConfigSchema.optional(),
})
    .transform((data) => {
    const transformed = {};
    for (const key in data) {
        transformed[camelToSnake(key)] = data[key];
    }
    return transformed;
});
/**
 * Zod schema for comprehensive node error handling configuration (snake_case version).
 * Supports three-tier failure handling:
 * 1. Retries (non-stateful, per execution)
 * 2. Fallbacks (stateful, persist across executions)
 * 3. Circuit breaker (cooldown to skip failing nodes)
 */
exports.NodeErrorConfigSchema = z
    .object({
    /**
     * List of retry configurations, each targeting specific error codes.
     * Example: retry once for UNAVAILABLE, retry 3 times for RESOURCE_EXHAUSTED.
     * @default []
     */
    retries: z.array(exports.RetryConfigSchema).optional(),
    /**
     * Ordered list of fallback nodes to try when primary fails.
     * Fallbacks are stateful - health state persists in GraphManager.
     * Results are saved under the primary node ID for transparency.
     * @default []
     */
    fallbacks: z.array(exports.FallbackConfigSchema).optional(),
    /**
     * Common cooldown configuration applied to all fallbacks.
     * Individual fallbacks can override with their own cooldown config.
     */
    cooldown: exports.CooldownConfigSchema.optional(),
})
    .transform((data) => {
    const transformed = {};
    for (const key in data) {
        transformed[camelToSnake(key)] = data[key];
    }
    return transformed;
});
/**
 * Validates a retry configuration (snake_case version).
 *
 * @param {unknown} config - The configuration to validate
 * @returns {RetryConfig} The validated retry configuration
 * @throws {z.ZodError} If validation fails
 */
function validateRetryConfig(config) {
    return exports.RetryConfigSchema.parse(config);
}
/**
 * Validates a cooldown configuration (snake_case version).
 *
 * @param {unknown} config - The configuration to validate
 * @returns {CooldownConfig} The validated cooldown configuration
 * @throws {z.ZodError} If validation fails
 */
function validateCooldownConfig(config) {
    return exports.CooldownConfigSchema.parse(config);
}
/**
 * Validates a fallback configuration (snake_case version).
 *
 * @param {unknown} config - The configuration to validate
 * @returns {FallbackConfig} The validated fallback configuration
 * @throws {z.ZodError} If validation fails
 */
function validateFallbackConfig(config) {
    return exports.FallbackConfigSchema.parse(config);
}
/**
 * Validates a node error configuration (snake_case version).
 *
 * @param {unknown} config - The configuration to validate
 * @returns {NodeErrorConfig} The validated node error configuration
 * @throws {z.ZodError} If validation fails
 */
function validateNodeErrorConfig(config) {
    return exports.NodeErrorConfigSchema.parse(config);
}
const toGraphConfig = (value) => {
    return exports.NodeErrorConfigSchema.parse(value);
};
exports.toGraphConfig = toGraphConfig;
