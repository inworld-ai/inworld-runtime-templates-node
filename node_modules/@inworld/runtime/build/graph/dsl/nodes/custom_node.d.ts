import { CustomNodeInputTypes, CustomNodeOutputTypes } from '../../../common/data_types/type_mapping';
import { ProcessContext } from '../../nodes';
import { CustomNodeTypeReference } from '../../nodes/types';
import { Node as GraphConfigNode } from '../graph_config_schema';
import type { CustomNodeSchemaDefinition } from '../types/custom_node_schema';
import { AbstractNode, AbstractNodeProps } from './abstract_node';
/**
 * Configuration for a `CustomNode`.
 *
 * @remarks
 * If no `id` is provided, one will be auto-generated based on the class name.
 * The `reportToClient` flag defaults to `false`.
 *
 * @param executionConfig - Execution configuration for the custom node.
 */
export interface CustomNodeProps<ExecutionConfigType> extends AbstractNodeProps {
    /**
     * Execution configuration for the custom node.
     */
    executionConfig?: ExecutionConfigType;
}
/**
 * Base class for creating custom (user-defined) nodes.
 *
 * Subclasses must implement the `process` method. A unique node type is
 * automatically registered once per subclass.
 *
 * @example
 * ```typescript
 * import { CustomNode, ProcessContext } from '@inworld/runtime/graph';
 *
 * // Define a custom node that processes the input text
 * class CustomTextNode extends CustomNode {
 *   async process(
 *     context: ProcessContext,
 *     input: string,
 *   ): Promise<{ processedText: string }> {
 *     return {
 *       processedText: input.toUpperCase(),
 *     };
 *   }
 * }
 *
 * // Create an instance of the custom node
 * const customTextNode = new CustomTextNode();
 * ```
 */
export declare abstract class CustomNode<InputType = CustomNodeInputTypes, OutputType = CustomNodeOutputTypes, ExecutionConfigType = Record<string, any>> extends AbstractNode {
    private executionConfig?;
    protected static typeReferences: {
        [key: string]: CustomNodeTypeReference;
    };
    protected schema?: CustomNodeSchemaDefinition;
    /**
     * Override this method in subclasses to specify the output stream type
     * for generator-based process methods.
     * @returns The stream type (e.g., 'Audio', 'Text', 'BaseData')
     */
    protected static getStreamType(): string;
    /**
     * Creates a new `CustomNode`.
     *
     * @remarks
     * Subclasses can pass an `executionConfig` object to surface additional
     * execution-time properties. Execution config would be available to the
     * process function in the {@link ProcessContext}.
     *
     * @typeParam InputType - The type of the inputs to the node, should be one of {@link CustomNodeInputTypes} or any for custom processing.
     * @typeParam OutputType - The type of the outputs from the node, should be one of {@link CustomNodeOutputTypes} or any for custom processing.
     *
     * @param props - Custom node options including optional `executionConfig`.
     */
    constructor(props?: CustomNodeProps<ExecutionConfigType>);
    /**
     * The execution function of the custom node. Must be implemented by subclasses.
     *
     * @param context - The execution context.
     * @param inputs - The inputs to the node.
     * @returns The output of the node.
     */
    abstract process(context: ProcessContext, ...inputs: InputType[]): OutputType | Promise<OutputType>;
    /**
     * Converts this custom node to a graph configuration node, including the
     * registered type and the provided execution configuration.
     */
    protected toGraphConfigNode(): GraphConfigNode;
    protected getSchemaDefinition(): CustomNodeSchemaDefinition | undefined;
    private deferSchemaRegistration;
}
