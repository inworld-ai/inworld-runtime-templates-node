"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SafetyCheckerNode = void 0;
const abstract_node_1 = require("./abstract_node");
/**
 * Safety checker node for content moderation and safety analysis.
 * Analyzes text input for potentially harmful content across multiple topic categories
 * and returns safety assessment results.
 *
 * You can either use a pre-configured safety checker component that could be reused across
 * multiple nodes or node will create a new component for you.
 *
 * @input {String} {@link String} - The data type that SafetyCheckerNode accepts as input
 * @output {GraphTypes.SafetyResult} {@link GraphTypes.SafetyResult} - The data type that SafetyCheckerNode outputs
 *
 * @example
 * ```typescript
 * // Using component configuration
 * const safetyNode = new SafetyCheckerNode({
 *   id: 'content-safety-check',
 *   modelWeightsPath: '/models/safety_weights.json',
 *   safetyConfig: {
 *     forbiddenTopics: [
 *       { topicName: TopicName.Violence, threshold: 0.7 },
 *       { topicName: TopicName.Profanity, threshold: 0.8 }
 *     ]
 *   }
 * });
 *
 * // Using existing safety checker component
 * const safetyComponent = new SafetyCheckerComponent({
 *   id: 'existing-safety-component',
 *   modelWeightsPath: '/models/safety_weights.json'
 * });
 * const safetyNodeWithComponent = new SafetyCheckerNode({
 *   id: 'content-safety-check',
 *   safetyCheckerComponent: safetyComponent
 * });
 * ```
 */
class SafetyCheckerNode extends abstract_node_1.AbstractNode {
    /**
     * Creates a new SafetyCheckerNode instance.
     *
     * @remarks
     * The SafetyCheckerNode creates its own safety checker using the factory pattern
     * and doesn't need a separate SafetyCheckerComponent.
     *
     * @param props - Configuration for the safety checker node.
     */
    constructor(props) {
        // Only pass id and a boolean reportToClient to super
        super({
            id: props.id,
            reportToClient: typeof props.reportToClient === 'boolean'
                ? props.reportToClient
                : false,
        });
        this.safetyConfig = props.safetyConfig;
        this.errorHandling = props.errorHandling;
        // Extract model weights path and embedder component ID directly
        if ('safetyCheckerComponent' in props) {
            // If using existing component, we don't create our own safety checker
            this.addComponent(props.safetyCheckerComponent);
            this.modelWeightsPath = ''; // Will be handled by component
            this.embedderComponentId = '';
        }
        else {
            // Use direct configuration - no component needed
            this.modelWeightsPath = props.modelWeightsPath;
            this.embedderComponentId = props.embedderComponentId;
        }
    }
    /**
     * Converts the safety checker node to a graph configuration node.
     *
     * @returns The configured safety checker node for graph execution
     */
    toGraphConfigNode() {
        const node = {
            id: this.id,
            type: 'SafetyCheckerNode',
            creation_config: {
                type: 'SafetyCheckerNodeCreationConfig',
                properties: {
                    embedder_component_id: this.embedderComponentId || 'text_embedder_component',
                    safety_config: {
                        model_weights_path: this.modelWeightsPath,
                    },
                },
            },
            execution_config: {
                type: 'SafetyCheckerNodeExecutionConfig',
                properties: {
                    report_to_client: this.reportToClient,
                    safety_config: this.safetyConfig || { forbiddenTopics: [] },
                },
            },
        };
        // Add error_handling if provided
        if (this.errorHandling) {
            node.execution_config.properties.error_handling =
                this.errorHandling;
        }
        return node;
    }
}
exports.SafetyCheckerNode = SafetyCheckerNode;
