"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RemoteSTTNode = void 0;
const remote_stt_component_1 = require("../components/remote_stt_component");
const constants_1 = require("../constants");
const snakify_1 = __importDefault(require("../utils/snakify"));
const abstract_node_1 = require("./abstract_node");
/**
 * Remote STT (Speech-to-Text) node for audio transcription.
 * You can either use a pre-configured STT component that could be reused across multiple nodes
 * or provide STT configuration, and the node will create a new component for you.
 *
 * @input {GraphTypes.Audio} {@link GraphTypes.Audio} - The data type that STTNode accepts as input
 * @output {String} {@link String} - The data type that STTNode outputs
 *
 * @example
 * ```typescript
 * // Using provider configuration
 * const sttNode = new RemoteSTTNode({
 *   id: 'my-stt-node',
 *   sttConfig: { languageCode: 'en-US' },
 *   modelId: 'groq/whisper-large-v3'
 * });
 *
 * // Using existing STT component
 * const sttNodeWithComponent = new RemoteSTTNode({
 *   id: 'my-stt-node',
 *   sttComponent: existingSTTComponent
 * });
 * ```
 */
class RemoteSTTNode extends abstract_node_1.AbstractNode {
    /**
     * Creates a new RemoteSTTNode instance.
     *
     * @remarks
     * Provide STT settings to create a new internal component, or pass
     * `sttComponent` to reuse an existing one.
     *
     * @param props - Configuration for the STT node.
     */
    constructor(props) {
        var _a, _b;
        super(props !== null && props !== void 0 ? props : {});
        this.executionConfig = {
            sttComponentId: '',
            reportToClient: (_a = props === null || props === void 0 ? void 0 : props.reportToClient) !== null && _a !== void 0 ? _a : false,
        };
        let sttComponent;
        if (props && 'sttComponent' in props) {
            sttComponent = props.sttComponent;
        }
        else {
            const nodeProps = props;
            const input = (_b = nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps.sttConfig) !== null && _b !== void 0 ? _b : {};
            const merged = Object.assign(Object.assign({}, constants_1.DEFAULT_SPEECH_RECOGNITION_CONFIG), input);
            sttComponent = new remote_stt_component_1.RemoteSTTComponent({
                id: `${this.id}_stt_component`,
                sttConfig: merged,
                service: nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps.service,
                modelId: nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps.modelId,
            });
        }
        this.executionConfig.sttComponentId = sttComponent.id;
        this.addComponent(sttComponent);
    }
    /**
     * Converts the STT node to a graph configuration node.
     *
     * @returns The configured STT node for graph execution
     */
    toGraphConfigNode() {
        return {
            id: this.id,
            type: 'STTNode',
            execution_config: {
                type: 'STTNodeExecutionConfig',
                properties: (0, snakify_1.default)(this.executionConfig),
            },
        };
    }
}
exports.RemoteSTTNode = RemoteSTTNode;
