"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextChunkingNode = void 0;
const abstract_node_1 = require("./abstract_node");
/**
 * Text chunking node for breaking large text into smaller pieces (a stream of token chunks).
 * This node processes streaming text data and converts it into discrete text chunks.
 *
 * @input {GraphTypes.TextStream | GraphTypes.ContentStream} {@link GraphTypes.TextStream} | {@link GraphTypes.ContentStream} - The data type that TextChunkingNode accepts as input
 * @output {GraphTypes.TextStream} {@link GraphTypes.TextStream} - The data type that TextChunkingNode outputs
 *
 * @example
 * ```typescript
 * const chunkingNode = new TextChunkingNode({
 *   id: 'my-chunking-node',
 *   reportToClient: true,
 *   minChunkLength: 100
 * });
 * ```
 */
class TextChunkingNode extends abstract_node_1.AbstractNode {
    /**
     * Creates a new TextChunkingNode instance.
     *
     * @remarks
     * Accepts the common node options from {@link AbstractNodeProps} plus
     * minChunkLength for controlling chunk size. If omitted, sensible defaults
     * are applied.
     *
     * @param props - Configuration for the text chunking node.
     */
    constructor(props = {}) {
        super(props);
        this.minChunkLength = props.minChunkLength;
    }
    /**
     * Converts the text chunking node to a graph configuration node.
     *
     * @returns The configured text chunking node for graph execution
     */
    toGraphConfigNode() {
        const properties = {
            report_to_client: this.reportToClient,
        };
        if (this.minChunkLength !== undefined) {
            properties.min_chunk_length = this.minChunkLength;
        }
        return {
            id: this.id,
            type: 'TextChunkingNode',
            execution_config: {
                type: 'TextChunkingNodeExecutionConfig',
                properties,
            },
        };
    }
}
exports.TextChunkingNode = TextChunkingNode;
