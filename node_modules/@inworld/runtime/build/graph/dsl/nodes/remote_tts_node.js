"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RemoteTTSNode = void 0;
const remote_tts_component_1 = require("../components/remote_tts_component");
const constants_1 = require("../constants");
const snakify_1 = __importDefault(require("../utils/snakify"));
const abstract_node_1 = require("./abstract_node");
/**
 * Remote TTS (Text-to-Speech) node for audio synthesis.
 * You can either use a pre-configured TTS component that could be reused across multiple nodes
 * or provide synthesis configuration, and the node will create a new component for you.
 *
 * @input {String | GraphTypes.TextStream | GraphTypes.TTSRequest} {@link String} | {@link GraphTypes.TextStream} | {@link GraphTypes.TTSRequest} - The data type that TTSNode accepts as input
 * @output {GraphTypes.TTSOutputStream} {@link GraphTypes.TTSOutputStream} - The data type that TTSNode outputs
 *
 * @example
 * ```typescript
 * // Using provider configuration
 * const ttsNode = new RemoteTTSNode({
 *   modelId: 'inworld-voice-v1',
 *   temperature: 1.0,
 *   speakingRate: 1.1,
 *   sampleRate: 22050
 * });
 *
 * // Using existing TTS component
 * const ttsNodeWithComponent = new RemoteTTSNode({
 *   ttsComponent: existingTTSComponent
 * });
 * ```
 */
class RemoteTTSNode extends abstract_node_1.AbstractNode {
    mergeSynthesisConfigWithDefault(input) {
        var _a;
        return {
            type: 'inworld',
            config: {
                modelId: (_a = input === null || input === void 0 ? void 0 : input.modelId) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_SPEECH_SYNTHESIS_CONFIG.inworldConfig.modelId,
                inference: Object.assign(Object.assign(Object.assign({}, constants_1.DEFAULT_SPEECH_SYNTHESIS_CONFIG.inworldConfig.inference), ((input === null || input === void 0 ? void 0 : input.temperature) ? { temperature: input.temperature } : {})), ((input === null || input === void 0 ? void 0 : input.speakingRate) ? { speakingRate: input.speakingRate } : {})),
                postprocessing: Object.assign(Object.assign({}, constants_1.DEFAULT_SPEECH_SYNTHESIS_CONFIG.inworldConfig.postprocessing), ((input === null || input === void 0 ? void 0 : input.sampleRate) ? { sampleRate: input.sampleRate } : {})),
            },
        };
    }
    /**
     * Creates a new RemoteTTSNode instance.
     *
     * @remarks
     * Provide synthesis settings to create a new internal component, or pass
     * `ttsComponent` to reuse an existing one. When omitted, defaults will be
     * applied.
     *
     * @param props - Configuration for the TTS node.
     */
    constructor(props) {
        var _a, _b, _c;
        super(props !== null && props !== void 0 ? props : {});
        this.executionConfig = {
            ttsComponentId: '',
            voice: {
                id: (_a = props === null || props === void 0 ? void 0 : props.speakerId) !== null && _a !== void 0 ? _a : constants_1.DEFAULT_TTS_VOICE.id,
                languageCode: (_b = props === null || props === void 0 ? void 0 : props.languageCode) !== null && _b !== void 0 ? _b : constants_1.DEFAULT_TTS_VOICE.language_code,
            },
            synthesisConfig: this.mergeSynthesisConfigWithDefault(props),
            reportToClient: (_c = props === null || props === void 0 ? void 0 : props.reportToClient) !== null && _c !== void 0 ? _c : false,
        };
        let ttsComponent;
        if (props && 'ttsComponent' in props && props.ttsComponent) {
            // Use the provided component (could be RemoteTTSComponent, FakeTTSComponent, etc.)
            ttsComponent = props.ttsComponent;
        }
        else {
            // Create a new RemoteTTSComponent by default
            ttsComponent = new remote_tts_component_1.RemoteTTSComponent({
                id: `${this.id}_tts_component`,
                synthesisConfig: this.mergeSynthesisConfigWithDefault(props),
            });
        }
        this.executionConfig.ttsComponentId = ttsComponent.id;
        this.addComponent(ttsComponent);
    }
    /**
     * Converts the TTS node to a graph configuration node.
     *
     * @returns The configured TTS node for graph execution
     */
    toGraphConfigNode() {
        return {
            id: this.id,
            type: 'TTSNode',
            execution_config: {
                type: 'TTSNodeExecutionConfig',
                properties: (0, snakify_1.default)(this.executionConfig),
            },
        };
    }
}
exports.RemoteTTSNode = RemoteTTSNode;
