import { Graph } from '../graph';
import { EdgeConditionCallback } from '../nodes/custom/types';
import { CustomEdgeConditionReference } from '../nodes/types';
import { AbstractComponent } from './components/abstract_component';
import { MCPClientComponent } from './components/mcp_client_component';
import { RemoteEmbedderComponent } from './components/remote_embedder_component';
import { RemoteLLMComponent } from './components/remote_llm_component';
import { Camelize } from './constants';
import { Component, Node, TextGenerationConfig } from './graph_config_schema';
import { AbstractNode } from './nodes/abstract_node';
import { SubgraphBuilder } from './subgraph_builder';
export type MCPSubgraphProps = {
    llmComponent: RemoteLLMComponent;
    mcpComponents: MCPClientComponent[];
    systemPrompt?: string;
    textGenerationConfig?: Camelize<TextGenerationConfig>;
    enableDirectResponse?: boolean;
};
export type IntentSubgraphProps = {
    intents: {
        name: string;
        phrases: string[];
    }[];
    promptTemplate: string;
    llmComponent?: RemoteLLMComponent | {
        provider?: string;
        modelName?: string;
        defaultConfig?: Camelize<TextGenerationConfig>;
    };
    embedderComponent?: RemoteEmbedderComponent | {
        provider?: string;
        modelName?: string;
    };
    similarityThreshold?: number;
    textGenerationConfig?: Camelize<TextGenerationConfig>;
    maxIntentsForLLM?: number;
    maxPhrasesPerIntent?: number;
    embeddingSimilarityThreshold?: number;
    topNIntents?: number;
};
/**
 * Tool choice configuration for LLM chat request builder.
 * Can specify either a string type or a function with a name.
 *
 * For string values: "none", "auto", "required":
 *  - "none": the model will not call any tool and instead generates a message
 *  - "auto": the model can pick between generating a message or calling tools
 *  - "required": The model must call one or more tools
 * And function specifies a particular tool the model should use
 */
export type RequestBuilderToolChoice = {
    type?: 'string';
    [k: string]: unknown;
} | {
    type?: 'function';
    function: {
        type: 'function';
        name: string;
    };
};
/**
 * Represents the properties required to initialize and configure a graph builder.
 */
export type GraphBuilderProps = {
    /**
     * A unique identifier for the graph instance. This field is required.
     */
    id: string;
    /**
     * An optional Inworld API key. In order for Remote nodes to work, you need to pass it here or via environment variable INWORLD_API_KEY.
     * @defaultValue Process environment variable `INWORLD_API_KEY`
     */
    apiKey?: string;
    /**
     * @deprecated use initTelemetry instead
     * An optional name of the application utilizing the graph builder. Used in observability reporting.
     */
    appName?: string;
    /**
     * @deprecated use initTelemetry instead
     * An optional version of the application utilizing the graph builder. Used in observability reporting.
     */
    appVersion?: string;
    /**
     * An optional flag to enable remote config, which allows one-click experiment deployment from Inworld portal.
     * @defaultValue `false`
     */
    enableRemoteConfig?: boolean;
    /**
     * Optional substitutions applied when compiling the graph.
     */
    substitutions?: Record<string, string>;
};
/**
 * Main graph builder class for creating complete graph configurations.
 * Provides a fluent API for building graphs with nodes, edges, components, and subgraphs.
 *
 * @example
 * ```typescript
 * const graph = new Graph('my_graph')
 *   .addComponent(llmComponent)
 *   .addComponent(embedderComponent)
 *   .addNode(intentNode)
 *   .addNode(llmNode)
 *   .addEdge(intentNode, llmNode)
 *   .setStartNode(intentNode)
 *   .setEndNode(llmNode)
 *   .build();
 * ```
 */
export declare class GraphBuilder {
    protected nodes: Node[];
    protected startNodes: string[];
    protected endNodes: string[];
    private enableRemoteConfig;
    private config;
    private edges;
    private components;
    private subgraphs;
    private apiKey;
    private substitutions?;
    /**
     * Creates a new graph builder.
     * Accepts either an options object or a graph ID string.
     *
     * @constructor
     * @param {GraphBuilderProps | string} opts - Graph builder options or graph ID string
     */
    constructor(opts: GraphBuilderProps | string);
    /**
     * Adds a subgraph to the graph configuration.
     *
     * @param {SubgraphBuilder} subgraph - Subgraph builder instance to be added
     * @returns {GraphBuilder} The graph instance for method chaining
     */
    addSubgraph(subgraph: SubgraphBuilder): this;
    /**
     * Adds an intent subgraph to the graph.
     * @param {string} id - Unique identifier for the subgraph
     * @param {Object} parameters - Intent subgraph parameters
     * @param {Array} parameters.intents - Array of intent configurations
     * @param {string} parameters.promptTemplate - Template for LLM prompting
     * @param {RemoteLLMComponent|Object} [parameters.llmComponent] - LLM component instance or configuration
     * @param {RemoteEmbedderComponent|Object} [parameters.embedderComponent] - Embedder component instance or configuration
     * @param {number} [parameters.similarityThreshold] - Similarity threshold for matching
     * @param {TextGenerationConfig} [parameters.textGenerationConfig] - Text generation configuration
     * @param {number} [parameters.maxIntentsForLLM] - Maximum intents to send to LLM
     * @param {number} [parameters.maxPhrasesPerIntent] - Maximum phrases per intent
     * @param {number} [parameters.embeddingSimilarityThreshold] - Embedding similarity threshold
     * @param {number} [parameters.topNIntents] - Number of top intents to return
     * @returns {GraphBuilder} The graph instance for method chaining
     */
    addIntentSubgraph(id: string, parameters: IntentSubgraphProps): this;
    /**
     * Adds a node to the graph.
     * If an {@link AbstractNode} is provided without corresponding component, internal components are automatically added.
     *
     * @param {AbstractNode} node - Node to add to the graph
     * @returns {GraphBuilder} The graph instance for method chaining
     */
    addNode(node: Node | AbstractNode): this;
    private addClassNode;
    /**
     * Adds an edge connecting two nodes in the graph.
     *
     * @param {AbstractNode} fromNode - Source node
     * @param {AbstractNode} toNode - Destination node
     * @param {Object} [options] - Optional edge configuration
     * @param {string} [options.conditionExpression] - CEL expression for conditional execution
     * @param {CustomEdgeConditionReference|EdgeConditionCallback} [options.condition] - Reference to a registered custom condition or a callback to register one
     * @param {boolean} [options.optional] - Whether the edge is optional
     * @param {boolean} [options.loop] - Whether the edge creates a loop
     *
     * @returns {GraphBuilder} The builder instance for method chaining
     */
    addEdge(fromNode: AbstractNode | Node | string, toNode: AbstractNode | Node | string, options?: {
        conditionExpression?: string;
        condition?: CustomEdgeConditionReference | EdgeConditionCallback;
        optional?: boolean;
        loop?: boolean;
    }): this;
    /**
     * Adds a component to the graph configuration.
     *
     * @param {AbstractComponent} component - Component to add to the graph
     * @returns {GraphBuilder} The graph instance for method chaining
     */
    addComponent(component: Component | AbstractComponent): this;
    /**
     * Sets the start node of the graph.
     *
     * @param {AbstractNode} node - Start node
     * @returns {GraphBuilder} The graph instance for method chaining
     */
    setStartNode(node: Node | string | AbstractNode): this;
    /**
     * Sets the end node of the graph.
     *
     * @param {AbstractNode} node - End node
     * @returns {GraphBuilder} The graph instance for method chaining
     */
    setEndNode(node: Node | string | AbstractNode): this;
    /**
     * Sets multiple start nodes for the graph.
     *
     * @param {Array<AbstractNode>} nodes - Array of start nodes
     * @returns {GraphBuilder} The graph instance for method chaining
     */
    setStartNodes(nodes: (Node | string | AbstractNode)[]): this;
    /**
     * Sets multiple end nodes for the graph.
     *
     * @param {Array<AbstractNode>} nodes - Array of end nodes
     * @returns {GraphBuilder} The graph instance for method chaining
     */
    setEndNodes(nodes: (Node | string | AbstractNode)[]): this;
    /**
     * Adds an MCP subgraph to the graph.
     * @param {string} id - Unique identifier for the subgraph
     * @param {Object} parameters - MCP subgraph parameters
     * @param {RemoteLLMComponent} parameters.llmComponent - LLM component instance
     * @param {MCPClientComponent[]} parameters.mcpComponents - Array of MCP client component instances
     * @param {string} [parameters.systemPrompt] - System prompt for the LLM
     * @param {TextGenerationConfig} [parameters.textGenerationConfig] - Text generation configuration
     * @param {boolean} [parameters.enableDirectResponse] - Whether to enable direct responses
     * @returns {GraphBuilder} The graph instance for method chaining
     */
    addMCPSubgraph(id: string, parameters: MCPSubgraphProps): this;
    private getSchema;
    /**
     * Converts the graph configuration to a JSON string.
     *
     * @returns {string} JSON string representation of the graph configuration
     */
    private toJSON;
    /**
     * Creates a graph executor instance for running the graph.
     *
     * @returns {Graph} GraphExecutor instance configured with this graph
     */
    build(): Graph;
}
