"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GraphBuilder = void 0;
const graph_1 = require("../graph");
const nodes_1 = require("../nodes");
const intent_subgraph_1 = require("./builtin/intent_subgraph");
const mcp_subgraph_1 = require("./builtin/mcp_subgraph");
const abstract_component_1 = require("./components/abstract_component");
const remote_embedder_component_1 = require("./components/remote_embedder_component");
const remote_llm_component_1 = require("./components/remote_llm_component");
const abstract_node_1 = require("./nodes/abstract_node");
const snakify_1 = __importDefault(require("./utils/snakify"));
const API_KEY_SUBSTITUTION_KEY = '{{INWORLD_API_KEY}}';
/**
 * Main graph builder class for creating complete graph configurations.
 * Provides a fluent API for building graphs with nodes, edges, components, and subgraphs.
 *
 * @example
 * ```typescript
 * const graph = new Graph('my_graph')
 *   .addComponent(llmComponent)
 *   .addComponent(embedderComponent)
 *   .addNode(intentNode)
 *   .addNode(llmNode)
 *   .addEdge(intentNode, llmNode)
 *   .setStartNode(intentNode)
 *   .setEndNode(llmNode)
 *   .build();
 * ```
 */
class GraphBuilder {
    /**
     * Creates a new graph builder.
     * Accepts either an options object or a graph ID string.
     *
     * @constructor
     * @param {GraphBuilderProps | string} opts - Graph builder options or graph ID string
     */
    constructor(opts) {
        var _a, _b;
        this.nodes = [];
        this.startNodes = [];
        this.endNodes = [];
        this.enableRemoteConfig = false;
        this.edges = [];
        this.components = [];
        this.subgraphs = [];
        if (typeof opts === 'string') {
            opts = { id: opts };
        }
        this.apiKey = (_a = opts.apiKey) !== null && _a !== void 0 ? _a : process.env.INWORLD_API_KEY;
        this.enableRemoteConfig = (_b = opts.enableRemoteConfig) !== null && _b !== void 0 ? _b : false;
        this.substitutions = opts.substitutions;
        this.config = {
            schema_version: '1.2.3',
            main: {
                id: opts.id,
                nodes: [],
                edges: [],
                end_nodes: [],
            },
        };
    }
    /**
     * Adds a subgraph to the graph configuration.
     *
     * @param {SubgraphBuilder} subgraph - Subgraph builder instance to be added
     * @returns {GraphBuilder} The graph instance for method chaining
     */
    addSubgraph(subgraph) {
        const finalSubgraph = subgraph.build();
        this.subgraphs.push(finalSubgraph);
        for (const component of subgraph[abstract_node_1.INTERNAL_COMPONENTS]) {
            this.addComponent(component);
        }
        return this;
    }
    /**
     * Adds an intent subgraph to the graph.
     * @param {string} id - Unique identifier for the subgraph
     * @param {Object} parameters - Intent subgraph parameters
     * @param {Array} parameters.intents - Array of intent configurations
     * @param {string} parameters.promptTemplate - Template for LLM prompting
     * @param {RemoteLLMComponent|Object} [parameters.llmComponent] - LLM component instance or configuration
     * @param {RemoteEmbedderComponent|Object} [parameters.embedderComponent] - Embedder component instance or configuration
     * @param {number} [parameters.similarityThreshold] - Similarity threshold for matching
     * @param {TextGenerationConfig} [parameters.textGenerationConfig] - Text generation configuration
     * @param {number} [parameters.maxIntentsForLLM] - Maximum intents to send to LLM
     * @param {number} [parameters.maxPhrasesPerIntent] - Maximum phrases per intent
     * @param {number} [parameters.embeddingSimilarityThreshold] - Embedding similarity threshold
     * @param {number} [parameters.topNIntents] - Number of top intents to return
     * @returns {GraphBuilder} The graph instance for method chaining
     */
    addIntentSubgraph(id, parameters) {
        // Handle LLM component - either use provided instance or create new one
        let llmComponentId;
        if (parameters.llmComponent instanceof remote_llm_component_1.RemoteLLMComponent) {
            // Use existing component instance
            this.addComponent(parameters.llmComponent);
            llmComponentId = parameters.llmComponent.id;
        }
        else if (parameters.llmComponent) {
            // Create new component from configuration
            llmComponentId = `${id}_subgraph_llm_component`;
            const llmComponent = new remote_llm_component_1.RemoteLLMComponent(Object.assign({ id: llmComponentId }, parameters.llmComponent));
            this.addComponent(llmComponent);
        }
        else {
            // Use default configuration
            llmComponentId = `${id}_default_llm_component`;
            const llmComponent = new remote_llm_component_1.RemoteLLMComponent({
                id: llmComponentId,
            });
            this.addComponent(llmComponent);
        }
        // Handle Embedder component - either use provided instance or create new one
        let embedderComponentId;
        if (parameters.embedderComponent instanceof remote_embedder_component_1.RemoteEmbedderComponent) {
            // Use existing component instance
            this.addComponent(parameters.embedderComponent);
            embedderComponentId = parameters.embedderComponent.id;
        }
        else if (parameters.embedderComponent) {
            // Create new component from configuration
            embedderComponentId = `${id}_embedder_component`;
            const embedderComponent = new remote_embedder_component_1.RemoteEmbedderComponent(Object.assign({ id: embedderComponentId }, parameters.embedderComponent));
            this.addComponent(embedderComponent);
        }
        else {
            // Use default configuration
            embedderComponentId = `${id}_default_embedder_component`;
            const embedderComponent = new remote_embedder_component_1.RemoteEmbedderComponent({
                id: embedderComponentId,
            });
            this.addComponent(embedderComponent);
        }
        const subgraph = (0, intent_subgraph_1.intentSubgraph)(Object.assign(Object.assign({}, parameters), { textGenerationConfig: (0, snakify_1.default)(parameters.textGenerationConfig), embedderComponentId,
            llmComponentId }));
        subgraph.id = id;
        this.subgraphs.push(subgraph);
        return this;
    }
    /**
     * Adds a node to the graph.
     * If an {@link AbstractNode} is provided without corresponding component, internal components are automatically added.
     *
     * @param {AbstractNode} node - Node to add to the graph
     * @returns {GraphBuilder} The graph instance for method chaining
     */
    addNode(node) {
        if (node instanceof abstract_node_1.AbstractNode) {
            return this.addClassNode(node);
        }
        this.nodes.push(node);
        return this;
    }
    addClassNode(node) {
        const graphConfigNode = node[abstract_node_1.TO_GRAPH_CONFIG_NODE]();
        const components = node[abstract_node_1.INTERNAL_COMPONENTS];
        components.forEach((component) => {
            const graphConfigComponent = component[abstract_component_1.TO_GRAPH_CONFIG_COMPONENT]();
            this.addComponent(graphConfigComponent);
        });
        this.nodes.push(graphConfigNode);
        return this;
    }
    /**
     * Adds an edge connecting two nodes in the graph.
     *
     * @param {AbstractNode} fromNode - Source node
     * @param {AbstractNode} toNode - Destination node
     * @param {Object} [options] - Optional edge configuration
     * @param {string} [options.conditionExpression] - CEL expression for conditional execution
     * @param {CustomEdgeConditionReference|EdgeConditionCallback} [options.condition] - Reference to a registered custom condition or a callback to register one
     * @param {boolean} [options.optional] - Whether the edge is optional
     * @param {boolean} [options.loop] - Whether the edge creates a loop
     *
     * @returns {GraphBuilder} The builder instance for method chaining
     */
    addEdge(fromNode, toNode, options) {
        const fromId = typeof fromNode === 'string' ? fromNode : fromNode.id;
        const toId = typeof toNode === 'string' ? toNode : toNode.id;
        const edge = {
            from_node: fromId,
            to_node: toId,
        };
        if (options === null || options === void 0 ? void 0 : options.conditionExpression) {
            edge.condition_expression = options.conditionExpression;
        }
        else if (options === null || options === void 0 ? void 0 : options.condition) {
            if ('id' in options.condition) {
                edge.condition_id = options.condition.id;
            }
            else {
                const id = (0, nodes_1.registerCustomEdgeCondition)(`custom-condition-from-${fromId}-to-${toId}`, options.condition).id;
                this.addComponent({
                    id,
                    type: id,
                });
                edge.condition_id = id;
            }
        }
        if ((options === null || options === void 0 ? void 0 : options.optional) !== undefined) {
            edge.optional = options.optional;
        }
        if ((options === null || options === void 0 ? void 0 : options.loop) !== undefined) {
            edge.loop = options.loop;
        }
        this.edges.push(edge);
        return this;
    }
    /**
     * Adds a component to the graph configuration.
     *
     * @param {AbstractComponent} component - Component to add to the graph
     * @returns {GraphBuilder} The graph instance for method chaining
     */
    addComponent(component) {
        var _a, _b, _c;
        if (component instanceof abstract_component_1.AbstractComponent) {
            component = component[abstract_component_1.TO_GRAPH_CONFIG_COMPONENT]();
        }
        // MCPClientInterface does not require an API key
        if (component.type !== 'MCPClientInterface' &&
            !component.type.startsWith('custom-condition-')) {
            const creationConfigType = (_b = (_a = component.creation_config) === null || _a === void 0 ? void 0 : _a.type) !== null && _b !== void 0 ? _b : '';
            const creationProps = (_c = component.creation_config) === null || _c === void 0 ? void 0 : _c.properties;
            // Allow callers to explicitly opt out of automatic API key injection.
            // This is useful for:
            // - Local components (which do not require API keys)
            // - Components with non-INWORLD API keys (e.g. GROQ) or custom placeholders
            if ((creationProps === null || creationProps === void 0 ? void 0 : creationProps.__skip_api_key_injection) === true) {
                // no-op
            }
            else if (creationConfigType.startsWith('Local')) {
                // Local components do not require API keys.
                // Keep config identical to blueprints and avoid polluting local config with api_key.
            }
            else {
                // For STTInterface, the API key may be nested inside the `config` object.
                if (component.type === 'STTInterface') {
                    const config = creationProps === null || creationProps === void 0 ? void 0 : creationProps.config;
                    const hasNestedApiKey = config && Object.prototype.hasOwnProperty.call(config, 'api_key');
                    const hasTopLevelApiKey = creationProps &&
                        Object.prototype.hasOwnProperty.call(creationProps, 'api_key');
                    // Only inject if neither nested nor top-level api_key is explicitly set.
                    if (!hasNestedApiKey && !hasTopLevelApiKey) {
                        if (config) {
                            config['api_key'] = API_KEY_SUBSTITUTION_KEY;
                        }
                        else {
                            creationProps['api_key'] = API_KEY_SUBSTITUTION_KEY;
                        }
                    }
                }
                else {
                    const hasApiKey = creationProps &&
                        Object.prototype.hasOwnProperty.call(creationProps, 'api_key');
                    if (!hasApiKey) {
                        creationProps['api_key'] = API_KEY_SUBSTITUTION_KEY;
                    }
                }
            }
        }
        this.components.push(component);
        return this;
    }
    /**
     * Sets the start node of the graph.
     *
     * @param {AbstractNode} node - Start node
     * @returns {GraphBuilder} The graph instance for method chaining
     */
    setStartNode(node) {
        const nodeId = typeof node === 'string' ? node : node.id;
        this.startNodes = [nodeId];
        return this;
    }
    /**
     * Sets the end node of the graph.
     *
     * @param {AbstractNode} node - End node
     * @returns {GraphBuilder} The graph instance for method chaining
     */
    setEndNode(node) {
        const nodeId = typeof node === 'string' ? node : node.id;
        this.endNodes = [nodeId];
        return this;
    }
    /**
     * Sets multiple start nodes for the graph.
     *
     * @param {Array<AbstractNode>} nodes - Array of start nodes
     * @returns {GraphBuilder} The graph instance for method chaining
     */
    setStartNodes(nodes) {
        this.startNodes = nodes.map((n) => (typeof n === 'string' ? n : n.id));
        return this;
    }
    /**
     * Sets multiple end nodes for the graph.
     *
     * @param {Array<AbstractNode>} nodes - Array of end nodes
     * @returns {GraphBuilder} The graph instance for method chaining
     */
    setEndNodes(nodes) {
        this.endNodes = nodes.map((n) => (typeof n === 'string' ? n : n.id));
        return this;
    }
    /**
     * Adds an MCP subgraph to the graph.
     * @param {string} id - Unique identifier for the subgraph
     * @param {Object} parameters - MCP subgraph parameters
     * @param {RemoteLLMComponent} parameters.llmComponent - LLM component instance
     * @param {MCPClientComponent[]} parameters.mcpComponents - Array of MCP client component instances
     * @param {string} [parameters.systemPrompt] - System prompt for the LLM
     * @param {TextGenerationConfig} [parameters.textGenerationConfig] - Text generation configuration
     * @param {boolean} [parameters.enableDirectResponse] - Whether to enable direct responses
     * @returns {GraphBuilder} The graph instance for method chaining
     */
    addMCPSubgraph(id, parameters) {
        // Add the LLM component
        this.addComponent(parameters.llmComponent);
        // Add MCP client components
        for (const mcpComponent of parameters.mcpComponents) {
            this.addComponent(mcpComponent);
        }
        const subgraphBuilder = (0, mcp_subgraph_1.mcpSubgraph)(Object.assign(Object.assign({}, parameters), { textGenerationConfig: (0, snakify_1.default)(parameters.textGenerationConfig) }));
        this.addSubgraph(subgraphBuilder);
        return this;
    }
    getSchema() {
        this.config.main.nodes = this.nodes;
        this.config.main.edges = this.edges;
        this.config.main.start_nodes =
            this.startNodes.length > 0
                ? this.startNodes
                : undefined;
        this.config.main.end_nodes = this.endNodes;
        if (this.components.length > 0) {
            this.config.components = this.components;
        }
        if (this.subgraphs.length > 0) {
            this.config.subgraphs = this.subgraphs;
        }
        return this.config;
    }
    /**
     * Converts the graph configuration to a JSON string.
     *
     * @returns {string} JSON string representation of the graph configuration
     */
    toJSON() {
        return JSON.stringify(this.getSchema(), null, 2);
    }
    /**
     * Creates a graph executor instance for running the graph.
     *
     * @returns {Graph} GraphExecutor instance configured with this graph
     */
    build() {
        return new graph_1.Graph({
            jsonConfig: this.toJSON(),
            enableRemoteConfig: this.enableRemoteConfig,
            apiKey: this.apiKey,
            substitutions: this.substitutions,
        });
    }
}
exports.GraphBuilder = GraphBuilder;
