import { LocalTextEmbedderConfig as LocalConfigClass, RemoteTextEmbedderConfig as RemoteConfigClass, TextEmbedderCreationConfig } from '../common/api/library';
import { PbBaseType, PbStreamBaseType } from './pb_types';
export type RuntimeInputStream<TStream = any> = AsyncIterator<TStream> & {
    type: string;
    abort: () => void;
    getMetadata: () => Record<string, any>;
};
/**
 * Base interface for all tagged data types
 */
interface TaggedTypeBase<TType extends string, TData> {
    type: TType;
    data: TData;
}
/**
 * Base interface for streaming tagged data types
 * Includes the _stream field that contains the actual stream implementation
 */
export interface StreamingTaggedTypeBase<TType extends string, TData, TStream> {
    type: TType;
    data?: TData;
    _stream: RuntimeInputStream<TStream>;
}
export interface StreamableTaggedType {
    type: string;
    _stream: RuntimeInputStream<any>;
}
/**
 * Core NAPI data types from C++ bindings (data_types.def)
 */
type CoreNapiTypes = 'Text' | 'Audio' | 'Json' | 'Error' | 'LLMChatRequest' | 'LLMChatResponse' | 'LLMCompletionResponse' | 'ToolCallRequest' | 'ToolCallResult' | 'ToolCallResponse' | 'ListToolsResponse' | 'SafetyResult' | 'MatchedKeywords' | 'MatchedIntents' | 'ClassificationResult' | 'KnowledgeRecords' | 'GoalAdvancement';
/**
 * Additional Node.js API specific types (may not have C++ counterparts yet)
 */
type NodeJsApiTypes = 'TTSRequest' | 'MemoryState' | 'Content';
/**
 * All supported tagged value types
 */
type AllTaggedTypes = CoreNapiTypes | NodeJsApiTypes;
/**
 * Specific tagged type implementations
 */
type TaggedAudioData = {
    data: Float32Array;
    sampleRate: number;
};
type TaggedTextData = {
    text: string;
};
type TaggedJsonData = {
    value: Record<string, any> | string;
};
type TaggedErrorData = {
    message: string;
    code: number;
};
type TaggedContentData = {
    content: string;
    toolCalls?: any[];
};
/**
 * Streaming data variants - contain stream metadata in data field
 */
type StreamingLLMChatResponseData = {
    stream: true;
    [key: string]: any;
};
type StreamingTTSRequestData = {
    stream: true;
    voice?: any;
    [key: string]: any;
};
type StreamingContentData = {
    stream: true;
    [key: string]: any;
};
/**
 * Comprehensive TaggedType that supports both regular and streaming variants.
 * This type represents all possible data types that can be passed through the NAPI boundary.
 *
 * Streaming variants include a _stream field containing the actual stream implementation.
 */
export type TaggedType = TaggedTypeBase<'Audio', TaggedAudioData> | TaggedTypeBase<'Text', TaggedTextData> | TaggedTypeBase<'Json', TaggedJsonData> | TaggedTypeBase<'Error', TaggedErrorData> | TaggedTypeBase<'Content', TaggedContentData> | StreamingTaggedTypeBase<'LLMChatResponse', StreamingLLMChatResponseData, any> | StreamingTaggedTypeBase<'TTSRequest', StreamingTTSRequestData, any> | StreamingTaggedTypeBase<'ContentStream', StreamingContentData, any> | StreamingTaggedTypeBase<'TextStream', any, any> | StreamingTaggedTypeBase<'TTSOutputStream', any, any> | StreamingTaggedTypeBase<'SpeechChunkStream', any, any> | StreamingTaggedTypeBase<'AudioChunkStream', any, any> | StreamingTaggedTypeBase<'DataStreamWithMetadata', {
    metadata: Record<string, any>;
}, any> | TaggedTypeBase<'LLMChatResponse', any> | TaggedTypeBase<'TTSRequest', any> | TaggedTypeBase<Exclude<AllTaggedTypes, 'Audio' | 'Text' | 'Json' | 'Error' | 'Content' | 'LLMChatResponse' | 'TTSRequest'>, any> | TaggedTypeBase<string, any> | PbBaseType | PbStreamBaseType;
/**
 * Type guard to check if a TaggedType has a stream field
 */
export declare function isStreamingTaggedType(value: TaggedType): value is TaggedType & {
    _stream: RuntimeInputStream;
};
/**
 * Type guard to check if a TaggedType has streaming data
 */
export declare function hasStreamingData(value: TaggedType): value is TaggedType & {
    data: {
        stream: true;
    };
};
/**
 * Utility type to extract the stream type from a streaming TaggedType
 */
export type ExtractStreamType<T> = T extends StreamingTaggedTypeBase<any, any, infer S> ? S : never;
/**
 * Utility type to check if a TaggedType is a streaming variant
 */
export type IsStreaming<T> = T extends StreamingTaggedTypeBase<any, any, any> ? true : false;
export type JsUserContext = {
    attributes: Record<string, any>;
    targeting_key: string;
};
export type JsGraph = {
    start: (input: any, request?: PbBaseType) => Promise<JsExecution>;
    cancelExecution: (id: string) => Promise<void>;
    stop: () => Promise<void>;
    visualize: (outputPath: string) => Promise<void>;
};
export type JsExecution = {
    readonly variant: string;
    readonly executionId: string;
    next(): Promise<{
        value: any;
        done: boolean;
    }>;
    [Symbol.asyncIterator](): RuntimeInputStream;
    abort(): void;
};
/**
 * DataStore wrapper - holds shared reference to C++ DataStore
 * Currently has no exposed methods in the C++ implementation
 */
export type DataStore = {
    set(key: string, data: any): boolean;
    add(key: string, data: any): boolean;
    get(key: string): any | undefined;
    has(key: string): boolean;
    keys(): string[];
    size(): number;
    clear(): boolean;
};
export type JsDataStore = {
    set(key: string, data: any): boolean;
    get(key: string): any | undefined;
    has(key: string): boolean;
    keys(): string[];
    size(): number;
    clear(): boolean;
};
/**
 * CancellationContext wrapper - provides cancellation state checking
 */
export type CancellationContext = {
    /**
     * Check if the current operation has been cancelled
     * @returns Promise<boolean> true if cancelled, false otherwise
     */
    isCancelled(): boolean;
};
/**
 * Callback function signature for custom nodes
 * @param input - The input data for the node
 * @param context - Process context containing execution state
 * @returns Promise resolving to the node's output data
 */
export type JsNodeCallback = (context: JsProcessContext, input: WrappedType) => Promise<WrappedType>;
/**
 * Callback function signature for custom edge conditions
 * @param input - The input data to evaluate
 * @param context - Process context containing execution state
 * @returns Promise<boolean> true if condition passes, false otherwise
 */
export type JsConditionCallback = (input: any, context: JsProcessContext) => Promise<boolean>;
type JsContent = any;
export type GenerateContentRequest = {
    messages: any;
    tools: any;
    tool_choice: any;
    response_format: any;
};
export type JsTextEmbedderInterface = {
    embed(text: string): Promise<Float32Array>;
    embedBatch(texts: string[]): Promise<Float32Array[]>;
};
export type JsLLMInterface = {
    generateContent(prompt: string): Promise<RuntimeInputStream<JsContent>>;
    generateContentMessages(messages: TaggedType): Promise<RuntimeInputStream<JsContent>>;
};
type JsPrimitiveInterface = JsLLMInterface | JsTextEmbedderInterface;
export type ProcessContextPayload = {
    readonly variant: string;
    readonly executionId: string;
    readonly isCancelled: boolean;
    readonly executionConfig: any | null;
    readonly datastore: JsDataStore | null;
    readonly cancellationContext: CancellationContext | null;
    readonly hasTelemetryContext: boolean;
    readonly componentRegistry: {
        getComponent: (componentId: string) => JsPrimitiveInterface;
    };
};
/**
 * Process context containing execution state and utilities
 */
export type JsProcessContext = {
    processContext: ProcessContextPayload;
    readonly nodeId: string;
};
/**
 * Union type representing either a TaggedType or PbBaseType
 * Used throughout the graph system for flexible data handling
 */
export type WrappedType = TaggedType | PbBaseType;
export type { LocalConfigClass as LocalTextEmbedderConfig, RemoteConfigClass as RemoteTextEmbedderConfig, TextEmbedderCreationConfig, };
/**
 * STT Interface for speech-to-text operations
 */
export interface STTInterface {
    /**
     * Recognize speech from audio data
     * @param {any} audio - Audio data to recognize
     * @returns {Promise<any>} Recognition result
     */
    recognizeSpeech(audio: any): Promise<any>;
}
/**
 * STT Factory for creating Speech-to-Text instances
 */
export interface STTFactory {
    /**
     * Create a Speech-to-Text instance
     * @param {any} config - STT creation configuration
     * @returns {Promise<STTInterface>} STT interface instance
     */
    createSTT(config: any): Promise<STTInterface>;
}
/**
 * TTS Interface for text-to-speech operations
 */
export interface TTSInterface {
    /**
     * Synthesize speech from text
     * @param {any} request - TTS request with text and configuration
     * @returns {Promise<any>} Synthesized audio data
     */
    synthesizeSpeech(request: any): Promise<any>;
}
/**
 * TTS Factory for creating Text-to-Speech instances
 */
export interface TTSFactory {
    /**
     * Create a Text-to-Speech instance
     * @param {any} config - TTS creation configuration
     * @returns {Promise<TTSInterface>} TTS interface instance
     */
    createTTS(config: any): Promise<TTSInterface>;
}
/**
 * Streaming STT Interface for streaming speech-to-text operations
 */
export interface StreamingSTTInterface {
    /**
     * Recognize speech using a bidirectional audio stream.
     * @param {any} request - StreamRecognizeSpeechRequest protobuf payload
     * @returns {Promise<any>} Bidirectional stream wrapper with next/write helpers
     */
    streamRecognizeSpeech(request: any): Promise<any>;
}
/**
 * Streaming STT Factory for creating streaming Speech-to-Text instances
 */
export interface StreamingSTTFactory {
    /**
     * Create a streaming Speech-to-Text instance
     * @param {any} config - Streaming STT creation configuration
     * @returns {Promise<StreamingSTTInterface>} Streaming STT interface instance
     */
    createStreamingSTT(config: any): Promise<StreamingSTTInterface>;
}
/**
 * VAD Interface for voice activity detection operations
 */
export interface VADInterface {
    /**
     * Detect voice activity in audio data
     * @param {any} audio - Audio data to analyze
     * @returns {Promise<any>} Voice activity detection result
     */
    detectVoiceActivity(audio: any): Promise<any>;
    /**
     * Detect silence in audio data
     * @param {any} audio - Audio data to analyze
     * @returns {Promise<any>} Silence detection result
     */
    detectSilence(audio: any): Promise<any>;
    /**
     * Stream voice activity detection
     * @param {any} audioStream - Streaming audio data
     * @returns {any} Streaming voice activity detection result
     */
    streamDetectVoiceActivity(audioStream: any): any;
}
/**
 * VAD Factory for creating Voice Activity Detection instances
 */
export interface VADFactory {
    /**
     * Create a Voice Activity Detection instance
     * @param {any} config - VAD creation configuration
     * @returns {Promise<VADInterface>} VAD interface instance
     */
    createVAD(config: any): Promise<VADInterface>;
}
/**
 * Turn Detector Interface for turn completion detection
 */
export interface TurnDetectorInterface {
    /**
     * Detect turn completion in audio or text data
     * @param {any} data - Data to analyze for turn completion
     * @returns {Promise<any>} Turn completion detection result
     */
    detectTurnCompletion(data: any): Promise<any>;
}
/**
 * Turn Detector Factory for creating turn detection instances
 */
export interface TurnDetectorFactory {
    /**
     * Create a Turn Detector instance
     * @param {any} config - Turn Detector creation configuration
     * @returns {Promise<TurnDetectorInterface>} Turn Detector interface instance
     */
    createTurnDetector(config: any): Promise<TurnDetectorInterface>;
}
/**
 * AEC Filter Interface for acoustic echo cancellation
 */
export interface AECFilterInterface {
    /**
     * Filter audio to remove acoustic echo
     * @param {any} audio - Audio data to filter
     * @returns {Promise<any>} Filtered audio data
     */
    filterAudio(audio: any): Promise<any>;
    /**
     * Stream filter audio to remove acoustic echo
     * @param {any} audioStream - Streaming audio data
     * @returns {any} Streaming filtered audio data
     */
    streamFilterAudio(audioStream: any): any;
}
/**
 * AEC Filter Factory for creating Acoustic Echo Cancellation filter instances
 */
export interface AECFilterFactory {
    /**
     * Create an AEC Filter instance
     * @param {any} config - AEC Filter creation configuration
     * @returns {Promise<AECFilterInterface>} AEC Filter interface instance
     */
    createAECFilter(config: any): Promise<AECFilterInterface>;
}
/**
 * Platform namespace providing device-related functionality
 */
export interface PlatformNamespace {
    /**
     * Get device registry for managing audio devices
     * @returns {any} Device registry instance
     */
    getDeviceRegistry(): any;
}
/**
 * Speech namespace providing speech-related factories
 */
export interface SpeechNamespace {
    /**
     * Create a Speech-to-Text factory
     * @returns {STTFactory} STT factory instance
     */
    createSTTFactory(): STTFactory;
    /**
     * Create a Text-to-Speech factory
     * @returns {TTSFactory} TTS factory instance
     */
    createTTSFactory(): TTSFactory;
    /**
     * Create a streaming Speech-to-Text factory
     * @returns {StreamingSTTFactory} Streaming STT factory instance
     */
    createStreamingSTTFactory(): StreamingSTTFactory;
    /**
     * Create a Voice Activity Detection factory
     * @returns {VADFactory} VAD factory instance
     */
    createVADFactory(): VADFactory;
    /**
     * Create a Turn Detector factory
     * @returns {TurnDetectorFactory} Turn Detector factory instance
     */
    createTurnDetectorFactory(): TurnDetectorFactory;
    /**
     * Create an Acoustic Echo Cancellation filter factory
     * @returns {AECFilterFactory} AEC factory instance
     */
    createAECFilterFactory(): AECFilterFactory;
}
/**
 * LLM Factory for creating LLM instances
 */
export interface LLMFactory {
    /**
     * Create an LLM instance
     * @param {any} config - LLM creation configuration
     * @returns {Promise<JsLLMInterface>} LLM interface instance
     */
    createLLM(config: any): Promise<JsLLMInterface>;
}
/**
 * Prompt Builder Interface for building prompts
 */
export interface PromptBuilderInterface {
    /**
     * Build a prompt from template and data
     * @param {any} data - Data to use in prompt building
     * @returns {Promise<string>} Built prompt string
     */
    build(data: any): Promise<string>;
}
/**
 * Prompt Building Factory for creating prompt builder instances
 */
export interface PromptBuildingFactory {
    /**
     * Create a Jinja prompt builder instance
     * @param {any} config - Prompt builder creation configuration
     * @returns {Promise<PromptBuilderInterface>} Prompt builder interface instance
     */
    createJinjaPromptBuilder(config: any): Promise<PromptBuilderInterface>;
}
/**
 * LLM namespace providing language model factories
 */
export interface LLMNamespace {
    /**
     * Create an LLM factory
     * @returns {LLMFactory} LLM factory instance
     */
    createLLMFactory(): LLMFactory;
    /**
     * Create a prompt building factory
     * @returns {PromptBuildingFactory} Prompt building factory instance
     */
    createPromptBuildingFactory(): PromptBuildingFactory;
}
/**
 * Knowledge Interface for knowledge base operations
 */
export interface KnowledgeInterface {
    /**
     * Get knowledge from the knowledge base
     * @param {any} query - Query to search knowledge base
     * @returns {Promise<any>} Knowledge retrieval result
     */
    getKnowledge(query: any): Promise<any>;
    /**
     * Compile knowledge from data
     * @param {any} data - Data to compile into knowledge base
     * @returns {Promise<any>} Compilation result
     */
    compileKnowledge(data: any): Promise<any>;
    /**
     * Compile knowledge from file
     * @param {string} filePath - Path to file containing knowledge data
     * @returns {Promise<any>} Compilation result
     */
    compileKnowledgeFromFile(filePath: string): Promise<any>;
    /**
     * Remove knowledge from the knowledge base
     * @param {any} identifier - Identifier of knowledge to remove
     * @returns {Promise<any>} Removal result
     */
    removeKnowledge(identifier: any): Promise<any>;
}
/**
 * Knowledge Factory for creating knowledge instances
 */
export interface KnowledgeFactory {
    /**
     * Create a knowledge instance
     * @param {any} config - Knowledge creation configuration
     * @returns {Promise<KnowledgeInterface>} Knowledge interface instance
     */
    createKnowledge(config: any): Promise<KnowledgeInterface>;
}
/**
 * Knowledge namespace providing knowledge base factories
 */
export interface KnowledgeNamespace {
    /**
     * Create a knowledge factory
     * @returns {KnowledgeFactory} Knowledge factory instance
     */
    createKnowledgeFactory(): KnowledgeFactory;
}
/**
 * Text Classifier Interface for text classification operations
 */
export interface TextClassifierInterface {
    /**
     * Classify text into categories
     * @param {any} text - Text to classify
     * @returns {Promise<any>} Classification result
     */
    classifyText(text: any): Promise<any>;
}
/**
 * Text Classifier Factory for creating text classifier instances
 */
export interface TextClassifierFactory {
    /**
     * Create a text classifier instance
     * @param {JsTextEmbedderInterface} embedder - Text embedder interface instance
     * @param {any} config - Text classifier creation configuration
     * @returns {Promise<TextClassifierInterface>} Text classifier interface instance
     */
    createTextClassifier(embedder: JsTextEmbedderInterface, config: any): Promise<TextClassifierInterface>;
}
/**
 * NER Interface for named entity recognition operations
 */
export interface NERInterface {
    /**
     * Extract entities from text
     * @param {any} text - Text to extract entities from
     * @returns {Promise<any>} Extracted entities
     */
    extractEntities(text: any): Promise<any>;
}
/**
 * NER Factory for creating Named Entity Recognition instances
 */
export interface NERFactory {
    /**
     * Create a NER instance
     * @param {any} config - NER creation configuration
     * @returns {Promise<NERInterface>} NER interface instance
     */
    createNER(config: any): Promise<NERInterface>;
}
/**
 * Keyword Matcher Interface for keyword matching operations
 */
export interface KeywordMatcherInterface {
    /**
     * Match keywords in text
     * @param {any} text - Text to match keywords against
     * @returns {Promise<any>} Matched keywords result
     */
    matchKeywords(text: any): Promise<any>;
}
/**
 * Keyword Matcher Factory for creating keyword matcher instances
 */
export interface KeywordMatcherFactory {
    /**
     * Create a keyword matcher instance
     * @param {any} config - Keyword matcher creation configuration
     * @returns {Promise<KeywordMatcherInterface>} Keyword matcher interface instance
     */
    createKeywordMatcher(config: any): Promise<KeywordMatcherInterface>;
}
/**
 * NLU namespace providing natural language understanding factories
 */
export interface NLUNamespace {
    /**
     * Create a text classifier factory
     * @returns {TextClassifierFactory} Text classifier factory instance
     */
    createTextClassifierFactory(): TextClassifierFactory;
    /**
     * Create a Named Entity Recognition factory
     * @returns {NERFactory} NER factory instance
     */
    createNERFactory(): NERFactory;
    /**
     * Create a keyword matcher factory
     * @returns {KeywordMatcherFactory} Keyword matcher factory instance
     */
    createKeywordMatcherFactory(): KeywordMatcherFactory;
}
/**
 * MCP Client Interface for Model Context Protocol operations
 */
export interface MCPClientInterface {
    /**
     * List available tools
     * @returns {Promise<any>} List of available tools
     */
    listTools(): Promise<any>;
    /**
     * Call a tool with parameters
     * @param {any} request - Tool call request with tool name and parameters
     * @returns {Promise<any>} Tool call result
     */
    call(request: any): Promise<any>;
}
/**
 * MCP Client Factory for creating MCP client instances
 */
export interface MCPClientFactory {
    /**
     * Create an MCP client instance
     * @param {any} config - MCP client creation configuration
     * @returns {Promise<MCPClientInterface>} MCP client interface instance
     */
    createMCPClient(config: any): Promise<MCPClientInterface>;
}
/**
 * MCP namespace providing Model Context Protocol client factories
 */
export interface MCPNamespace {
    /**
     * Create an MCP client factory
     * @returns {MCPClientFactory} MCP client factory instance
     */
    createMCPClientFactory(): MCPClientFactory;
}
/**
 * Text Embedder Factory for creating text embedder instances
 */
export interface TextEmbedderFactory {
    /**
     * Create a text embedder instance
     * @param {any} config - Text embedder creation configuration
     * @returns {Promise<JsTextEmbedderInterface>} Text embedder interface instance
     */
    createTextEmbedder(config: any): Promise<JsTextEmbedderInterface>;
}
/**
 * Embeddings namespace providing text embedding factories
 */
export interface EmbeddingsNamespace {
    /**
     * Create a text embedder factory
     * @returns {TextEmbedderFactory} Text embedder factory instance
     */
    createTextEmbedderFactory(): TextEmbedderFactory;
}
/**
 * Testing namespace providing testing utilities
 */
export interface TestingNamespace {
    /**
     * Register testing nodes
     * @param {any} config - Testing node configuration
     * @returns {void}
     */
    registerNodes(config: any): void;
    /**
     * Create a test string stream
     * @param {any} config - String stream configuration
     * @returns {any} String stream instance
     */
    stringStream(config: any): any;
}
/**
 * Addon Environment - the main interface for the Inworld Node.js addon
 * Created by calling inworldAddon.createEnv(config?)
 */
export interface AddonEnvironment {
    /**
     * Create a graph executor from a serialized CreateGraphRequest
     * @param {PbBaseType} spec - Encoded CreateGraphRequest protobuf
     * @returns {Promise<JsGraph>} Promise resolving to a graph instance
     */
    createGraph(spec: Record<string, any>): Promise<JsGraph>;
    /**
     * Register custom node and condition callbacks
     * @param {object} callbacks - Object containing nodes and/or conditions
     * @param {Record<string, JsNodeCallback>} callbacks.nodes - Map of node type names to callback functions
     * @param {Record<string, JsConditionCallback>} callbacks.conditions - Map of condition type names to callback functions
     * @returns {void}
     */
    registerCallbacks(callbacks: {
        nodes?: Record<string, JsNodeCallback>;
        conditions?: Record<string, JsConditionCallback>;
    }): void;
    /**
     * Clear all registered callbacks
     * @returns {void}
     */
    clearCallbacks(): void;
    /**
     * Set a single environment variable/substitution
     * @param {string} name - Variable name
     * @param {string} value - Variable value
     * @param {boolean} allowOverwrite - Whether to allow overwriting existing variable (default: false)
     * @returns {void}
     */
    setVariable(name: string, value: string, allowOverwrite?: boolean): void;
    /**
     * Set multiple environment variables/substitutions
     * @param {Record<string, string>} variables - Map of variable names to values
     * @param {boolean} allowOverwrite - Whether to allow overwriting existing variables (default: false)
     * @returns {void}
     */
    setVariables(variables: Record<string, string>, allowOverwrite?: boolean): void;
    /**
     * Get all environment variables/substitutions
     * @returns {Record<string, string>} Map of all variable names to values
     */
    getVariables(): Record<string, string>;
    /**
     * Get testing utilities
     * @returns {TestingNamespace} Testing namespace with utility methods
     */
    testing(): TestingNamespace;
    /**
     * Close the environment and clean up resources
     * @returns {Promise<void>} Promise that resolves when cleanup is complete
     */
    close(): Promise<void>;
    /**
     * Platform namespace - provides device-related functionality
     */
    readonly platform: PlatformNamespace;
    /**
     * Speech namespace - provides speech processing factories
     */
    readonly speech: SpeechNamespace;
    /**
     * LLM namespace - provides language model factories
     */
    readonly llm: LLMNamespace;
    /**
     * Knowledge namespace - provides knowledge base factories
     */
    readonly knowledge: KnowledgeNamespace;
    /**
     * NLU namespace - provides natural language understanding factories
     */
    readonly nlu: NLUNamespace;
    /**
     * MCP namespace - provides Model Context Protocol client factories
     */
    readonly mcp: MCPNamespace;
    /**
     * Embeddings namespace - provides text embedding factories
     */
    readonly embeddings: EmbeddingsNamespace;
}
