"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateInput = void 0;
exports.serializeContextWithHighlights = serializeContextWithHighlights;
exports.ValidateInput = ValidateInput;
/**
 * @internal
 */
const chalk_1 = __importDefault(require("chalk"));
const z = __importStar(require("zod"));
const inworld_1 = require("../error/inworld");
/**
 * Formats a Zod validation issue into a human-readable error message with colors.
 * @param issue - The Zod issue to format
 * @returns A formatted error message string
 */
function formatZodIssue(issue) {
    var _a;
    const path = issue.path.length > 0 ? issue.path.join('.') : 'root';
    // Format based on issue code for better context
    switch (issue.code) {
        case 'invalid_type':
            return `  ${chalk_1.default.red('•')} ${chalk_1.default.yellow(path)}: Expected ${chalk_1.default.green(issue.expected)}, but received ${chalk_1.default.red(issue.received)}`;
        case 'invalid_union':
            return `  ${chalk_1.default.red('•')} ${chalk_1.default.yellow(path)}: ${issue.message}`;
        case 'unrecognized_keys':
            const keys = ((_a = issue.keys) === null || _a === void 0 ? void 0 : _a.join(', ')) || 'unknown keys';
            return `  ${chalk_1.default.red('•')} ${chalk_1.default.yellow(path)}: Unrecognized keys: ${chalk_1.default.cyan(keys)}`;
        case 'too_small':
        case 'too_big':
            return `  ${chalk_1.default.red('•')} ${chalk_1.default.yellow(path)}: ${issue.message}`;
        default:
            // Handle other issue types with special formatting if they have additional context
            if ('received' in issue && 'expected' in issue) {
                return `  ${chalk_1.default.red('•')} ${chalk_1.default.yellow(path)}: Expected ${chalk_1.default.green(issue.expected)}, but received ${chalk_1.default.red(issue.received)}`;
            }
            return `  ${chalk_1.default.red('•')} ${chalk_1.default.yellow(path)}: ${issue.message}`;
    }
}
/**
 * Serializes the input context with highlighted error paths.
 * @param value - The input value that failed validation
 * @param issues - The list of validation issues from Zod
 * @returns A formatted string showing the input with error highlights
 * @example
 * ```typescript
 * const issues = [{path: ['user', 'email'], message: 'Invalid email'}];
 * const highlighted = serializeContextWithHighlights(myObject, issues);
 * console.log(highlighted); // Shows the object with highlighted error paths
 * ```
 */
function serializeContextWithHighlights(value, issues) {
    const errorPaths = new Set(issues.map((issue) => issue.path.join('.')).filter((p) => p.length > 0));
    // Check if current path or any of its children have errors
    function hasErrorInPath(path) {
        // Check exact match
        if (errorPaths.has(path))
            return true;
        // Check if any error path starts with this path (children have errors)
        for (const errorPath of errorPaths) {
            if (errorPath.startsWith(path + '.')) {
                return true;
            }
        }
        return false;
    }
    // Get direct child fields that have errors
    function getErrorFields(path) {
        const prefix = path ? path + '.' : '';
        const childErrors = [];
        for (const errorPath of errorPaths) {
            if (errorPath.startsWith(prefix)) {
                const remainingPath = errorPath.substring(prefix.length);
                const firstSegment = remainingPath.split('.')[0];
                if (firstSegment && !childErrors.includes(firstSegment)) {
                    childErrors.push(firstSegment);
                }
            }
        }
        return childErrors;
    }
    function highlightValue(val, currentPath = [], indent = 0) {
        const spacing = '  '.repeat(indent);
        const fullPath = currentPath.join('.');
        const hasDirectError = errorPaths.has(fullPath);
        const hasNestedError = hasErrorInPath(fullPath);
        const marker = hasDirectError ? chalk_1.default.red(' ← ERROR') : '';
        if (val === null) {
            return chalk_1.default.gray('null') + marker;
        }
        if (val === undefined) {
            return chalk_1.default.gray('undefined') + marker;
        }
        if (typeof val === 'string') {
            return chalk_1.default.green(`"${val}"`) + marker;
        }
        if (typeof val === 'number' || typeof val === 'boolean') {
            return chalk_1.default.blue(String(val)) + marker;
        }
        if (Array.isArray(val)) {
            if (val.length === 0) {
                return chalk_1.default.gray('[]') + marker;
            }
            // Get error fields for this array
            const errorFields = hasNestedError ? getErrorFields(fullPath) : [];
            const errorFieldsHint = errorFields.length > 0
                ? chalk_1.default.red(` ← item${errorFields.length > 1 ? 's' : ''} ${errorFields.join(', ')} ${errorFields.length > 1 ? 'have' : 'has'} error${errorFields.length > 1 ? 's' : ''}`)
                : '';
            const items = val.map((item, index) => {
                const itemPath = [...currentPath, String(index)];
                const itemFullPath = itemPath.join('.');
                const itemHasNestedError = hasErrorInPath(itemFullPath);
                const indexColor = itemHasNestedError ? chalk_1.default.yellow : chalk_1.default.gray;
                return `${spacing}  ${indexColor(`[${index}]`)} ${highlightValue(item, itemPath, indent + 1)}`;
            });
            // Highlight the array brackets if it has nested errors
            const bracketColor = hasNestedError ? chalk_1.default.yellow : chalk_1.default.gray;
            return `${bracketColor('[')}${errorFieldsHint}${marker}\n${items.join(',\n')}\n${spacing}${bracketColor(']')}`;
        }
        if (typeof val === 'object') {
            const keys = Object.keys(val);
            if (keys.length === 0) {
                return chalk_1.default.gray('{}') + marker;
            }
            // Get error fields for this object
            const errorFields = hasNestedError ? getErrorFields(fullPath) : [];
            const errorFieldsHint = errorFields.length > 0
                ? chalk_1.default.red(` ← ${errorFields.join(', ')} field${errorFields.length > 1 ? 's have' : ' has'} error${errorFields.length > 1 ? 's' : ''}`)
                : '';
            const entries = keys.map((key) => {
                const keyPath = [...currentPath, key];
                const keyFullPath = keyPath.join('.');
                const keyHasDirectError = errorPaths.has(keyFullPath);
                const keyHasNestedError = hasErrorInPath(keyFullPath);
                // Use red for direct errors, yellow for nested errors, cyan otherwise
                const keyColor = keyHasDirectError
                    ? chalk_1.default.red
                    : keyHasNestedError
                        ? chalk_1.default.yellow
                        : chalk_1.default.cyan;
                return `${spacing}  ${keyColor(key)}: ${highlightValue(val[key], keyPath, indent + 1)}`;
            });
            // Highlight the object brackets if it has nested errors
            const bracketColor = hasNestedError ? chalk_1.default.yellow : chalk_1.default.gray;
            return `${bracketColor('{')}${errorFieldsHint}${marker}\n${entries.join(',\n')}\n${spacing}${bracketColor('}')}`;
        }
        return String(val) + marker;
    }
    return highlightValue(value);
}
const validateInput = (schema, value, throwOnAnyIssue = false, context) => {
    var _a;
    const result = z.safeParse(schema, value);
    const issues = ((_a = result.error) === null || _a === void 0 ? void 0 : _a.issues) || [];
    if (throwOnAnyIssue && issues.length > 0) {
        const errorSummary = issues.map(formatZodIssue).join('\n');
        const contextPreview = serializeContextWithHighlights(value, issues);
        const errorMessage = [
            '\n',
            chalk_1.default.bold.red('═══════════════════════════════════════════════════════════'),
            chalk_1.default.bold.red(chalk_1.default.bold(` Validation Failed in the ${context === null || context === void 0 ? void 0 : context.componentName}`)),
            chalk_1.default.bold.red('═══════════════════════════════════════════════════════════'),
            '',
            chalk_1.default.bold.underline('Errors:'),
            errorSummary,
            '',
            chalk_1.default.bold.underline('Input Context:'),
            contextPreview,
        ].join('\n');
        throw new inworld_1.InworldError(errorMessage);
    }
    issues.forEach((issue) => {
        // eslint-disable-next-line no-console
        console.warn(formatZodIssue(issue));
    });
};
exports.validateInput = validateInput;
/**
 * Class decorator that validates the first argument of the constructor using a Zod schema.
 * @param schema - The Zod schema to validate against
 * @param throwOnAnyIssue - Whether to throw an error on validation failure (default: false)
 * @returns A class decorator function
 * @example
 * ```typescript
 * @ValidateInput(MySchema)
 * class MyClass {
 *   constructor(input: MyInterface) {
 *     // input will be validated before reaching here
 *   }
 * }
 * ```
 */
function ValidateInput(schema, throwOnAnyIssue = false) {
    return function (constructor, _context) {
        return class extends constructor {
            constructor(...args) {
                // Validate the first argument
                if (args.length > 0) {
                    (0, exports.validateInput)(schema, args[0], throwOnAnyIssue, {
                        componentName: _context.name,
                    });
                }
                super(...args);
            }
        };
    };
}
