"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.showWelcomeMessage = showWelcomeMessage;
/**
 * @internal
 */
const fs_1 = require("fs");
const path_1 = require("path");
// Try to get package version directly from package.json using require()
// This is more reliable than __dirname when the package is installed in node_modules
// because require() follows Node's module resolution algorithm
let packageJsonData;
try {
    packageJsonData = require('../package.json');
}
catch (_e) {
    // If require fails (e.g., in some build configurations),
    // we'll fall back to filesystem-based approaches below
}
function showWelcomeMessage() {
    // Display welcome message
    const reset = '\x1b[0m';
    const bold = '\x1b[1m';
    // Use default color for the frame so it matches the terminal background/appearance
    const frameColor = '';
    // Read versions dynamically
    let cppVersion = 'Unknown';
    let packageVersion = (packageJsonData === null || packageJsonData === void 0 ? void 0 : packageJsonData.version) || 'Unknown';
    // Try multiple strategies to find the package root for runtime-binaries-version.txt
    const possiblePaths = [
        // When running from source (development)
        (0, path_1.join)(__dirname, '..'),
        // When running from compiled output (build directory)
        (0, path_1.join)(__dirname, '..', '..'),
        // When used as installed package - look for package.json up the tree
        (0, path_1.join)(__dirname, '..', '..', '..'),
        // Current working directory as fallback
        process.cwd(),
    ];
    // Find runtime-binaries-version.txt
    for (const basePath of possiblePaths) {
        try {
            cppVersion = (0, fs_1.readFileSync)((0, path_1.join)(basePath, 'runtime-binaries-version.txt'), 'utf-8').trim();
            break; // Found it, stop searching
        }
        catch (_e) {
            // Continue to next path
        }
    }
    // If we didn't get package version from require, try filesystem approach
    if (packageVersion === 'Unknown') {
        for (const basePath of possiblePaths) {
            try {
                const packageJson = JSON.parse((0, fs_1.readFileSync)((0, path_1.join)(basePath, 'package.json'), 'utf-8'));
                // Make sure it's the right package.json by checking the name
                if (packageJson.name === '@inworld/runtime') {
                    packageVersion = packageJson.version;
                    break;
                }
            }
            catch (_e) {
                // Continue to next path
            }
        }
    }
    // Fancy boxed ASCII-art template (keeps both Core and Node.js versions)
    const topLeft = '┌';
    const topRight = '┐';
    const bottomLeft = '└';
    const bottomRight = '┘';
    const horizontal = '─';
    const vertical = '│';
    // Big-logo lines (inspired by header above). We keep it scalable by
    // measuring width dynamically rather than hard-coding spaces.
    const logoLines = [
        '░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░',
        '░▀█▀░█▀█░█░█░█▀█░█▀▄░█░░░█▀▄░░░█▀▄░█░█░█▀█░▀█▀░▀█▀░█▄█░█▀▀░░',
        '░░█░░█░█░█▄█░█░█░█▀▄░█░░░█░█░░░█▀▄░█░█░█░█░░█░░░█░░█░█░█▀▀░░',
        '░▀▀▀░▀░▀░▀░▀░▀▀▀░▀░▀░▀▀▀░▀▀░░░░▀░▀░▀▀▀░▀░▀░░▀░░▀▀▀░▀░▀░▀▀▀░░',
        '░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░',
    ];
    // Helpers to correctly handle visible width when strings contain ANSI codes
    const stripAnsi = (value) => value.replace(/\x1b\[[0-9;]*m/g, '');
    const visibleLength = (value) => stripAnsi(value).length;
    const padRightVisible = (value, target) => {
        const missing = target - visibleLength(value);
        return missing > 0 ? `${value}${' '.repeat(missing)}` : value;
    };
    // Create version lines with aligned labels and versions
    const createAlignedVersionLines = () => {
        const labels = ['core', 'node.js'];
        const versions = [cppVersion, `v${packageVersion}`];
        const minSpaceBetween = 2; // Minimum spaces between label and version
        const versionEndColumn = 60; // Where versions end (right edge)
        // Calculate the maximum widths for both labels and versions
        const labelWidths = labels.map((label) => visibleLength(`${bold}${label}:${reset}`));
        const maxLabelWidth = Math.max(...labelWidths);
        const versionWidths = versions.map((version) => visibleLength(version));
        const maxVersionWidth = Math.max(...versionWidths);
        // Calculate where labels should start to ensure minimum spacing
        // labelStartColumn + maxLabelWidth + minSpaceBetween + maxVersionWidth = versionEndColumn
        const labelStartColumn = versionEndColumn - maxLabelWidth - minSpaceBetween - maxVersionWidth;
        return labels.map((label, index) => {
            const labelWithColon = `${bold}${label}:${reset}`;
            const versionStr = versions[index];
            // Calculate visible widths
            const labelVisibleWidth = visibleLength(labelWithColon);
            const versionVisibleWidth = visibleLength(versionStr);
            // Calculate padding after label to align all labels to max width
            const labelPadding = maxLabelWidth - labelVisibleWidth;
            // Calculate middle spacing to push version to right edge
            const middleSpacing = versionEndColumn -
                labelStartColumn -
                maxLabelWidth -
                versionVisibleWidth;
            // Build the complete line
            return `${' '.repeat(labelStartColumn)}${labelWithColon}${' '.repeat(labelPadding + middleSpacing)}${versionStr}`;
        });
    };
    const versionLines = createAlignedVersionLines();
    const spacerLines = [' '];
    const allContentLines = [
        ...spacerLines,
        ...logoLines,
        ...spacerLines,
        ...versionLines,
        ' ',
    ];
    const innerWidth = allContentLines.reduce((max, line) => Math.max(max, visibleLength(line)), 0);
    const renderLine = (line) => {
        const padded = line.padEnd(innerWidth, ' ');
        // eslint-disable-next-line no-console
        console.log(`${frameColor}${vertical}${reset} ${padded} ${frameColor}${vertical}${reset}`);
    };
    // Top border
    // eslint-disable-next-line no-console
    console.log(`${frameColor}${topLeft}${horizontal.repeat(innerWidth + 2)}${topRight}${reset}`);
    // Body
    for (const line of allContentLines) {
        renderLine(padRightVisible(line, innerWidth));
    }
    // Bottom border
    // eslint-disable-next-line no-console
    console.log(`${frameColor}${bottomLeft}${horizontal.repeat(innerWidth + 2)}${bottomRight}${reset}`);
}
