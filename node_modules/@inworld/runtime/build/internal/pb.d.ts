import protobuf from 'protobufjs';
import type { KnowledgeRecords as KnowledgeRecordsData, LLMChatResponse as LLMChatResponseData, LLMChatRoutingRequest, LLMCompletionResponse as LLMCompletionResponseData, ToolCallResult as ToolCallResultData } from '../common/api/graphs';
import { ContentData, EvaluationMode, LLMChatRequest, TelemetryExporterType, TelemetryLogLevel, ToolCallResponse, TTSRequest, WorkerCountStrategy } from '../common/api/graphs';
import type { AudioChunk as AudioFrameData, Device as DeviceData, EmbedBatchResponse as EmbeddingBatchData, EmbedRequest as EmbeddingRequest, EmbedResponse as EmbeddingData } from '../common/api/library';
import { DequeueSpanTracesResponse, LogMessageRequest, MetricConfig as TelemetryMetricConfig, RecordMetricRequest, SimpleTelemetryConfig, TelemetryConfig as ProtoTelemetryConfig, ToolList as ToolListData } from '../common/api/library';
import type { VADConfig } from '../primitives/speech/types';
import { PbBaseType } from './pb_types';
import { RuntimeInputStream } from './types';
declare const TTSRequest: protobuf.Type, LLMChatRequest: protobuf.Type, LLMChatRoutingRequest: protobuf.Type, ToolCallResponse: protobuf.Type, ContentData: protobuf.Type;
export type { PbBaseType } from './pb_types';
export declare const isPbBaseType: (value: unknown) => value is PbBaseType;
export type PbStreamBaseType = {
    _pb: Uint8Array<ArrayBufferLike>;
    _stream: RuntimeInputStream;
};
export declare const isPbStreamBaseType: (value: unknown) => value is PbStreamBaseType;
/**
 * Get the type of a protobuf object
 * @param {Object} obj - Object with _pb field containing serialized bytes
 * @returns {string} The type of the message ('text', 'error', etc.) or null if
 *     unknown
 */
declare function getType(obj: any): "unknown" | "error" | "audio" | "json" | "text" | "any" | "ttsOutput" | "safetyResult" | "matchedKeywords" | "matchedPhrases" | "classificationResult" | "knowledgeRecords" | "matchedIntents" | "toolCallRequest" | "listToolsResponse" | "llmChatRequest" | "llmChatResponse" | "llmCompletionRequest" | "llmCompletionResponse" | "toolCallResult" | "toolCallResponse" | "ttsRequest" | "sttRequest" | "googleSerperApiSearchRequest" | "googleSerperApiSearchResponse" | "multiModalContent" | "contentData" | "goalAdvancementRequest" | "goalAdvancementResponse" | "customData" | "llmChatRoutingRequest" | "dataStreamWithMetadata";
declare function encodeLLMChatResponse(content: string, stream?: boolean, toolCalls?: Array<{
    id: string;
    name: string;
    args: string;
}>): PbBaseType;
declare function encodeLLMChatResponse(response: LLMChatResponseData): PbBaseType;
export declare const embeddingsMethods: {
    unpackEmbedding(obj: PbBaseType): EmbeddingData;
    unpackEmbeddingBatch(obj: PbBaseType): EmbeddingBatchData;
    createTextBatch(texts: string[]): PbBaseType;
    createTextEmbedRequest(request: EmbeddingRequest): PbBaseType;
    createTextEmbedderCreationConfig(config: Record<any, any>): PbBaseType;
};
export declare const speechMethods: {
    createSTTCreationConfig(config: Record<any, any>): PbBaseType;
    createStreamingSTTCreationConfig(config: Record<any, any>): PbBaseType;
    createStreamRecognizeSpeechRequest(request?: {
        config?: {
            languageCode?: string;
            silenceThresholdMs?: number;
        };
        credentials?: Record<string, any>;
    }): PbBaseType;
    createAudioFrame(audioFrame: Record<any, any>): PbBaseType;
    createTTSCreationConfig(config: Record<any, any>): PbBaseType;
    createVADCreationConfig(config: Record<any, any>): PbBaseType;
    createAECFilterCreationConfig(config: Record<any, any>): PbBaseType;
    createTurnDetectorCreationConfig(config: Record<any, any>): PbBaseType;
    createSynthesizeSpeechRequest(request: {
        voice: any;
        text: string;
        config?: any;
    }): PbBaseType;
    createRecognizeSpeechRequest(audioChunk: any, config?: any): PbBaseType;
    createDetectVoiceActivityRequest(audioChunk: any, config?: any): PbBaseType;
    createDetectTurnCompletionRequest(audioChunk: any, config?: any): PbBaseType;
    createFilterAudioRequest(request: any): PbBaseType;
    unpackAudioFrame(obj: PbBaseType): AudioFrameData;
    unpackStreamSpeechRecognitionResponse(obj: PbBaseType): {
        text: string;
        isFinal: boolean;
    };
    unpackTurnPrediction(obj: PbBaseType): any;
    unpackText(obj: PbBaseType): string;
    createDetectSilenceRequest(audioBytes: Buffer, sampleRate: number, config?: VADConfig): PbBaseType;
};
export declare const llmMethods: {
    createLLMCreationConfig(config: Record<any, any>): PbBaseType;
    createGenerateContentRequest(content: string, config: any): PbBaseType;
    createGenerateContentChatRequest(messages: any[], options: any): PbBaseType;
    unpackLLMGenerationResult(obj: PbBaseType): LLMCompletionResponseData;
};
export declare const nluMethods: {
    createNERCreationConfig(config: Record<any, any>): PbBaseType;
    unpackExtractEntitiesResponse(obj: PbBaseType): any[];
    unpackEntityMatch(obj: PbBaseType): any;
    unpackEntityMatches(objArray: any[]): any[];
    createKeywordGroup(group: {
        keywords: string[];
        name: string;
    }): PbBaseType;
    createTextClassifierCreationConfig(config: Record<any, any>): PbBaseType;
    createClassifyTextRequest(request: any): PbBaseType;
    unpackTextClassifierResponse(obj: PbBaseType): {
        classes: {
            className: string;
            confidence: number;
        }[];
    };
    unpackKeywordMatcherResponse(obj: PbBaseType): {
        matches: {
            groupName: string;
            keyword: string;
        }[];
    };
};
export declare const knowledgeMethods: {
    createKnowledgeCreationConfig(config: Record<any, any>): PbBaseType;
    createCompileKnowledgeRequest(knowledgeId: string, records: any[]): PbBaseType;
    createGetKnowledgeRequest(ids: string[], searchQuery: string): PbBaseType;
    unpackKnowledgeRecords(obj: PbBaseType): KnowledgeRecordsData;
    createCompileKnowledgeFromFileRequest(knowledgeId: string, filePath: string): PbBaseType;
};
export declare const mcpMethods: {
    createMCPClientCreationConfig(config: Record<any, any>): PbBaseType;
    unpackToolList(obj: PbBaseType): ToolListData;
    createToolCall(toolCallId: string, name: string, args: string): PbBaseType;
    unpackToolCallResult(obj: PbBaseType): ToolCallResultData;
};
export declare const platformMethods: {
    /**
     * Unpack a Device protobuf message to Device
     * @param {PbBaseType} obj - Protobuf object containing Device message
     * @returns {DeviceData} Unpacked device object
     */
    unpackDevice(obj: PbBaseType): DeviceData;
};
export declare const telemetryMethods: {
    createConfigureTelemetryRequest(config: {
        config?: ProtoTelemetryConfig;
        simpleConfig?: SimpleTelemetryConfig;
    }): PbBaseType;
    unpackConfigureTelemetryRequest(obj: PbBaseType): {
        config?: ProtoTelemetryConfig;
        simpleConfig?: SimpleTelemetryConfig;
    };
    createTelemetryConfig(config: ProtoTelemetryConfig): ProtoTelemetryConfig;
    createSimpleTelemetryConfig(config: SimpleTelemetryConfig): SimpleTelemetryConfig;
    createLoggerConfig(config: Record<any, any>): Record<any, any>;
    createTracerConfig(config: Record<any, any>): Record<any, any>;
    createMetricsConfig(config: Record<any, any>): Record<any, any>;
    createMetricConfig(config: TelemetryMetricConfig): PbBaseType;
    createRecordMetricRequest(request: RecordMetricRequest): PbBaseType;
    createLogMessageRequest(request: LogMessageRequest): PbBaseType;
    unpackDequeueSpanTracesResponse(obj: PbBaseType): DequeueSpanTracesResponse;
    createSpanEvent(event: Record<any, any>): Record<any, any>;
    createSpanData(span: Record<any, any>): Record<any, any>;
};
type FeatureFlagConfigOptions = {
    enabled?: boolean;
    flagdAddress?: string;
    pollIntervalMs?: number;
    evaluationMode?: EvaluationMode;
};
type CreateGraphRequestOptions = {
    spec?: Record<string, any>;
    specJson?: string;
    substitutions?: Record<string, string | undefined>;
    featureFlagConfig?: FeatureFlagConfigOptions;
};
type StartExecutionContextInput = {
    executionId: string;
    userContext?: {
        attributes?: Record<string, string>;
        targetingKey?: string;
    };
    userCredentials?: Record<string, any>;
    dataToStore?: Record<string, PbBaseType>;
};
type StartExecutionRequestOptions = {
    executionContext: StartExecutionContextInput;
};
type ThreadPoolOptions = {
    workerStrategy?: WorkerCountStrategy;
    workerCount?: number;
    coreMultiplier?: number;
};
type TelemetryOptions = {
    appName?: string;
    appVersion?: string;
    exporterType?: TelemetryExporterType;
    sinkAbslLogs?: boolean;
    logLevel?: TelemetryLogLevel;
};
type CreateEnvRequestOptions = {
    initializeFromEnvVars?: boolean;
    threadPool?: ThreadPoolOptions;
    telemetry?: TelemetryOptions;
    substitutions?: Record<string, string | undefined>;
    addonPoolSize?: number;
};
export declare const graphMethods: {
    createEnvRequest(options?: CreateEnvRequestOptions): PbBaseType;
    createGraphRequest(options: CreateGraphRequestOptions): PbBaseType;
    createStartExecutionRequest(options: StartExecutionRequestOptions): PbBaseType;
};
export declare const PbType: {
    embeddings: {
        unpackEmbedding(obj: PbBaseType): EmbeddingData;
        unpackEmbeddingBatch(obj: PbBaseType): EmbeddingBatchData;
        createTextBatch(texts: string[]): PbBaseType;
        createTextEmbedRequest(request: EmbeddingRequest): PbBaseType;
        createTextEmbedderCreationConfig(config: Record<any, any>): PbBaseType;
    };
    speech: {
        createSTTCreationConfig(config: Record<any, any>): PbBaseType;
        createStreamingSTTCreationConfig(config: Record<any, any>): PbBaseType;
        createStreamRecognizeSpeechRequest(request?: {
            config?: {
                languageCode?: string;
                silenceThresholdMs?: number;
            };
            credentials?: Record<string, any>;
        }): PbBaseType;
        createAudioFrame(audioFrame: Record<any, any>): PbBaseType;
        createTTSCreationConfig(config: Record<any, any>): PbBaseType;
        createVADCreationConfig(config: Record<any, any>): PbBaseType;
        createAECFilterCreationConfig(config: Record<any, any>): PbBaseType;
        createTurnDetectorCreationConfig(config: Record<any, any>): PbBaseType;
        createSynthesizeSpeechRequest(request: {
            voice: any;
            text: string;
            config?: any;
        }): PbBaseType;
        createRecognizeSpeechRequest(audioChunk: any, config?: any): PbBaseType;
        createDetectVoiceActivityRequest(audioChunk: any, config?: any): PbBaseType;
        createDetectTurnCompletionRequest(audioChunk: any, config?: any): PbBaseType;
        createFilterAudioRequest(request: any): PbBaseType;
        unpackAudioFrame(obj: PbBaseType): AudioFrameData;
        unpackStreamSpeechRecognitionResponse(obj: PbBaseType): {
            text: string;
            isFinal: boolean;
        };
        unpackTurnPrediction(obj: PbBaseType): any;
        unpackText(obj: PbBaseType): string;
        createDetectSilenceRequest(audioBytes: Buffer, sampleRate: number, config?: VADConfig): PbBaseType;
    };
    llm: {
        createLLMCreationConfig(config: Record<any, any>): PbBaseType;
        createGenerateContentRequest(content: string, config: any): PbBaseType;
        createGenerateContentChatRequest(messages: any[], options: any): PbBaseType;
        unpackLLMGenerationResult(obj: PbBaseType): LLMCompletionResponseData;
    };
    nlu: {
        createNERCreationConfig(config: Record<any, any>): PbBaseType;
        unpackExtractEntitiesResponse(obj: PbBaseType): any[];
        unpackEntityMatch(obj: PbBaseType): any;
        unpackEntityMatches(objArray: any[]): any[];
        createKeywordGroup(group: {
            keywords: string[];
            name: string;
        }): PbBaseType;
        createTextClassifierCreationConfig(config: Record<any, any>): PbBaseType;
        createClassifyTextRequest(request: any): PbBaseType;
        unpackTextClassifierResponse(obj: PbBaseType): {
            classes: {
                className: string;
                confidence: number;
            }[];
        };
        unpackKeywordMatcherResponse(obj: PbBaseType): {
            matches: {
                groupName: string;
                keyword: string;
            }[];
        };
    };
    knowledge: {
        createKnowledgeCreationConfig(config: Record<any, any>): PbBaseType;
        createCompileKnowledgeRequest(knowledgeId: string, records: any[]): PbBaseType;
        createGetKnowledgeRequest(ids: string[], searchQuery: string): PbBaseType;
        unpackKnowledgeRecords(obj: PbBaseType): KnowledgeRecordsData;
        createCompileKnowledgeFromFileRequest(knowledgeId: string, filePath: string): PbBaseType;
    };
    mcp: {
        createMCPClientCreationConfig(config: Record<any, any>): PbBaseType;
        unpackToolList(obj: PbBaseType): ToolListData;
        createToolCall(toolCallId: string, name: string, args: string): PbBaseType;
        unpackToolCallResult(obj: PbBaseType): ToolCallResultData;
    };
    platform: {
        /**
         * Unpack a Device protobuf message to Device
         * @param {PbBaseType} obj - Protobuf object containing Device message
         * @returns {DeviceData} Unpacked device object
         */
        unpackDevice(obj: PbBaseType): DeviceData;
    };
    telemetry: {
        createConfigureTelemetryRequest(config: {
            config?: ProtoTelemetryConfig;
            simpleConfig?: SimpleTelemetryConfig;
        }): PbBaseType;
        unpackConfigureTelemetryRequest(obj: PbBaseType): {
            config?: ProtoTelemetryConfig;
            simpleConfig?: SimpleTelemetryConfig;
        };
        createTelemetryConfig(config: ProtoTelemetryConfig): ProtoTelemetryConfig;
        createSimpleTelemetryConfig(config: SimpleTelemetryConfig): SimpleTelemetryConfig;
        createLoggerConfig(config: Record<any, any>): Record<any, any>;
        createTracerConfig(config: Record<any, any>): Record<any, any>;
        createMetricsConfig(config: Record<any, any>): Record<any, any>;
        createMetricConfig(config: TelemetryMetricConfig): PbBaseType;
        createRecordMetricRequest(request: RecordMetricRequest): PbBaseType;
        createLogMessageRequest(request: LogMessageRequest): PbBaseType;
        unpackDequeueSpanTracesResponse(obj: PbBaseType): DequeueSpanTracesResponse;
        createSpanEvent(event: Record<any, any>): Record<any, any>;
        createSpanData(span: Record<any, any>): Record<any, any>;
    };
    graph: {
        createEnvRequest(options?: CreateEnvRequestOptions): PbBaseType;
        createGraphRequest(options: CreateGraphRequestOptions): PbBaseType;
        createStartExecutionRequest(options: StartExecutionRequestOptions): PbBaseType;
    };
    of: typeof getType;
    any(value: Record<string, any>): PbBaseType;
    unpackAny(obj: PbBaseType): any;
    text(value: string): PbBaseType;
    unpackText(obj: PbBaseType): string;
    /**
     * Create an Audio message from data and sample rate
     * @param {Uint8Array|Array} data - The audio data
     * @param {number} sampleRate - The sample rate in Hz
     * @returns {Object} Object with _pb field containing serialized bytes
     */
    audio(data: number[] | Float32Array, sampleRate: number): PbBaseType;
    multimodalContent(content: {
        text?: PbBaseType;
        audio?: PbBaseType;
    }): PbBaseType;
    unpackMultimodalContent(obj: PbBaseType): {
        text?: string;
        audio?: {
            data: Float32Array;
            sampleRate: number;
        };
    };
    unpackAudio(obj: any): {
        data: Float32Array<ArrayBufferLike>;
        sampleRate: any;
    };
    /**
     * Create a TTSRequest message with streaming
     * @param ttsRequest
     * @param {Generator} streamGenerator - Generator function that yields text
     *     messages
     * @returns {Object} Object with _pb field containing serialized bytes and
     *     _stream field
     */
    ttsRequest(ttsRequest: TTSRequest, streamGenerator: RuntimeInputStream<string>): {
        _pb: Uint8Array<ArrayBufferLike>;
        _stream: RuntimeInputStream<string>;
    };
    unpackTTSOutput(obj: PbBaseType): {
        text: string;
        audio: {
            data: Buffer;
            sampleRate: number;
        };
    };
    json(value: any): PbBaseType;
    unpackJson(obj: PbBaseType): any;
    customData(value: Record<string, any>, schema?: Record<string, any>): PbBaseType;
    unpackCustomData(obj: PbBaseType): {
        value: Record<string, any>;
        schema?: Record<string, any>;
    };
    safetyResult(text: string, isSafe: boolean): PbBaseType;
    unpackSafetyResult(obj: PbBaseType): {
        text: any;
        isSafe: any;
    };
    classificationResult(classes: string[]): PbBaseType;
    unpackClassificationResult(obj: PbBaseType): {
        classes: any;
    };
    goalAdvancementResponse(activatedGoals: string[], completedGoals: string[], currentGoals: string[], beliefState: string): PbBaseType;
    unpackGoalAdvancement(obj: PbBaseType): {
        activatedGoals: any;
        completedGoals: any;
        currentGoals: any;
        beliefState: any;
    };
    goalAdvancementRequest(request: any): PbBaseType;
    unpackGoalAdvancementRequest(obj: PbBaseType): any;
    knowledgeRecords(records: string[]): PbBaseType;
    unpackKnowledgeRecords(obj: PbBaseType): {
        records: any;
    };
    matchedIntents(intents: Array<{
        intentName: string;
        score: number;
    }>): PbBaseType;
    unpackMatchedIntents(obj: PbBaseType): {
        intents: any;
    };
    matchedKeywords(keywords: Array<{
        groupName: string;
        keyword: string;
    }>): PbBaseType;
    unpackMatchedKeywords(obj: PbBaseType): {
        keywords: any;
    };
    toolCallRequest(toolCalls: Array<{
        id: string;
        name: string;
        args: string;
    }>): PbBaseType;
    unpackToolCallRequest(obj: PbBaseType): {
        toolCalls: any;
    };
    toolCallResponse(results: Array<{
        result: string;
    }>): PbBaseType;
    unpackToolCallResponse(obj: PbBaseType): ToolCallResponse;
    toolCallResult(result: string): PbBaseType;
    unpackToolCallResult(obj: PbBaseType): {
        toolCallId: any;
        result: any;
    };
    listToolsResponse(tools: Array<{
        name: string;
        description: string;
        properties?: string;
    }>): PbBaseType;
    unpackListToolsResponse(obj: PbBaseType): {
        tools: any;
    };
    llmChatRequest(input: LLMChatRequest): PbBaseType;
    unpackLLMChatRequest(obj: PbBaseType): {
        messages: any;
        tools: any;
        responseFormat: any;
        toolChoice: any;
        textGenerationConfig: any;
    };
    llmChatRoutingRequest(input: any): PbBaseType;
    unpackLLMChatRoutingRequest(obj: PbBaseType): LLMChatRoutingRequest;
    llmChatResponse: typeof encodeLLMChatResponse;
    unpackLLMChatResponse(obj: PbBaseType): LLMChatResponseData;
    llmCompletionResponse(content: string, stream?: boolean): PbBaseType;
    unpackLLMCompletionResponse(obj: PbBaseType): any;
    contentData(contentData: ContentData): PbBaseType;
    unpackContentData(obj: PbBaseType): any;
    graphError(code: number, message: string): PbBaseType;
    unpackGraphError(obj: PbBaseType): {
        code: any;
        message: any;
    };
    /**
     * Create a DataStreamWithMetadata message with metadata
     * @param {Record<string, any>} metadata - The metadata object (will be
     *     converted to google.protobuf.Struct)
     * @returns {PbBaseType} Object with _pb field containing serialized
     *     DataContainer bytes
     */
    dataStreamWithMetadata(metadata?: Record<string, any>): PbBaseType;
    /**
     * Unpack a DataStreamWithMetadata message
     * @param {PbBaseType} obj - Object with _pb field containing serialized
     *     DataContainer bytes
     * @returns {Record<string, any>} The metadata object
     */
    unpackDataStreamWithMetadata(obj: PbBaseType): Record<string, any>;
};
