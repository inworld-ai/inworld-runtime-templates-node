/**
 * Protobuf helper functions for primitives implementation.
 * This module provides TypeScript-friendly wrappers for packing/unpacking
 * protobuf messages used by the N-API addon primitives.
 */
/**
 * Main PbHelper export that provides access to all category-specific helpers.
 *
 * Usage:
 * - PbHelper.Embeddings.createTextEmbedderCreationConfig(config)
 * - PbHelper.Speech.createSTTCreationConfig(config)
 * - PbHelper.LLM.createLLMCreationConfig(config)
 */
export declare const PbHelper: {
    Embeddings: {
        unpackEmbedding(obj: import("./pb_types").PbBaseType): import("../common/api/library").EmbedResponse;
        unpackEmbeddingBatch(obj: import("./pb_types").PbBaseType): import("../common/api/library").EmbedBatchResponse;
        createTextBatch(texts: string[]): import("./pb_types").PbBaseType;
        createTextEmbedRequest(request: import("../common/api/library").EmbedRequest): import("./pb_types").PbBaseType;
        createTextEmbedderCreationConfig(config: Record<any, any>): import("./pb_types").PbBaseType;
    };
    Speech: {
        createSTTCreationConfig(config: Record<any, any>): import("./pb_types").PbBaseType;
        createStreamingSTTCreationConfig(config: Record<any, any>): import("./pb_types").PbBaseType;
        createStreamRecognizeSpeechRequest(request?: {
            config?: {
                languageCode?: string;
                silenceThresholdMs?: number;
            };
            credentials?: Record<string, any>;
        }): import("./pb_types").PbBaseType;
        createAudioFrame(audioFrame: Record<any, any>): import("./pb_types").PbBaseType;
        createTTSCreationConfig(config: Record<any, any>): import("./pb_types").PbBaseType;
        createVADCreationConfig(config: Record<any, any>): import("./pb_types").PbBaseType;
        createAECFilterCreationConfig(config: Record<any, any>): import("./pb_types").PbBaseType;
        createTurnDetectorCreationConfig(config: Record<any, any>): import("./pb_types").PbBaseType;
        createSynthesizeSpeechRequest(request: {
            voice: any;
            text: string;
            config?: any;
        }): import("./pb_types").PbBaseType;
        createRecognizeSpeechRequest(audioChunk: any, config?: any): import("./pb_types").PbBaseType;
        createDetectVoiceActivityRequest(audioChunk: any, config?: any): import("./pb_types").PbBaseType;
        createDetectTurnCompletionRequest(audioChunk: any, config?: any): import("./pb_types").PbBaseType;
        createFilterAudioRequest(request: any): import("./pb_types").PbBaseType;
        unpackAudioFrame(obj: import("./pb_types").PbBaseType): import("../primitives/speech").AudioChunk;
        unpackStreamSpeechRecognitionResponse(obj: import("./pb_types").PbBaseType): {
            text: string;
            isFinal: boolean;
        };
        unpackTurnPrediction(obj: import("./pb_types").PbBaseType): any;
        unpackText(obj: import("./pb_types").PbBaseType): string;
        createDetectSilenceRequest(audioBytes: Buffer, sampleRate: number, config?: import("../primitives/speech").VADConfig): import("./pb_types").PbBaseType;
    };
    LLM: {
        createLLMCreationConfig(config: Record<any, any>): import("./pb_types").PbBaseType;
        createGenerateContentRequest(content: string, config: any): import("./pb_types").PbBaseType;
        createGenerateContentChatRequest(messages: any[], options: any): import("./pb_types").PbBaseType;
        unpackLLMGenerationResult(obj: import("./pb_types").PbBaseType): import("../common/api/graphs").LLMCompletionResponse;
    };
    NLU: {
        createNERCreationConfig(config: Record<any, any>): import("./pb_types").PbBaseType;
        unpackExtractEntitiesResponse(obj: import("./pb_types").PbBaseType): any[];
        unpackEntityMatch(obj: import("./pb_types").PbBaseType): any;
        unpackEntityMatches(objArray: any[]): any[];
        createKeywordGroup(group: {
            keywords: string[];
            name: string;
        }): import("./pb_types").PbBaseType;
        createTextClassifierCreationConfig(config: Record<any, any>): import("./pb_types").PbBaseType;
        createClassifyTextRequest(request: any): import("./pb_types").PbBaseType;
        unpackTextClassifierResponse(obj: import("./pb_types").PbBaseType): {
            classes: {
                className: string;
                confidence: number;
            }[];
        };
        unpackKeywordMatcherResponse(obj: import("./pb_types").PbBaseType): {
            matches: {
                groupName: string;
                keyword: string;
            }[];
        };
    };
    Knowledge: {
        createKnowledgeCreationConfig(config: Record<any, any>): import("./pb_types").PbBaseType;
        createCompileKnowledgeRequest(knowledgeId: string, records: any[]): import("./pb_types").PbBaseType;
        createGetKnowledgeRequest(ids: string[], searchQuery: string): import("./pb_types").PbBaseType;
        unpackKnowledgeRecords(obj: import("./pb_types").PbBaseType): import("../common/api/graphs").KnowledgeRecords;
        createCompileKnowledgeFromFileRequest(knowledgeId: string, filePath: string): import("./pb_types").PbBaseType;
    };
    MCP: {
        createMCPClientCreationConfig(config: Record<any, any>): import("./pb_types").PbBaseType;
        unpackToolList(obj: import("./pb_types").PbBaseType): import("../primitives/mcp").ToolList;
        createToolCall(toolCallId: string, name: string, args: string): import("./pb_types").PbBaseType;
        unpackToolCallResult(obj: import("./pb_types").PbBaseType): import("../common/export").ToolCallResult;
    };
    Platform: {
        unpackDevice(obj: import("./pb_types").PbBaseType): import("../common/api/library").Device;
    };
    Telemetry: {
        createConfigureTelemetryRequest(config: {
            config?: import("../common/api/library").TelemetryConfig;
            simpleConfig?: import("../common/api/library").SimpleTelemetryConfig;
        }): import("./pb_types").PbBaseType;
        unpackConfigureTelemetryRequest(obj: import("./pb_types").PbBaseType): {
            config?: import("../common/api/library").TelemetryConfig;
            simpleConfig?: import("../common/api/library").SimpleTelemetryConfig;
        };
        createTelemetryConfig(config: import("../common/api/library").TelemetryConfig): import("../common/api/library").TelemetryConfig;
        createSimpleTelemetryConfig(config: import("../common/api/library").SimpleTelemetryConfig): import("../common/api/library").SimpleTelemetryConfig;
        createLoggerConfig(config: Record<any, any>): Record<any, any>;
        createTracerConfig(config: Record<any, any>): Record<any, any>;
        createMetricsConfig(config: Record<any, any>): Record<any, any>;
        createMetricConfig(config: import("../common/api/library").MetricConfig): import("./pb_types").PbBaseType;
        createRecordMetricRequest(request: import("../common/api/library").RecordMetricRequest): import("./pb_types").PbBaseType;
        createLogMessageRequest(request: import("../common/api/library").LogMessageRequest): import("./pb_types").PbBaseType;
        unpackDequeueSpanTracesResponse(obj: import("./pb_types").PbBaseType): import("../common/api/library").DequeueSpanTracesResponse;
        createSpanEvent(event: Record<any, any>): Record<any, any>;
        createSpanData(span: Record<any, any>): Record<any, any>;
    };
};
