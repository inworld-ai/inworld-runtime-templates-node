"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PbType = exports.graphMethods = exports.telemetryMethods = exports.platformMethods = exports.mcpMethods = exports.knowledgeMethods = exports.nluMethods = exports.llmMethods = exports.speechMethods = exports.embeddingsMethods = exports.isPbStreamBaseType = exports.isPbBaseType = void 0;
const fs_1 = __importDefault(require("fs"));
const protobufjs_1 = __importDefault(require("protobufjs"));
const graphs_1 = require("../common/api/graphs");
const descriptors_json_1 = __importDefault(require("./generated/descriptors.json"));
const pb_bindings_1 = require("./generated/pb-bindings");
const pb_types_1 = require("./pb_types");
const root = protobufjs_1.default.Root.fromJSON(descriptors_json_1.default);
const { DataContainer, DataCustomData, DataStreamWithMetadata, Text, Audio, MultimodalContent, Error, TTSRequest, GoogleProtobufAny, GoogleStruct, GoogleListValue, GoogleValue, SafetyResult, MatchedKeywords, ClassificationResult, KnowledgeRecords, MatchedIntents, GoalAdvancementResponse, GoalAdvancementRequest, Json, ToolCallRequest, ListToolsResponse, LLMChatRequest, LLMChatRoutingRequest, LLMChatResponse, LLMCompletionResponse, ToolCallResult, ToolCallResponse, KeywordMatch, IntentMatch, ToolCall, Tool, LLMMessage, ContentData, EmbedBatchRequest, EmbedBatchResponse, EmbedResponse, ConfigsEmbedRequest, TextEmbedderCreationConfig, AudioFrame, STTCreationConfig, StreamingSTTCreationConfig, TTSCreationConfig, VADCreationConfig, AECFilterCreationConfig, TurnDetectorCreationConfig, SynthesizeSpeechRequest, RecognizeSpeechRequest, DetectSilenceRequest, DetectVoiceActivityRequest, VoiceActivityDetectionConfig, DetectTurnCompletionRequest, FilterAudioRequest, TurnPrediction, LLMCreationConfig, GenerateContentRequest, GenerateContentChatRequest, NERCreationConfig, EntityMatch, ExtractEntitiesResponse, TextClassifierCreationConfig, ClassifyTextRequest, TextClassifierResponse, KeywordMatcherResponse, KeywordGroup, KnowledgeCreationConfig, KnowledgeCompilationRequest, KnowledgeGetRequest, File, Device, MCPClientCreationConfig, ToolList, ConfigsConfigureTelemetryRequest, ConfigsTelemetryConfig, ConfigsSimpleTelemetryConfig, ConfigsLoggerConfig, ConfigsTracerConfig, ConfigsMetricsConfig, ConfigsMetricConfig, ConfigsRecordMetricRequest, ConfigsCounterMetric, ConfigsGaugeMetric, ConfigsHistogramMetric, ConfigsLogMessageRequest, ConfigsDequeueSpanTracesResponse, ConfigsSpanData, ConfigsSpanEvent, ConfigsCreateEnvRequest, ConfigsGraphCreationConfig, ConfigsFeatureFlagConfig, ConfigsStreamRecognizeSpeechRequest, ConfigsStreamSpeechRecognitionConfig, ConfigsStreamSpeechRecognitionResponse, ConfigsCreateGraphRequest, ConfigsStartExecutionRequest, ConfigsExecutionContext, ConfigsUserContext, ConfigsCredentials, ConfigsThreadPoolConfig, } = (0, pb_bindings_1.createProtoTypeBindings)(root);
exports.isPbBaseType = pb_types_1.isPbBaseType;
/**
 * Helper function to convert numeric timeout (milliseconds) to Duration object
 * @param {number} timeoutMs - Timeout in milliseconds
 * @returns {Object} Duration object with seconds and nanos fields
 */
function convertTimeoutToDuration(timeoutMs) {
    const seconds = Math.floor(timeoutMs / 1000);
    const nanos = (timeoutMs % 1000) * 1000000;
    return { seconds, nanos };
}
/**
 * Helper function to convert defaultTimeout fields in config objects
 * @param {Record<any, any>} config - Configuration object that may contain
 *     defaultTimeout
 * @returns {Record<any, any>} Processed configuration with converted timeouts
 */
function processDefaultTimeout(config) {
    var _a, _b, _c, _d, _f;
    const processedConfig = Object.assign({}, config);
    const normalizeTimeout = (timeout) => {
        if (typeof timeout === 'number') {
            // Convert milliseconds to Duration
            return convertTimeoutToDuration(timeout);
        }
        else if (typeof timeout === 'string') {
            // Parse protobuf Duration string format (e.g., "60s", "1.5s")
            // Format: "<seconds>s" or "<seconds>.<fractional_seconds>s"
            const match = timeout.match(/^(\d+(?:\.\d+)?)s$/);
            if (match) {
                const totalSeconds = parseFloat(match[1]);
                const seconds = Math.floor(totalSeconds);
                const nanos = Math.round((totalSeconds - seconds) * 1e9);
                return { seconds, nanos };
            }
            // If it doesn't match the expected format, return as-is and let protobuf
            // handle it
            return timeout;
        }
        else if (typeof timeout === 'object' && timeout !== null) {
            // Handle { seconds: number } format - ensure nanos field exists
            return {
                seconds: timeout.seconds || 0,
                nanos: timeout.nanos || 0,
            };
        }
        return timeout;
    };
    // Handle remoteConfig.defaultTimeout
    if (((_a = processedConfig.remoteConfig) === null || _a === void 0 ? void 0 : _a.defaultTimeout) !== undefined) {
        processedConfig.remoteConfig.defaultTimeout = normalizeTimeout(processedConfig.remoteConfig.defaultTimeout);
    }
    // Handle httpConfig.defaultTimeout (for MCP)
    if (((_b = processedConfig.httpConfig) === null || _b === void 0 ? void 0 : _b.defaultTimeout) !== undefined) {
        processedConfig.httpConfig.defaultTimeout = normalizeTimeout(processedConfig.httpConfig.defaultTimeout);
    }
    // Handle paragonConfig.defaultTimeout (for MCP)
    if (((_c = processedConfig.paragonConfig) === null || _c === void 0 ? void 0 : _c.defaultTimeout) !== undefined) {
        processedConfig.paragonConfig.defaultTimeout = normalizeTimeout(processedConfig.paragonConfig.defaultTimeout);
    }
    // Handle nested sessionConfig (for MCP primitives)
    if (processedConfig.sessionConfig) {
        if (((_d = processedConfig.sessionConfig.httpConfig) === null || _d === void 0 ? void 0 : _d.defaultTimeout) !== undefined) {
            processedConfig.sessionConfig.httpConfig.defaultTimeout =
                normalizeTimeout(processedConfig.sessionConfig.httpConfig.defaultTimeout);
        }
        if (((_f = processedConfig.sessionConfig.paragonConfig) === null || _f === void 0 ? void 0 : _f.defaultTimeout) !== undefined) {
            processedConfig.sessionConfig.paragonConfig.defaultTimeout =
                normalizeTimeout(processedConfig.sessionConfig.paragonConfig.defaultTimeout);
        }
    }
    return processedConfig;
}
function structFromObject(obj) {
    if (obj === undefined) {
        return undefined;
    }
    return jsObjectToStruct(obj);
}
/**
 * Convert a protobuf Value to a JavaScript value (recursive)
 */
function protobufValueToJsValue(val) {
    if (!val)
        return undefined;
    if (val.stringValue !== undefined)
        return val.stringValue;
    if (val.numberValue !== undefined)
        return val.numberValue;
    if (val.boolValue !== undefined)
        return val.boolValue;
    if (val.nullValue !== undefined)
        return null;
    if (val.structValue)
        return protobufStructToJsObject(val.structValue);
    if (val.listValue && val.listValue.values) {
        return val.listValue.values.map(protobufValueToJsValue);
    }
    return val;
}
/**
 * Convert a protobuf Struct to a plain JavaScript object
 */
function protobufStructToJsObject(structObj) {
    if (!structObj) {
        return {};
    }
    // If it has toJSON, use that (protobuf.js auto-conversion)
    let valueObj = structObj;
    if (typeof structObj.toJSON === 'function') {
        valueObj = structObj.toJSON();
    }
    // Check if it's a Struct with fields property
    if (typeof valueObj === 'object' && valueObj !== null) {
        if (valueObj.fields && typeof valueObj.fields === 'object') {
            // Convert Struct fields to plain object
            const fields = valueObj.fields;
            const plainObj = {};
            for (const key in fields) {
                if (Object.prototype.hasOwnProperty.call(fields, key)) {
                    plainObj[key] = protobufValueToJsValue(fields[key]);
                }
            }
            return plainObj;
        }
        else {
            // Already a plain object (protobuf.js auto-conversion)
            return valueObj;
        }
    }
    return {};
}
function structToObject(struct) {
    if (!struct) {
        return undefined;
    }
    return protobufStructToJsObject(struct);
}
function jsObjectToStruct(obj) {
    if (!isPlainObject(obj)) {
        return undefined;
    }
    const fields = {};
    for (const [key, val] of Object.entries(obj)) {
        const structValue = jsValueToStructValue(val);
        if (structValue) {
            fields[key] = structValue;
        }
    }
    return GoogleStruct.create({ fields });
}
function jsValueToStructValue(value) {
    if (value === null) {
        return GoogleValue.create({ nullValue: 0 });
    }
    if (value === undefined) {
        return undefined;
    }
    if (typeof value === 'boolean') {
        return GoogleValue.create({ boolValue: value });
    }
    if (typeof value === 'number') {
        return GoogleValue.create({ numberValue: value });
    }
    if (typeof value === 'string') {
        return GoogleValue.create({ stringValue: value });
    }
    if (Array.isArray(value)) {
        const listValues = value
            .map((item) => jsValueToStructValue(item))
            .filter((item) => item !== undefined);
        return GoogleValue.create({
            listValue: GoogleListValue.create({
                values: listValues,
            }),
        });
    }
    if (isPlainObject(value)) {
        return GoogleValue.create({
            structValue: jsObjectToStruct(value),
        });
    }
    return undefined;
}
const isPbStreamBaseType = (value) => {
    return (value !== null &&
        typeof value === 'object' &&
        '_pb' in value &&
        '_stream' in value);
};
exports.isPbStreamBaseType = isPbStreamBaseType;
/**
 * Get the type of a protobuf object
 * @param {Object} obj - Object with _pb field containing serialized bytes
 * @returns {string} The type of the message ('text', 'error', etc.) or null if
 *     unknown
 */
function getType(obj) {
    if (!obj || !obj._pb) {
        return null;
    }
    try {
        const container = DataContainer.decode(obj._pb);
        if (container.text)
            return 'text';
        if (container.audio)
            return 'audio';
        if (container.ttsOutput)
            return 'ttsOutput';
        if (container.safetyResult)
            return 'safetyResult';
        if (container.matchedKeywords)
            return 'matchedKeywords';
        if (container.matchedPhrases)
            return 'matchedPhrases';
        if (container.classificationResult)
            return 'classificationResult';
        if (container.knowledgeRecords)
            return 'knowledgeRecords';
        if (container.error)
            return 'error';
        if (container.matchedIntents)
            return 'matchedIntents';
        if (container.goalAdvancementResponse)
            return 'goalAdvancementResponse';
        if (container.goalAdvancementRequest)
            return 'goalAdvancementRequest';
        if (container.customData)
            return 'customData';
        if (container.json)
            return 'json';
        if (container.toolCallRequest)
            return 'toolCallRequest';
        if (container.listToolsResponse)
            return 'listToolsResponse';
        if (container.llmChatRequest)
            return 'llmChatRequest';
        if (container.llmChatRoutingRequest)
            return 'llmChatRoutingRequest';
        if (container.llmChatResponse)
            return 'llmChatResponse';
        if (container.llmCompletionRequest)
            return 'llmCompletionRequest';
        if (container.llmCompletionResponse)
            return 'llmCompletionResponse';
        if (container.toolCallResult)
            return 'toolCallResult';
        if (container.toolCallResponse)
            return 'toolCallResponse';
        if (container.ttsRequest)
            return 'ttsRequest';
        if (container.sttRequest)
            return 'sttRequest';
        if (container.googleSerperApiSearchRequest)
            return 'googleSerperApiSearchRequest';
        if (container.googleSerperApiSearchResponse)
            return 'googleSerperApiSearchResponse';
        if (container.multiModalContent)
            return 'multiModalContent';
        if (container.contentData)
            return 'contentData';
        if (container.dataStreamWithMetadata)
            return 'dataStreamWithMetadata';
        if (container.any)
            return 'any';
        return 'unknown';
    }
    catch (_error) {
        return null;
    }
}
/**
 * Helper function to validate that an object has a _pb field
 * @param obj - The object to validate
 * @throws Error if the object is missing or doesn't have a _pb field
 */
function validatePbObject(obj) {
    if (!obj || !obj._pb) {
        throw new global.Error('Object must have _pb field');
    }
}
/**
 * Helper function to handle common error cases in unpack methods
 * @param container - The decoded DataContainer
 * @param obj - The original object for type detection
 * @param expectedType - The expected type name for error messages
 */
function handleUnpackError(container, obj, expectedType) {
    if (container.error) {
        throw new global.Error(`Error: ${container.error.code}: ${container.error.message}`);
    }
    const actualType = getType(obj);
    throw new global.Error(`Expected ${expectedType} message in DataContainer, but found: ${actualType || 'unknown'}`);
}
/**
 * Convert numeric finish reason from protobuf to TypeScript enum string
 * Runtime pb produces integer values for proto enums
 * @param value - Numeric or string finish reason value
 * @returns String representation of the finish reason, or undefined for
 *     unspecified
 */
function convertFinishReason(value) {
    if (value === undefined)
        return undefined;
    if (typeof value === 'number') {
        switch (value) {
            case 0: {
                return undefined;
            }
            case 1: {
                return 'stop';
            }
            case 2: {
                return 'length';
            }
            case 3: {
                return 'content_filter';
            }
            case 4: {
                return 'tool_call';
            }
            default: {
                return undefined;
            }
        }
    }
    return value;
}
/**
 * Convert protobuf Long object to JavaScript number
 * Protobuf.js encodes int64/uint64 as Long objects with toNumber() method
 * @param value - Value that might be a number, Long object, or undefined
 * @returns Number value, or 0 if undefined/null
 */
function convertLongToNumber(value) {
    if (value === null || value === undefined)
        return 0;
    if (typeof value === 'number')
        return value;
    if (typeof value === 'object' && typeof value.toNumber === 'function') {
        return value.toNumber();
    }
    return 0;
}
function encodeLLMChatResponse(contentOrResponse, stream = false, toolCalls) {
    var _a, _b, _c, _d, _f;
    const response = typeof contentOrResponse === 'string'
        ? {
            content: contentOrResponse,
            stream,
            toolCalls,
        }
        : contentOrResponse;
    const toolCallObjs = ((_a = response.toolCalls) === null || _a === void 0 ? void 0 : _a.map((tc) => ToolCall.create({ id: tc.id, name: tc.name, args: tc.args }))) || [];
    const responseMsg = LLMChatResponse.create({
        content: (_b = response.content) !== null && _b !== void 0 ? _b : '',
        stream: (_c = response.stream) !== null && _c !== void 0 ? _c : false,
        toolCalls: toolCallObjs,
        finishReason: response.finishReason,
        usage: response.usage
            ? {
                promptTokens: (_d = response.usage.promptTokens) !== null && _d !== void 0 ? _d : 0,
                completionTokens: (_f = response.usage.completionTokens) !== null && _f !== void 0 ? _f : 0,
            }
            : undefined,
        metadata: response.metadata,
        modelName: response.modelName,
    });
    const container = DataContainer.create({ llmChatResponse: responseMsg });
    const bytes = DataContainer.encode(container).finish();
    return { _pb: bytes };
}
exports.embeddingsMethods = {
    unpackEmbedding(obj) {
        validatePbObject(obj);
        const buffer = Buffer.isBuffer(obj._pb) ? obj._pb : Buffer.from(obj._pb);
        const embedding = EmbedResponse.decode(buffer);
        return {
            embedding: Array.from(embedding.embedding || []),
        };
    },
    unpackEmbeddingBatch(obj) {
        validatePbObject(obj);
        const buffer = Buffer.isBuffer(obj._pb) ? obj._pb : Buffer.from(obj._pb);
        const batch = EmbedBatchResponse.decode(buffer);
        return {
            embeddings: (batch.embeddings || []).map((emb) => ({
                embedding: Array.from(emb.embedding || []),
            })),
        };
    },
    createTextBatch(texts) {
        const batchMsg = EmbedBatchRequest.create({ texts });
        const bytes = EmbedBatchRequest.encode(batchMsg).finish();
        return { _pb: bytes };
    },
    createTextEmbedRequest(request) {
        const requestMsg = ConfigsEmbedRequest.create(request);
        const bytes = ConfigsEmbedRequest.encode(requestMsg).finish();
        return { _pb: bytes };
    },
    createTextEmbedderCreationConfig(config) {
        const processedConfig = processDefaultTimeout(config);
        const protoConfig = TextEmbedderCreationConfig.create(processedConfig);
        const bytes = TextEmbedderCreationConfig.encode(protoConfig).finish();
        return { _pb: bytes };
    },
};
exports.speechMethods = {
    createSTTCreationConfig(config) {
        const processedConfig = processDefaultTimeout(config);
        const protoConfig = STTCreationConfig.create(processedConfig);
        const bytes = STTCreationConfig.encode(protoConfig).finish();
        return { _pb: bytes };
    },
    createStreamingSTTCreationConfig(config) {
        const processedConfig = processDefaultTimeout(config);
        const protoConfig = StreamingSTTCreationConfig.create(processedConfig);
        const bytes = StreamingSTTCreationConfig.encode(protoConfig).finish();
        return { _pb: bytes };
    },
    createStreamRecognizeSpeechRequest(request) {
        const payload = {};
        if (request === null || request === void 0 ? void 0 : request.config) {
            const configPayload = {};
            if (request.config.languageCode) {
                configPayload.speechConfig = {
                    language: request.config.languageCode,
                };
            }
            const silenceThreshold = request.config.silenceThresholdMs;
            if (typeof silenceThreshold === 'number' &&
                Number.isFinite(silenceThreshold)) {
                configPayload.silenceThresholdMs = silenceThreshold;
            }
            if (Object.keys(configPayload).length > 0) {
                payload.config =
                    ConfigsStreamSpeechRecognitionConfig.create(configPayload);
            }
        }
        if (request === null || request === void 0 ? void 0 : request.credentials) {
            payload.credentials = ConfigsCredentials.create(request.credentials);
        }
        const requestMsg = ConfigsStreamRecognizeSpeechRequest.create(payload);
        const bytes = ConfigsStreamRecognizeSpeechRequest.encode(requestMsg).finish();
        return { _pb: bytes };
    },
    createAudioFrame(audioFrame) {
        if (!audioFrame || !audioFrame.data) {
            throw new global.Error('Audio frame data is required');
        }
        const payload = Object.assign({}, audioFrame);
        const { data } = audioFrame;
        if (Buffer.isBuffer(data)) {
            payload.data = data;
        }
        else if (ArrayBuffer.isView(data)) {
            // Handles Float32Array, Uint8Array, etc. without extra copies.
            payload.data = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
        }
        else if (data instanceof ArrayBuffer) {
            payload.data = Buffer.from(data);
        }
        else if (Array.isArray(data)) {
            const float32 = new Float32Array(data.length);
            float32.set(data);
            payload.data = Buffer.from(float32.buffer);
        }
        else {
            payload.data = Buffer.from(data);
        }
        const audioFrameMsg = AudioFrame.create(payload);
        const bytes = AudioFrame.encode(audioFrameMsg).finish();
        return { _pb: bytes };
    },
    createTTSCreationConfig(config) {
        const processedConfig = processDefaultTimeout(config);
        const protoConfig = TTSCreationConfig.create(processedConfig);
        const bytes = TTSCreationConfig.encode(protoConfig).finish();
        return { _pb: bytes };
    },
    createVADCreationConfig(config) {
        const protoConfig = VADCreationConfig.create(config);
        const bytes = VADCreationConfig.encode(protoConfig).finish();
        return { _pb: bytes };
    },
    createAECFilterCreationConfig(config) {
        const protoConfig = AECFilterCreationConfig.create(config);
        const bytes = AECFilterCreationConfig.encode(protoConfig).finish();
        return { _pb: bytes };
    },
    createTurnDetectorCreationConfig(config) {
        const protoConfig = TurnDetectorCreationConfig.create(config);
        const bytes = TurnDetectorCreationConfig.encode(protoConfig).finish();
        return { _pb: bytes };
    },
    createSynthesizeSpeechRequest(request) {
        const requestMsg = SynthesizeSpeechRequest.create({
            voice: request.voice,
            text: request.text,
            config: request.config,
        });
        const bytes = SynthesizeSpeechRequest.encode(requestMsg).finish();
        return { _pb: bytes };
    },
    createRecognizeSpeechRequest(audioChunk, config = null) {
        // Convert audio data to bytes
        let dataBuffer;
        if (audioChunk.data instanceof Float32Array) {
            dataBuffer = Buffer.from(audioChunk.data.buffer, audioChunk.data.byteOffset, audioChunk.data.byteLength);
        }
        else {
            dataBuffer = Buffer.from(audioChunk.data);
        }
        const audioFrameMsg = AudioFrame.create({
            data: dataBuffer,
            sampleRate: audioChunk.sampleRate,
        });
        const requestMsg = RecognizeSpeechRequest.create({
            audioChunk: audioFrameMsg,
            config,
        });
        const bytes = RecognizeSpeechRequest.encode(requestMsg).finish();
        return { _pb: bytes };
    },
    createDetectVoiceActivityRequest(audioChunk, config = null) {
        // Convert audio data to Buffer (protobuf bytes type)
        let dataBuffer;
        if (audioChunk.data instanceof Float32Array) {
            dataBuffer = Buffer.from(audioChunk.data.buffer, audioChunk.data.byteOffset, audioChunk.data.byteLength);
        }
        else {
            dataBuffer = Buffer.from(audioChunk.data);
        }
        // Pass Buffer directly - protobuf handles bytes type efficiently
        const audioFrameMsg = AudioFrame.create({
            data: dataBuffer,
            sampleRate: audioChunk.sampleRate,
        });
        const requestMsg = DetectVoiceActivityRequest.create({
            audioChunk: audioFrameMsg,
            config,
        });
        const bytes = DetectVoiceActivityRequest.encode(requestMsg).finish();
        return { _pb: bytes };
    },
    createDetectTurnCompletionRequest(audioChunk, config = null) {
        // Convert audio data to Buffer (protobuf bytes type)
        let dataBuffer;
        if (audioChunk.data instanceof Float32Array) {
            dataBuffer = Buffer.from(audioChunk.data.buffer, audioChunk.data.byteOffset, audioChunk.data.byteLength);
        }
        else {
            dataBuffer = Buffer.from(audioChunk.data);
        }
        // Pass Buffer directly - protobuf handles bytes type efficiently
        const audioFrameMsg = AudioFrame.create({
            data: dataBuffer,
            sampleRate: audioChunk.sampleRate,
        });
        const requestMsg = DetectTurnCompletionRequest.create({
            audioChunk: audioFrameMsg,
            config,
        });
        const bytes = DetectTurnCompletionRequest.encode(requestMsg).finish();
        return { _pb: bytes };
    },
    createFilterAudioRequest(request) {
        // Convert microphone audio data to Buffer (protobuf bytes type)
        let micDataBuffer;
        if (request.microphoneChunk.data instanceof Float32Array) {
            micDataBuffer = Buffer.from(request.microphoneChunk.data.buffer, request.microphoneChunk.data.byteOffset, request.microphoneChunk.data.byteLength);
        }
        else {
            micDataBuffer = Buffer.from(request.microphoneChunk.data);
        }
        // Convert speakers audio data to Buffer (protobuf bytes type)
        let speakerDataBuffer;
        if (request.speakersChunk.data instanceof Float32Array) {
            speakerDataBuffer = Buffer.from(request.speakersChunk.data.buffer, request.speakersChunk.data.byteOffset, request.speakersChunk.data.byteLength);
        }
        else {
            speakerDataBuffer = Buffer.from(request.speakersChunk.data);
        }
        // Pass Buffers directly - protobuf handles bytes type efficiently
        const micFrameMsg = AudioFrame.create({
            data: micDataBuffer,
            sampleRate: request.microphoneChunk.sampleRate,
        });
        const speakerFrameMsg = AudioFrame.create({
            data: speakerDataBuffer,
            sampleRate: request.speakersChunk.sampleRate,
        });
        const requestMsg = FilterAudioRequest.create({
            microphoneChunk: micFrameMsg,
            speakersChunk: speakerFrameMsg,
            config: request.config,
        });
        const bytes = FilterAudioRequest.encode(requestMsg).finish();
        return { _pb: bytes };
    },
    unpackAudioFrame(obj) {
        validatePbObject(obj);
        const buffer = Buffer.isBuffer(obj._pb) ? obj._pb : Buffer.from(obj._pb);
        const frame = AudioFrame.decode(buffer);
        // Convert base64 string data back to Float32Array
        const dataBuffer = Buffer.from(frame.data, 'base64');
        const float32Array = new Float32Array(dataBuffer.buffer, dataBuffer.byteOffset, dataBuffer.byteLength / 4);
        return {
            data: float32Array,
            sampleRate: frame.sample_rate || 24000,
        };
    },
    unpackStreamSpeechRecognitionResponse(obj) {
        var _a, _b;
        validatePbObject(obj);
        const buffer = Buffer.isBuffer(obj._pb) ? obj._pb : Buffer.from(obj._pb);
        const response = ConfigsStreamSpeechRecognitionResponse.decode(buffer);
        return {
            text: response.text || '',
            isFinal: (_b = (_a = response.isFinal) !== null && _a !== void 0 ? _a : response.is_final) !== null && _b !== void 0 ? _b : false,
        };
    },
    unpackTurnPrediction(obj) {
        validatePbObject(obj);
        const buffer = Buffer.isBuffer(obj._pb) ? obj._pb : Buffer.from(obj._pb);
        const prediction = TurnPrediction.decode(buffer);
        // Convert status enum to prediction number (0 or 1)
        const predictionValue = prediction.status === 'TURN_COMPLETE' ? 1 : 0;
        return {
            prediction: predictionValue,
            probability: prediction.probability || 0,
        };
    },
    unpackText(obj) {
        // Uses same logic as PbType.unpackText for DataContainer text messages
        validatePbObject(obj);
        const container = DataContainer.decode(obj._pb);
        if (container.text) {
            return container.text.value;
        }
        throw new global.Error('Expected text message in DataContainer');
    },
    createDetectSilenceRequest(audioBytes, sampleRate, config) {
        const voiceActivityDetectionConfig = VoiceActivityDetectionConfig.create({
            speechThreshold: config === null || config === void 0 ? void 0 : config.speechThreshold,
        });
        // Pass Buffer directly - protobuf handles bytes type efficiently
        const request = DetectSilenceRequest.create({
            audioBytes,
            sampleRate,
            config: voiceActivityDetectionConfig,
        });
        const bytes = DetectSilenceRequest.encode(request).finish();
        return { _pb: bytes };
    },
};
exports.llmMethods = {
    createLLMCreationConfig(config) {
        const processedConfig = processDefaultTimeout(config);
        const protoConfig = LLMCreationConfig.create(processedConfig);
        const bytes = LLMCreationConfig.encode(protoConfig).finish();
        return { _pb: bytes };
    },
    createGenerateContentRequest(content, config) {
        const requestMsg = GenerateContentRequest.create({
            content,
            config,
        });
        const bytes = GenerateContentRequest.encode(requestMsg).finish();
        return { _pb: bytes };
    },
    createGenerateContentChatRequest(messages, options) {
        const requestMsg = GenerateContentChatRequest.create({
            messages,
            tools: options.tools,
            toolChoice: options.toolChoice,
            responseFormat: options.responseFormat,
            config: options.config,
        });
        const bytes = GenerateContentChatRequest.encode(requestMsg).finish();
        return { _pb: bytes };
    },
    unpackLLMGenerationResult(obj) {
        validatePbObject(obj);
        const buffer = Buffer.isBuffer(obj._pb) ? obj._pb : Buffer.from(obj._pb);
        const response = LLMCompletionResponse.decode(buffer);
        const result = {
            content: response.content || '',
            stream: response.stream || false,
        };
        if (response.finishReason) {
            result.finishReason = response.finishReason;
        }
        if (response.usage) {
            result.usage = {
                promptTokens: response.usage.promptTokens || 0,
                completionTokens: response.usage.completionTokens || 0,
            };
        }
        if (response.modelName) {
            result.modelName = response.modelName;
        }
        if (response.failedAttempts) {
            result.failedAttempts = response.failedAttempts.map((attempt) => ({
                modelId: attempt.modelId || '',
                errorMessage: attempt.errorMessage || '',
            }));
        }
        return result;
    },
};
exports.nluMethods = {
    createNERCreationConfig(config) {
        const processedConfig = processDefaultTimeout(config);
        const protoConfig = NERCreationConfig.create(processedConfig);
        const bytes = NERCreationConfig.encode(protoConfig).finish();
        return { _pb: bytes };
    },
    unpackExtractEntitiesResponse(obj) {
        // Unpack ExtractEntitiesResponse protobuf message
        validatePbObject(obj);
        const buffer = Buffer.isBuffer(obj._pb) ? obj._pb : Buffer.from(obj._pb);
        const response = ExtractEntitiesResponse.decode(buffer);
        // Return the matches array conforming to EntityMatch + position
        // fields
        return (response.matches || []).map((match) => ({
            entityName: match.entityName || match.entity_name || '', // EntityMatch field
            ruleName: match.ruleName || match.rule_name || '', // EntityMatch field
            text: match.text || '', // EntityMatch field
            start: 0, // Extended field for position
            end: (match.text || '').length, // Extended field for position
        }));
    },
    unpackEntityMatch(obj) {
        // Unpack single entity match
        validatePbObject(obj);
        const buffer = Buffer.isBuffer(obj._pb) ? obj._pb : Buffer.from(obj._pb);
        const entity = EntityMatch.decode(buffer);
        return {
            type: entity.entity_name || entity.entityName, // Map entityName to type
            text: entity.text,
            start: 0, // These aren't in protobuf, set defaults
            end: entity.text.length,
        };
    },
    unpackEntityMatches(objArray) {
        // Entity matches are returned as array of protobuf objects
        return objArray.map((obj) => {
            validatePbObject(obj);
            const buffer = Buffer.isBuffer(obj._pb) ? obj._pb : Buffer.from(obj._pb);
            const entity = EntityMatch.decode(buffer);
            return {
                type: entity.entity_name || entity.entityName, // Map entityName to type
                text: entity.text,
                start: 0, // These aren't in protobuf, set defaults
                end: entity.text.length,
            };
        });
    },
    createKeywordGroup(group) {
        const groupMsg = KeywordGroup.create({
            keywords: group.keywords,
            name: group.name,
        });
        const bytes = KeywordGroup.encode(groupMsg).finish();
        return { _pb: bytes };
    },
    createTextClassifierCreationConfig(config) {
        const processedConfig = processDefaultTimeout(config);
        const protoConfig = TextClassifierCreationConfig.create(processedConfig);
        const bytes = TextClassifierCreationConfig.encode(protoConfig).finish();
        return { _pb: bytes };
    },
    createClassifyTextRequest(request) {
        const requestMsg = ClassifyTextRequest.create(request);
        const bytes = ClassifyTextRequest.encode(requestMsg).finish();
        return { _pb: bytes };
    },
    unpackTextClassifierResponse(obj) {
        validatePbObject(obj);
        const buffer = Buffer.isBuffer(obj._pb) ? obj._pb : Buffer.from(obj._pb);
        const response = TextClassifierResponse.decode(buffer);
        return {
            classes: (response.classes || []).map((cls) => ({
                className: cls.class_name,
                confidence: cls.confidence,
            })),
        };
    },
    unpackKeywordMatcherResponse(obj) {
        validatePbObject(obj);
        const buffer = Buffer.isBuffer(obj._pb) ? obj._pb : Buffer.from(obj._pb);
        const response = KeywordMatcherResponse.decode(buffer);
        return {
            matches: (response.matches || []).map((match) => ({
                groupName: match.group_name,
                keyword: match.keyword,
            })),
        };
    },
};
exports.knowledgeMethods = {
    createKnowledgeCreationConfig(config) {
        const processedConfig = processDefaultTimeout(config);
        const protoConfig = KnowledgeCreationConfig.create(processedConfig);
        const bytes = KnowledgeCreationConfig.encode(protoConfig).finish();
        return { _pb: bytes };
    },
    createCompileKnowledgeRequest(knowledgeId, records) {
        const normalizedRecords = (records === null || records === void 0 ? void 0 : records.map((record) => typeof record === 'string' ? record : JSON.stringify(record))) || [];
        const requestMsg = KnowledgeCompilationRequest.create({
            knowledgeId,
            records: normalizedRecords.length > 0
                ? KnowledgeRecords.create({ records: normalizedRecords })
                : undefined,
        });
        const bytes = KnowledgeCompilationRequest.encode(requestMsg).finish();
        return { _pb: bytes };
    },
    createGetKnowledgeRequest(ids, searchQuery) {
        const requestMsg = KnowledgeGetRequest.create({
            ids,
            query: searchQuery,
        });
        const bytes = KnowledgeGetRequest.encode(requestMsg).finish();
        return { _pb: bytes };
    },
    unpackKnowledgeRecords(obj) {
        validatePbObject(obj);
        const buffer = Buffer.isBuffer(obj._pb) ? obj._pb : Buffer.from(obj._pb);
        const records = KnowledgeRecords.decode(buffer);
        return {
            records: records.records || [],
        };
    },
    createCompileKnowledgeFromFileRequest(knowledgeId, filePath) {
        const fileBuffer = fs_1.default.readFileSync(filePath);
        const fileMsg = File.create({
            content: fileBuffer,
            type: 'TYPE_TXT',
        });
        const requestMsg = KnowledgeCompilationRequest.create({
            knowledgeId,
            file: fileMsg,
        });
        const bytes = KnowledgeCompilationRequest.encode(requestMsg).finish();
        return { _pb: bytes };
    },
};
exports.mcpMethods = {
    createMCPClientCreationConfig(config) {
        const processedConfig = processDefaultTimeout(config);
        const protoConfig = MCPClientCreationConfig.create(processedConfig);
        const bytes = MCPClientCreationConfig.encode(protoConfig).finish();
        return { _pb: bytes };
    },
    unpackToolList(obj) {
        validatePbObject(obj);
        const buffer = Buffer.isBuffer(obj._pb) ? obj._pb : Buffer.from(obj._pb);
        const toolList = ToolList.decode(buffer);
        return {
            tools: (toolList.tools || []).map((tool) => ({
                name: tool.name || '',
                description: tool.description || '',
                properties: JSON.parse(tool.properties || '{}'),
            })),
        };
    },
    createToolCall(toolCallId, name, args) {
        const toolCallMsg = ToolCall.create({
            id: toolCallId,
            name,
            args,
        });
        const bytes = ToolCall.encode(toolCallMsg).finish();
        return { _pb: bytes };
    },
    unpackToolCallResult(obj) {
        validatePbObject(obj);
        const buffer = Buffer.isBuffer(obj._pb) ? obj._pb : Buffer.from(obj._pb);
        const result = ToolCallResult.decode(buffer);
        return {
            result: result.result || '',
            // isError: result.is_error || false,
        };
    },
};
exports.platformMethods = {
    /**
     * Unpack a Device protobuf message to Device
     * @param {PbBaseType} obj - Protobuf object containing Device message
     * @returns {DeviceData} Unpacked device object
     */
    unpackDevice(obj) {
        validatePbObject(obj);
        const buffer = Buffer.isBuffer(obj._pb) ? obj._pb : Buffer.from(obj._pb);
        const device = Device.decode(buffer);
        let deviceType;
        switch (device.type) {
            case 1:
                deviceType = 'CPU';
                break;
            case 2:
                deviceType = 'CUDA';
                break;
            case 3:
                deviceType = 'Metal';
                break;
            case 4:
                deviceType = 'ROCm';
                break;
            default:
                deviceType = 'DEVICE_TYPE_UNSPECIFIED';
                break;
        }
        return {
            type: deviceType,
            index: device.index || 0,
            info: device.info
                ? {
                    name: device.info.name || '',
                    freeMemoryBytes: device.info.freeMemoryBytes || device.info.free_memory_bytes || 0,
                    totalMemoryBytes: device.info.totalMemoryBytes ||
                        device.info.total_memory_bytes ||
                        0,
                    timestamp: device.info.timestamp,
                }
                : undefined,
        };
    },
};
exports.telemetryMethods = {
    createConfigureTelemetryRequest(config) {
        const payload = {};
        if (config.config) {
            payload.config = config.config;
        }
        if (config.simpleConfig) {
            payload.simpleConfig = config.simpleConfig;
        }
        const message = ConfigsConfigureTelemetryRequest.fromObject(payload);
        const bytes = ConfigsConfigureTelemetryRequest.encode(message).finish();
        return { _pb: bytes };
    },
    unpackConfigureTelemetryRequest(obj) {
        validatePbObject(obj);
        const buffer = Buffer.isBuffer(obj._pb) ? obj._pb : Buffer.from(obj._pb);
        const request = ConfigsConfigureTelemetryRequest.decode(buffer);
        const config = request.config
            ? ConfigsTelemetryConfig.toObject(request.config, {
                enums: String,
            })
            : undefined;
        const simpleConfig = request.simpleConfig
            ? ConfigsSimpleTelemetryConfig.toObject(request.simpleConfig)
            : undefined;
        return { config, simpleConfig };
    },
    createTelemetryConfig(config) {
        return ConfigsTelemetryConfig.toObject(ConfigsTelemetryConfig.create(config), {
            enums: String,
        });
    },
    createSimpleTelemetryConfig(config) {
        return ConfigsSimpleTelemetryConfig.toObject(ConfigsSimpleTelemetryConfig.create(config));
    },
    createLoggerConfig(config) {
        return ConfigsLoggerConfig.toObject(ConfigsLoggerConfig.create(config));
    },
    createTracerConfig(config) {
        return ConfigsTracerConfig.toObject(ConfigsTracerConfig.create(config));
    },
    createMetricsConfig(config) {
        return ConfigsMetricsConfig.toObject(ConfigsMetricsConfig.create(config));
    },
    createMetricConfig(config) {
        const message = ConfigsMetricConfig.fromObject(config);
        const bytes = ConfigsMetricConfig.encode(message).finish();
        return { _pb: bytes };
    },
    createRecordMetricRequest(request) {
        const metricRequest = {
            name: request.name,
            attributes: request.attributes,
        };
        if (request.counter) {
            metricRequest.counter = ConfigsCounterMetric.create({
                uint64Value: request.counter.uint64Value,
                doubleValue: request.counter.doubleValue,
            });
        }
        else if (request.gauge) {
            metricRequest.gauge = ConfigsGaugeMetric.create({
                int64Value: request.gauge.int64Value,
                doubleValue: request.gauge.doubleValue,
            });
        }
        else if (request.histogram) {
            metricRequest.histogram = ConfigsHistogramMetric.create({
                uint64Value: request.histogram.uint64Value,
                doubleValue: request.histogram.doubleValue,
            });
        }
        const message = ConfigsRecordMetricRequest.create(metricRequest);
        const bytes = ConfigsRecordMetricRequest.encode(message).finish();
        return { _pb: bytes };
    },
    createLogMessageRequest(request) {
        const message = ConfigsLogMessageRequest.fromObject({
            logLevel: request.logLevel,
            message: request.message,
            attributes: request.attributes,
        });
        const bytes = ConfigsLogMessageRequest.encode(message).finish();
        return { _pb: bytes };
    },
    unpackDequeueSpanTracesResponse(obj) {
        validatePbObject(obj);
        const buffer = Buffer.isBuffer(obj._pb) ? obj._pb : Buffer.from(obj._pb);
        const response = ConfigsDequeueSpanTracesResponse.decode(buffer);
        return {
            spans: (response.spans || []).map((span) => ({
                traceId: span.traceId || '',
                spanId: span.spanId || '',
                parentSpanId: span.parentSpanId || '',
                name: span.name || '',
                description: span.description || '',
                startTimeInNanos: span.startTimeInNanos || 0,
                durationInNanos: span.durationInNanos || 0,
                kind: span.kind,
                status: span.status,
                attributes: span.attributes || {},
                events: (span.events || []).map((event) => ({
                    name: event.name || '',
                    timestampInNanos: event.timestampInNanos || 0,
                    attributes: event.attributes || {},
                })) || [],
            })),
        };
    },
    createSpanEvent(event) {
        return ConfigsSpanEvent.toObject(ConfigsSpanEvent.create(event));
    },
    createSpanData(span) {
        return ConfigsSpanData.toObject(ConfigsSpanData.create(span));
    },
};
const isPlainObject = (value) => {
    return (typeof value === 'object' &&
        value !== null &&
        !Array.isArray(value) &&
        !(value instanceof Uint8Array) &&
        !(value instanceof Buffer));
};
function buildFeatureFlagConfigProto(options) {
    var _a;
    if (!options) {
        return undefined;
    }
    const featureFlagConfig = {};
    if (options.enabled !== undefined) {
        featureFlagConfig.enabled = options.enabled;
    }
    if (options.flagdAddress) {
        featureFlagConfig.flagdAddress = options.flagdAddress;
    }
    if (options.pollIntervalMs !== undefined) {
        featureFlagConfig.pollInterval = convertTimeoutToDuration(options.pollIntervalMs);
    }
    if (options.evaluationMode) {
        // Convert string enum to numeric value for protobuf
        const EvaluationModeEnum = root.lookupEnum('ai.inworld.runtime.v1.graphs.spec.EvaluationMode');
        featureFlagConfig.evaluationMode =
            (_a = EvaluationModeEnum.values[options.evaluationMode]) !== null && _a !== void 0 ? _a : options.evaluationMode;
    }
    return Object.keys(featureFlagConfig).length > 0
        ? ConfigsFeatureFlagConfig.create(featureFlagConfig)
        : undefined;
}
function decodeDataStoreMap(dataToStore) {
    if (!dataToStore) {
        return undefined;
    }
    const entries = Object.entries(dataToStore);
    if (entries.length === 0) {
        return undefined;
    }
    const decoded = {};
    for (const [key, value] of entries) {
        try {
            validatePbObject(value);
            decoded[key] = DataContainer.decode(value._pb);
        }
        catch (error) {
            const errorMessage = error instanceof global.Error ? error.message : JSON.stringify(error);
            throw new global.Error(`Failed to decode data store entry "${key}": ${errorMessage}`);
        }
    }
    return decoded;
}
function buildThreadPoolConfigProto(options) {
    if (!options) {
        return undefined;
    }
    const config = {};
    if (options.workerStrategy) {
        config.workerStrategy = options.workerStrategy;
    }
    if (options.workerCount !== undefined) {
        config.workerCount = options.workerCount;
    }
    if (options.coreMultiplier !== undefined) {
        config.coreMultiplier = options.coreMultiplier;
    }
    return Object.keys(config).length > 0
        ? ConfigsThreadPoolConfig.create(config)
        : undefined;
}
function buildTelemetryConfigProto(options) {
    if (!options) {
        return undefined;
    }
    const telemetryConfig = {};
    if (options.appName !== undefined) {
        telemetryConfig.appName = options.appName;
    }
    if (options.appVersion !== undefined) {
        telemetryConfig.appVersion = options.appVersion;
    }
    if (options.exporterType) {
        telemetryConfig.exporterType = options.exporterType;
    }
    if (options.sinkAbslLogs !== undefined) {
        telemetryConfig.sinkAbslLogs = options.sinkAbslLogs;
    }
    if (options.logLevel) {
        telemetryConfig.logLevel = options.logLevel;
    }
    return Object.keys(telemetryConfig).length > 0
        ? ConfigsTelemetryConfig.create(telemetryConfig)
        : undefined;
}
exports.graphMethods = {
    createEnvRequest(options = {}) {
        const request = {
            initializeFromEnvVars: options.initializeFromEnvVars !== undefined
                ? options.initializeFromEnvVars
                : true,
        };
        const threadPool = buildThreadPoolConfigProto(options.threadPool);
        if (threadPool) {
            request.threadPool = threadPool;
        }
        const telemetry = buildTelemetryConfigProto(options.telemetry);
        if (telemetry) {
            request.telemetry = telemetry;
        }
        if (options.substitutions) {
            const substitutions = Object.entries(options.substitutions).reduce((acc, [key, value]) => {
                if (value !== undefined) {
                    acc[key] = value;
                }
                return acc;
            }, {});
            if (Object.keys(substitutions).length > 0) {
                request.substitutions = substitutions;
            }
        }
        if (options.addonPoolSize !== undefined) {
            request.addonConfig = { addonPoolSize: options.addonPoolSize };
        }
        const requestMsg = ConfigsCreateEnvRequest.create(request);
        const bytes = ConfigsCreateEnvRequest.encode(requestMsg).finish();
        return { _pb: bytes };
    },
    createGraphRequest(options) {
        if (!options.specJson) {
            throw new global.Error('specJson must be provided to create CreateGraphRequest');
        }
        const request = {};
        request.specJson = options.specJson;
        const featureFlagConfig = buildFeatureFlagConfigProto(options.featureFlagConfig);
        if (featureFlagConfig) {
            request.config = ConfigsGraphCreationConfig.create({
                featureFlagConfig,
            });
        }
        if (options.substitutions) {
            const filteredSubstitutions = Object.entries(options.substitutions).reduce((acc, [key, value]) => {
                if (value !== undefined) {
                    acc[key] = value;
                }
                return acc;
            }, {});
            if (Object.keys(filteredSubstitutions).length > 0) {
                request.substitutions = filteredSubstitutions;
            }
        }
        const requestMsg = ConfigsCreateGraphRequest.create(request);
        const bytes = ConfigsCreateGraphRequest.encode(requestMsg).finish();
        return { _pb: bytes };
    },
    createStartExecutionRequest(options) {
        var _a;
        if (!options.executionContext) {
            throw new global.Error('executionContext is required to start execution');
        }
        const executionContext = options.executionContext;
        const trimmedExecutionId = (_a = executionContext.executionId) === null || _a === void 0 ? void 0 : _a.trim();
        if (!trimmedExecutionId) {
            throw new global.Error('executionId is required to start execution');
        }
        const executionContextProto = {
            executionId: trimmedExecutionId,
        };
        if (executionContext.userContext) {
            const userContextProto = {};
            if (executionContext.userContext.attributes) {
                userContextProto.attributes = executionContext.userContext.attributes;
            }
            if (executionContext.userContext.targetingKey !== undefined) {
                userContextProto.targetingKey =
                    executionContext.userContext.targetingKey;
            }
            if (Object.keys(userContextProto).length > 0) {
                executionContextProto.userContext =
                    ConfigsUserContext.create(userContextProto);
            }
        }
        if (executionContext.userCredentials) {
            executionContextProto.userCredentials = ConfigsCredentials.create(executionContext.userCredentials);
        }
        const decodedDataStore = decodeDataStoreMap(executionContext.dataToStore);
        if (decodedDataStore) {
            executionContextProto.dataToStore = decodedDataStore;
        }
        const executionContextMsg = ConfigsExecutionContext.create(executionContextProto);
        const startRequestMsg = ConfigsStartExecutionRequest.create({
            executionContext: executionContextMsg,
        });
        const bytes = ConfigsStartExecutionRequest.encode(startRequestMsg).finish();
        return { _pb: bytes };
    },
};
exports.PbType = {
    embeddings: exports.embeddingsMethods,
    speech: exports.speechMethods,
    llm: exports.llmMethods,
    nlu: exports.nluMethods,
    knowledge: exports.knowledgeMethods,
    mcp: exports.mcpMethods,
    platform: exports.platformMethods,
    telemetry: exports.telemetryMethods,
    graph: exports.graphMethods,
    of: getType,
    any(value) {
        const jsonString = JSON.stringify(value);
        const anyMsg = GoogleProtobufAny.create({
            type_url: 'type.googleapis.com/inworld.CustomData',
            value: Buffer.from(jsonString, 'utf-8'),
        });
        const container = DataContainer.create({ any: anyMsg });
        const bytes = DataContainer.encode(container).finish();
        return { _pb: bytes };
    },
    unpackAny(obj) {
        validatePbObject(obj);
        const container = DataContainer.decode(obj._pb);
        if (container.any) {
            try {
                const jsonString = Buffer.from(container.any.value).toString('utf-8');
                return JSON.parse(jsonString);
            }
            catch (error) {
                throw new global.Error(`Failed to unpack Any field: ${error.message}`);
            }
        }
        handleUnpackError(container, obj, 'Any');
    },
    text(value) {
        const textMsg = Text.create({ value });
        const container = DataContainer.create({ text: textMsg });
        const bytes = DataContainer.encode(container).finish();
        return { _pb: bytes };
    },
    unpackText(obj) {
        validatePbObject(obj);
        const container = DataContainer.decode(obj._pb);
        if (container.text) {
            return container.text.value;
        }
        handleUnpackError(container, obj, 'Text');
    },
    /**
     * Create an Audio message from data and sample rate
     * @param {Uint8Array|Array} data - The audio data
     * @param {number} sampleRate - The sample rate in Hz
     * @returns {Object} Object with _pb field containing serialized bytes
     */
    audio(data, sampleRate) {
        // Convert data to Buffer properly, handling Float32Array
        let buffer;
        if (data instanceof Float32Array) {
            // Create a Buffer from the Float32Array's underlying ArrayBuffer
            buffer = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
        }
        else if (Array.isArray(data)) {
            const floatArray = new Float32Array(data);
            buffer = Buffer.from(floatArray.buffer);
        }
        else {
            buffer = Buffer.from(data);
        }
        const audioMsg = Audio.create({
            data: buffer,
            sampleRate: sampleRate,
        });
        const container = DataContainer.create({ audio: audioMsg });
        const bytes = DataContainer.encode(container).finish();
        return { _pb: bytes };
    },
    multimodalContent(content) {
        // Decode the inner Text or Audio from their DataContainer wrappers
        let textMsg = null;
        let audioMsg = null;
        if (content.text) {
            const textContainer = DataContainer.decode(content.text._pb);
            textMsg = textContainer.text;
        }
        if (content.audio) {
            const audioContainer = DataContainer.decode(content.audio._pb);
            audioMsg = audioContainer.audio;
        }
        // Create MultimodalContent with the unwrapped text or audio
        const multimodalMsg = MultimodalContent.create({
            text: textMsg,
            audio: audioMsg,
        });
        // Wrap in DataContainer - protobuf.js expects camelCase in JS but
        // encodes to snake_case on wire
        const container = DataContainer.create({
            multiModalContent: multimodalMsg,
        });
        const bytes = DataContainer.encode(container).finish();
        return { _pb: bytes };
    },
    unpackMultimodalContent(obj) {
        validatePbObject(obj);
        const container = DataContainer.decode(obj._pb);
        // Check both camelCase (from JS) and snake_case (from C++ wire format)
        const mmContent = container.multiModalContent || container.multi_modal_content;
        if (mmContent) {
            const result = {};
            // Extract text if present (it's a Text message with a 'value' field)
            if (mmContent.text) {
                result.text = mmContent.text.value;
            }
            // Extract audio if present
            if (mmContent.audio) {
                const buffer = mmContent.audio.data;
                // Check if buffer is properly aligned for Float32Array (4-byte
                // boundary)
                let float32Array;
                if (buffer.byteOffset % 4 === 0) {
                    // Buffer is aligned, safe to create view directly
                    float32Array = new Float32Array(buffer.buffer, buffer.byteOffset, buffer.byteLength / 4);
                }
                else {
                    // Buffer is not aligned, copy to new aligned buffer
                    const alignedBuffer = new Uint8Array(buffer);
                    float32Array = new Float32Array(alignedBuffer.buffer, alignedBuffer.byteOffset, alignedBuffer.byteLength / 4);
                }
                result.audio = {
                    data: float32Array,
                    sampleRate: mmContent.audio.sampleRate,
                };
            }
            return result;
        }
        handleUnpackError(container, obj, 'MultimodalContent');
    },
    unpackAudio(obj) {
        validatePbObject(obj);
        const container = DataContainer.decode(obj._pb);
        if (container.audio) {
            const buffer = container.audio.data;
            // Check if buffer is properly aligned for Float32Array (4-byte boundary)
            // If not, copy to a new buffer to ensure proper alignment
            let float32Array;
            if (buffer.byteOffset % 4 === 0) {
                // Buffer is aligned, safe to create view directly
                float32Array = new Float32Array(buffer.buffer, buffer.byteOffset, buffer.byteLength / 4);
            }
            else {
                // Buffer is not aligned, copy to new aligned buffer
                const alignedBuffer = new Uint8Array(buffer);
                float32Array = new Float32Array(alignedBuffer.buffer, alignedBuffer.byteOffset, alignedBuffer.byteLength / 4);
            }
            return {
                data: float32Array,
                sampleRate: container.audio.sampleRate,
            };
        }
        handleUnpackError(container, obj, 'Audio');
    },
    /**
     * Create a TTSRequest message with streaming
     * @param ttsRequest
     * @param {Generator} streamGenerator - Generator function that yields text
     *     messages
     * @returns {Object} Object with _pb field containing serialized bytes and
     *     _stream field
     */
    ttsRequest(ttsRequest, streamGenerator) {
        const ttsMsg = TTSRequest.create({
            stream: ttsRequest.stream,
            content: ttsRequest.content,
            voice: ttsRequest.voice,
            synthesisConfig: ttsRequest.synthesisConfig,
        });
        const container = DataContainer.create({ ttsRequest: ttsMsg });
        const bytes = DataContainer.encode(container).finish();
        return {
            _pb: bytes,
            _stream: streamGenerator,
        };
    },
    unpackTTSOutput(obj) {
        validatePbObject(obj);
        const container = DataContainer.decode(obj._pb);
        if (container.ttsOutput) {
            return {
                text: container.ttsOutput.text,
                audio: container.ttsOutput.audio,
            };
        }
        handleUnpackError(container, obj, 'TTSOutput');
    },
    // Json functions
    json(value) {
        const jsonString = typeof value === 'string' ? value : JSON.stringify(value);
        const jsonMsg = Json.create({ value: jsonString });
        const container = DataContainer.create({ json: jsonMsg });
        const bytes = DataContainer.encode(container).finish();
        return { _pb: bytes };
    },
    unpackJson(obj) {
        validatePbObject(obj);
        const container = DataContainer.decode(obj._pb);
        if (container.json) {
            try {
                return JSON.parse(container.json.value);
            }
            catch (_error) {
                return container.json.value;
            }
        }
        handleUnpackError(container, obj, 'Json');
    },
    customData(value, schema) {
        var _a;
        const customMsg = DataCustomData.create({
            value: (_a = structFromObject(value)) !== null && _a !== void 0 ? _a : GoogleStruct.create({}),
            schema: structFromObject(schema),
        });
        const container = DataContainer.create({ customData: customMsg });
        const bytes = DataContainer.encode(container).finish();
        return { _pb: bytes };
    },
    unpackCustomData(obj) {
        var _a;
        validatePbObject(obj);
        const container = DataContainer.decode(obj._pb);
        if (container.customData) {
            return {
                value: (_a = structToObject(container.customData.value)) !== null && _a !== void 0 ? _a : {},
                schema: structToObject(container.customData.schema),
            };
        }
        handleUnpackError(container, obj, 'CustomData');
    },
    // SafetyResult functions
    safetyResult(text, isSafe) {
        const safetyMsg = SafetyResult.create({ text, isSafe: isSafe });
        const container = DataContainer.create({ safetyResult: safetyMsg });
        const bytes = DataContainer.encode(container).finish();
        return { _pb: bytes };
    },
    unpackSafetyResult(obj) {
        validatePbObject(obj);
        const container = DataContainer.decode(obj._pb);
        if (container.safetyResult) {
            return {
                text: container.safetyResult.text,
                isSafe: container.safetyResult.isSafe,
            };
        }
        handleUnpackError(container, obj, 'SafetyResult');
    },
    // ClassificationResult functions
    classificationResult(classes) {
        const classMsg = ClassificationResult.create({ classes });
        const container = DataContainer.create({ classificationResult: classMsg });
        const bytes = DataContainer.encode(container).finish();
        return { _pb: bytes };
    },
    unpackClassificationResult(obj) {
        validatePbObject(obj);
        const container = DataContainer.decode(obj._pb);
        if (container.classificationResult) {
            return {
                classes: container.classificationResult.classes || [],
            };
        }
        handleUnpackError(container, obj, 'ClassificationResult');
    },
    goalAdvancementResponse(activatedGoals, completedGoals, currentGoals, beliefState) {
        const goalMsg = GoalAdvancementResponse.create({
            activatedGoals: activatedGoals,
            completedGoals: completedGoals,
            currentGoals: currentGoals,
            beliefState: beliefState,
        });
        const container = DataContainer.create({ goalAdvancement: goalMsg });
        const bytes = DataContainer.encode(container).finish();
        return { _pb: bytes };
    },
    unpackGoalAdvancement(obj) {
        validatePbObject(obj);
        const container = DataContainer.decode(obj._pb);
        if (container.goalAdvancementResponse) {
            return {
                activatedGoals: container.goalAdvancementResponse.activatedGoals || [],
                completedGoals: container.goalAdvancementResponse.completedGoals || [],
                currentGoals: container.goalAdvancementResponse.currentGoals || [],
                beliefState: container.goalAdvancementResponse.beliefState || '{}',
            };
        }
        handleUnpackError(container, obj, 'GoalAdvancement');
    },
    goalAdvancementRequest(request) {
        const goalMsg = GoalAdvancementRequest.create(request);
        const container = DataContainer.create({ goalAdvancementRequest: goalMsg });
        const bytes = DataContainer.encode(container).finish();
        return { _pb: bytes };
    },
    unpackGoalAdvancementRequest(obj) {
        validatePbObject(obj);
        const container = DataContainer.decode(obj._pb);
        if (container.goalAdvancementRequest) {
            return container.goalAdvancementRequest;
        }
        handleUnpackError(container, obj, 'GoalAdvancementRequest');
    },
    // KnowledgeRecords functions
    knowledgeRecords(records) {
        const knowledgeMsg = KnowledgeRecords.create({ records });
        const container = DataContainer.create({ knowledgeRecords: knowledgeMsg });
        const bytes = DataContainer.encode(container).finish();
        return { _pb: bytes };
    },
    unpackKnowledgeRecords(obj) {
        validatePbObject(obj);
        const container = DataContainer.decode(obj._pb);
        if (container.knowledgeRecords) {
            return {
                records: container.knowledgeRecords.records || [],
            };
        }
        handleUnpackError(container, obj, 'KnowledgeRecords');
    },
    // MatchedIntents functions
    matchedIntents(intents) {
        const intentMatches = intents.map((intent) => IntentMatch.create(intent));
        const matchedMsg = MatchedIntents.create({ intentMatches: intentMatches });
        const container = DataContainer.create({ matchedIntents: matchedMsg });
        const bytes = DataContainer.encode(container).finish();
        return { _pb: bytes };
    },
    unpackMatchedIntents(obj) {
        var _a;
        validatePbObject(obj);
        const container = DataContainer.decode(obj._pb);
        if (container.matchedIntents) {
            return {
                intents: ((_a = container.matchedIntents.intentMatches) === null || _a === void 0 ? void 0 : _a.map((intent) => ({
                    intentName: intent.intentName,
                    score: intent.score,
                }))) || [],
            };
        }
        handleUnpackError(container, obj, 'MatchedIntents');
    },
    // MatchedKeywords functions
    matchedKeywords(keywords) {
        const keywordMatches = keywords.map((kw) => KeywordMatch.create(kw));
        const matchedMsg = MatchedKeywords.create({
            keywordMatches: keywordMatches,
        });
        const container = DataContainer.create({ matchedKeywords: matchedMsg });
        const bytes = DataContainer.encode(container).finish();
        return { _pb: bytes };
    },
    unpackMatchedKeywords(obj) {
        var _a;
        validatePbObject(obj);
        const container = DataContainer.decode(obj._pb);
        if (container.matchedKeywords) {
            return {
                keywords: ((_a = container.matchedKeywords.keywordMatches) === null || _a === void 0 ? void 0 : _a.map((kw) => ({
                    groupName: kw.groupName,
                    keyword: kw.keyword,
                }))) || [],
            };
        }
        handleUnpackError(container, obj, 'MatchedKeywords');
    },
    // ToolCallRequest functions
    toolCallRequest(toolCalls) {
        const toolCallObjs = toolCalls.map((tc) => ToolCall.create({ id: tc.id, name: tc.name, args: tc.args }));
        const toolMsg = ToolCallRequest.create({ toolCalls: toolCallObjs });
        const container = DataContainer.create({ toolCallRequest: toolMsg });
        const bytes = DataContainer.encode(container).finish();
        return { _pb: bytes };
    },
    unpackToolCallRequest(obj) {
        var _a;
        validatePbObject(obj);
        const container = DataContainer.decode(obj._pb);
        if (container.toolCallRequest) {
            return {
                toolCalls: ((_a = container.toolCallRequest.toolCalls) === null || _a === void 0 ? void 0 : _a.map((tc) => ({
                    id: tc.id,
                    name: tc.name,
                    args: tc.args,
                }))) || [],
            };
        }
        handleUnpackError(container, obj, 'ToolCallRequest');
    },
    // ToolCallResponse functions
    toolCallResponse(results) {
        const toolResults = results.map((r) => ToolCallResult.create({ result: r.result }));
        const responseMsg = ToolCallResponse.create({
            toolCallResults: toolResults,
        });
        const container = DataContainer.create({ toolCallResponse: responseMsg });
        const bytes = DataContainer.encode(container).finish();
        return { _pb: bytes };
    },
    unpackToolCallResponse(obj) {
        var _a;
        validatePbObject(obj);
        const container = DataContainer.decode(obj._pb);
        if (container.toolCallResponse) {
            return {
                toolCallResults: ((_a = container.toolCallResponse.toolCallResults) === null || _a === void 0 ? void 0 : _a.map((r) => ({
                    toolCallId: r.toolCallId,
                    result: r.result,
                }))) || [],
            };
        }
        handleUnpackError(container, obj, 'ToolCallResponse');
    },
    // ToolCallResult functions
    toolCallResult(result) {
        const resultMsg = ToolCallResult.create({
            result,
        });
        const container = DataContainer.create({ toolCallResult: resultMsg });
        const bytes = DataContainer.encode(container).finish();
        return { _pb: bytes };
    },
    unpackToolCallResult(obj) {
        validatePbObject(obj);
        const container = DataContainer.decode(obj._pb);
        if (container.toolCallResult) {
            return {
                toolCallId: container.toolCallResult.toolCallId,
                result: container.toolCallResult.result,
            };
        }
        handleUnpackError(container, obj, 'ToolCallResult');
    },
    // ListToolsResponse functions
    listToolsResponse(tools) {
        const toolObjs = tools.map((t) => Tool.create(t));
        const listMsg = ListToolsResponse.create({ tools: toolObjs });
        const container = DataContainer.create({ listToolsResponse: listMsg });
        const bytes = DataContainer.encode(container).finish();
        return { _pb: bytes };
    },
    unpackListToolsResponse(obj) {
        var _a;
        validatePbObject(obj);
        const container = DataContainer.decode(obj._pb);
        if (container.listToolsResponse) {
            return {
                tools: ((_a = container.listToolsResponse.tools) === null || _a === void 0 ? void 0 : _a.map((t) => ({
                    name: t.name,
                    description: t.description,
                    properties: t.properties,
                }))) || [],
            };
        }
        handleUnpackError(container, obj, 'ListToolsResponse');
    },
    llmChatRequest(input) {
        var _a, _b;
        const request = graphs_1.LLMChatRequestSchema.parse(input);
        const msgObjs = ((_a = request.messages) === null || _a === void 0 ? void 0 : _a.map((m) => {
            var _a;
            return LLMMessage.create({
                role: m.role,
                content: m.content,
                contentItems: m.contentItems,
                toolCalls: ((_a = m.toolCalls) === null || _a === void 0 ? void 0 : _a.map((tc) => ToolCallRequest.create(tc))) || [],
                toolCallId: m.toolCallId,
            });
        })) || [];
        const toolObjs = ((_b = request.tools) === null || _b === void 0 ? void 0 : _b.map((t) => Tool.create(t))) || [];
        const toolChoice = request.toolChoice
            ? {
                type: request.toolChoice.type,
                value: request.toolChoice.value,
                function: request.toolChoice.function,
            }
            : undefined;
        const textGenerationConfig = request.textGenerationConfig
            ? {
                frequencyPenalty: request.textGenerationConfig.frequencyPenalty,
                logitBias: request.textGenerationConfig.logitBias,
                maxNewTokens: request.textGenerationConfig.maxNewTokens,
                maxPromptLength: request.textGenerationConfig.maxPromptLength,
                presencePenalty: request.textGenerationConfig.presencePenalty,
                repetitionPenalty: request.textGenerationConfig.repetitionPenalty,
                seed: request.textGenerationConfig.seed,
                stopSequences: request.textGenerationConfig.stopSequences,
                temperature: request.textGenerationConfig.temperature,
                topP: request.textGenerationConfig.topP,
            }
            : undefined;
        const requestMsg = LLMChatRequest.create({
            messages: msgObjs,
            tools: toolObjs,
            responseFormat: request.responseFormat,
            toolChoice: toolChoice,
            textGenerationConfig: textGenerationConfig,
        });
        const container = DataContainer.create({ llmChatRequest: requestMsg });
        const bytes = DataContainer.encode(container).finish();
        return { _pb: bytes };
    },
    unpackLLMChatRequest(obj) {
        var _a, _b;
        validatePbObject(obj);
        const container = DataContainer.decode(obj._pb);
        // TODO: fix bug. Runtime pb produces integer values for proto enum
        const getResponseFormat = (value) => {
            if (typeof container.llmChatRequest.responseFormat === 'number') {
                switch (value) {
                    case 1: {
                        return 'text';
                    }
                    case 2: {
                        return 'json';
                    }
                    case 3: {
                        return 'json_schema';
                    }
                    default:
                        return 'text';
                }
            }
            return container.llmChatRequest.responseFormat;
        };
        if (container.llmChatRequest) {
            return {
                messages: ((_a = container.llmChatRequest.messages) === null || _a === void 0 ? void 0 : _a.map((m) => {
                    var _a;
                    return ({
                        role: m.role,
                        content: m.content,
                        toolCallId: m.toolCallId || '',
                        toolCalls: ((_a = m.toolCalls) === null || _a === void 0 ? void 0 : _a.map((tc) => ({
                            name: tc.name,
                            arguments: tc.arguments,
                        }))) || [],
                    });
                })) || [],
                tools: ((_b = container.llmChatRequest.tools) === null || _b === void 0 ? void 0 : _b.map((t) => ({
                    name: t.name,
                    description: t.description,
                    properties: t.properties,
                }))) || [],
                responseFormat: getResponseFormat(container.llmChatRequest.responseFormat),
                toolChoice: container.llmChatRequest.toolChoice,
                textGenerationConfig: container.llmChatRequest.textGenerationConfig,
            };
        }
        handleUnpackError(container, obj, 'LLMChatRequest');
    },
    llmChatRoutingRequest(input) {
        var _a, _b, _c, _d, _f;
        const request = input;
        const msgObjs = ((_a = request.messages) === null || _a === void 0 ? void 0 : _a.map((m) => {
            var _a;
            return LLMMessage.create({
                role: m.role,
                content: m.content,
                contentItems: m.contentItems,
                toolCalls: ((_a = m.toolCalls) === null || _a === void 0 ? void 0 : _a.map((tc) => ToolCallRequest.create(tc))) || [],
                toolCallId: m.toolCallId,
            });
        })) || [];
        const toolObjs = ((_b = request.tools) === null || _b === void 0 ? void 0 : _b.map((t) => Tool.create(t))) || [];
        const toolChoice = request.toolChoice
            ? {
                type: request.toolChoice.type,
                value: request.toolChoice.value,
                function: request.toolChoice.function,
            }
            : undefined;
        const textGenerationConfig = request.textGenerationConfig
            ? {
                frequencyPenalty: request.textGenerationConfig.frequencyPenalty,
                logitBias: request.textGenerationConfig.logitBias,
                maxNewTokens: request.textGenerationConfig.maxNewTokens,
                maxPromptLength: request.textGenerationConfig.maxPromptLength,
                presencePenalty: request.textGenerationConfig.presencePenalty,
                repetitionPenalty: request.textGenerationConfig.repetitionPenalty,
                seed: request.textGenerationConfig.seed,
                stopSequences: request.textGenerationConfig.stopSequences,
                temperature: request.textGenerationConfig.temperature,
                topP: request.textGenerationConfig.topP,
            }
            : undefined;
        const modelId = request.modelId
            ? {
                provider: request.modelId.provider,
                modelName: request.modelId.modelName,
            }
            : undefined;
        const SortMetric = root.lookupEnum('ai.inworld.runtime.v1.graphs.schema.SortMetric');
        const SortDirection = root.lookupEnum('ai.inworld.runtime.v1.graphs.schema.SortDirection');
        const modelSelection = request.modelSelection
            ? {
                models: ((_c = request.modelSelection.models) === null || _c === void 0 ? void 0 : _c.map((m) => ({
                    provider: m.provider,
                    modelName: m.modelName,
                }))) || [],
                ignore: (_d = request.modelSelection.ignore) === null || _d === void 0 ? void 0 : _d.map((m) => ({
                    provider: m.provider,
                    modelName: m.modelName,
                })),
                sort: (_f = request.modelSelection.sort) === null || _f === void 0 ? void 0 : _f.map((s) => {
                    var _a, _b;
                    return ({
                        metric: typeof s.metric === 'string'
                            ? ((_a = SortMetric.values[s.metric]) !== null && _a !== void 0 ? _a : s.metric)
                            : s.metric,
                        direction: s.direction && typeof s.direction === 'string'
                            ? ((_b = SortDirection.values[s.direction]) !== null && _b !== void 0 ? _b : s.direction)
                            : s.direction,
                    });
                }),
            }
            : undefined;
        const strategy = request.strategy
            ? {
                weightedLoadBalancing: request.strategy.weightedLoadBalancing,
            }
            : undefined;
        const requestMsg = LLMChatRoutingRequest.create({
            messages: msgObjs,
            tools: toolObjs,
            responseFormat: request.responseFormat,
            toolChoice: toolChoice,
            textGenerationConfig: textGenerationConfig,
            modelId: modelId,
            modelSelection: modelSelection,
            promptVariables: request.promptVariables,
            strategy: strategy,
            stream: request.stream,
        });
        const container = DataContainer.create({
            llmChatRoutingRequest: requestMsg,
        });
        const bytes = DataContainer.encode(container).finish();
        return { _pb: bytes };
    },
    unpackLLMChatRoutingRequest(obj) {
        var _a, _b;
        validatePbObject(obj);
        const container = DataContainer.decode(obj._pb);
        const getResponseFormat = (value) => {
            if (typeof value === 'number') {
                switch (value) {
                    case 1:
                        return 'RESPONSE_FORMAT_TEXT';
                    case 2:
                        return 'RESPONSE_FORMAT_JSON';
                    case 3:
                        return 'RESPONSE_FORMAT_JSON_SCHEMA';
                    case 0:
                    default:
                        return 'RESPONSE_FORMAT_UNSPECIFIED';
                }
            }
            if (typeof value === 'string') {
                return value;
            }
            return undefined;
        };
        if (container.llmChatRoutingRequest) {
            return {
                messages: ((_a = container.llmChatRoutingRequest.messages) === null || _a === void 0 ? void 0 : _a.map((m) => {
                    var _a;
                    return ({
                        role: m.role,
                        content: m.content,
                        toolCallId: m.toolCallId || '',
                        toolCalls: ((_a = m.toolCalls) === null || _a === void 0 ? void 0 : _a.map((tc) => ({
                            name: tc.name,
                            arguments: tc.arguments,
                        }))) || [],
                    });
                })) || [],
                tools: ((_b = container.llmChatRoutingRequest.tools) === null || _b === void 0 ? void 0 : _b.map((t) => ({
                    name: t.name,
                    description: t.description,
                    properties: t.properties,
                }))) || [],
                responseFormat: getResponseFormat(container.llmChatRoutingRequest.responseFormat),
                toolChoice: container.llmChatRoutingRequest.toolChoice,
                textGenerationConfig: container.llmChatRoutingRequest.textGenerationConfig,
                modelId: container.llmChatRoutingRequest.modelId,
                modelSelection: container.llmChatRoutingRequest.modelSelection,
                promptVariables: container.llmChatRoutingRequest.promptVariables,
                strategy: container.llmChatRoutingRequest.strategy,
                stream: container.llmChatRoutingRequest.stream || false,
            };
        }
        handleUnpackError(container, obj, 'LLMChatRoutingRequest');
    },
    // LLMChatResponse functions
    llmChatResponse: encodeLLMChatResponse,
    unpackLLMChatResponse(obj) {
        var _a, _b;
        validatePbObject(obj);
        const container = DataContainer.decode(obj._pb);
        if (container.llmChatResponse) {
            const response = {
                content: container.llmChatResponse.content || '',
                stream: container.llmChatResponse.stream || false,
                toolCalls: ((_a = container.llmChatResponse.toolCalls) === null || _a === void 0 ? void 0 : _a.map((tc) => ({
                    id: tc.id,
                    name: tc.name,
                    args: tc.args,
                }))) || [],
                finishReason: convertFinishReason(container.llmChatResponse.finishReason),
            };
            if (container.llmChatResponse.usage) {
                const promptTokens = container.llmChatResponse.usage.promptTokens;
                const completionTokens = container.llmChatResponse.usage.completionTokens;
                response.usage = {
                    promptTokens: typeof promptTokens === 'object' && 'low' in promptTokens
                        ? promptTokens.low
                        : promptTokens || 0,
                    completionTokens: typeof completionTokens === 'object' && 'low' in completionTokens
                        ? completionTokens.low
                        : completionTokens || 0,
                };
            }
            if (container.llmChatResponse.modelName) {
                response.modelName = container.llmChatResponse.modelName;
            }
            if (container.llmChatResponse.metadata) {
                response.metadata = {
                    attempts: (_b = container.llmChatResponse.metadata.attempts) === null || _b === void 0 ? void 0 : _b.map((attempt) => {
                        var _a;
                        return ({
                            modelId: attempt.modelId,
                            success: attempt.success,
                            // Convert null to undefined for optional string field
                            errorMessage: (_a = attempt.errorMessage) !== null && _a !== void 0 ? _a : undefined,
                            // Convert Long object to number
                            timeToFirstTokenMs: convertLongToNumber(attempt.timeToFirstTokenMs) || undefined,
                            warnings: attempt.warnings,
                        });
                    }),
                    generationId: container.llmChatResponse.metadata.generationId,
                    reasoning: container.llmChatResponse.metadata.reasoning,
                    // Convert Long object to number
                    totalDurationMs: convertLongToNumber(container.llmChatResponse.metadata.totalDurationMs) || undefined,
                };
            }
            return response;
        }
        handleUnpackError(container, obj, 'LLMChatResponse');
    },
    llmCompletionResponse(content, stream = false) {
        const responseMsg = LLMCompletionResponse.create({
            content,
            stream,
        });
        const container = DataContainer.create({
            llmCompletionResponse: responseMsg,
        });
        const bytes = DataContainer.encode(container).finish();
        return { _pb: bytes };
    },
    unpackLLMCompletionResponse(obj) {
        validatePbObject(obj);
        const container = DataContainer.decode(obj._pb);
        if (container.llmCompletionResponse) {
            const response = {
                content: container.llmCompletionResponse.content || '',
                stream: container.llmCompletionResponse.stream || false,
            };
            // Add optional fields if they exist
            if (container.llmCompletionResponse.finishReason) {
                response.finishReason = convertFinishReason(container.llmCompletionResponse.finishReason);
            }
            if (container.llmCompletionResponse.usage) {
                // Convert protobuf Long objects to numbers
                const promptTokens = container.llmCompletionResponse.usage.promptTokens;
                const completionTokens = container.llmCompletionResponse.usage.completionTokens;
                response.usage = {
                    promptTokens: typeof promptTokens === 'object' && 'low' in promptTokens
                        ? promptTokens.low
                        : promptTokens || 0,
                    completionTokens: typeof completionTokens === 'object' && 'low' in completionTokens
                        ? completionTokens.low
                        : completionTokens || 0,
                };
            }
            if (container.llmCompletionResponse.modelName) {
                response.modelName = container.llmCompletionResponse.modelName;
            }
            if (container.llmCompletionResponse.failedAttempts) {
                response.failedAttempts =
                    container.llmCompletionResponse.failedAttempts.map((attempt) => ({
                        modelId: attempt.modelId || '',
                        errorMessage: attempt.errorMessage || '',
                    }));
            }
            return response;
        }
        handleUnpackError(container, obj, 'LLMCompletionResponse');
    },
    contentData(contentData) {
        const contentDataMsg = ContentData.create({
            content: contentData.content,
            toolCalls: contentData.toolCalls,
        });
        const container = DataContainer.create({ contentData: contentDataMsg });
        const bytes = DataContainer.encode(container).finish();
        return { _pb: bytes };
    },
    unpackContentData(obj) {
        var _a, _b, _c, _d;
        validatePbObject(obj);
        const container = DataContainer.decode(obj._pb);
        // Check for llmChatResponse first (has more fields including metadata)
        if (container.llmChatResponse) {
            const response = container.llmChatResponse;
            const result = {
                content: response.content || '',
                stream: response.stream || false,
                toolCalls: ((_a = response.toolCalls) === null || _a === void 0 ? void 0 : _a.map((tc) => ({
                    id: tc.id || '',
                    name: tc.name || '',
                    args: tc.args || '',
                }))) || [],
                finishReason: convertFinishReason(response.finishReason),
            };
            if (response.usage) {
                result.usage = {
                    promptTokens: convertLongToNumber(response.usage.promptTokens),
                    completionTokens: convertLongToNumber(response.usage.completionTokens),
                };
            }
            if (response.modelName) {
                result.modelName = response.modelName;
            }
            if (response.metadata) {
                result.metadata = {
                    attempts: (_b = response.metadata.attempts) === null || _b === void 0 ? void 0 : _b.map((attempt) => {
                        var _a;
                        return ({
                            modelId: attempt.modelId,
                            success: attempt.success,
                            errorMessage: (_a = attempt.errorMessage) !== null && _a !== void 0 ? _a : undefined,
                            timeToFirstTokenMs: convertLongToNumber(attempt.timeToFirstTokenMs) || undefined,
                            warnings: attempt.warnings,
                        });
                    }),
                    generationId: response.metadata.generationId,
                    reasoning: response.metadata.reasoning,
                    totalDurationMs: convertLongToNumber(response.metadata.totalDurationMs) || undefined,
                };
            }
            return result;
        }
        if (container.contentData) {
            const result = {
                content: container.contentData.content || '',
                stream: false,
                toolCalls: ((_c = container.contentData.toolCalls) === null || _c === void 0 ? void 0 : _c.map((tc) => ({
                    id: tc.id || '',
                    name: tc.name || '',
                    args: tc.args || '',
                }))) || [],
                finishReason: convertFinishReason(container.contentData.finishReason),
            };
            // Add optional fields if they exist
            if (container.contentData.usage) {
                result.usage = {
                    promptTokens: convertLongToNumber(container.contentData.usage.promptTokens),
                    completionTokens: convertLongToNumber(container.contentData.usage.completionTokens),
                };
            }
            if (container.contentData.modelName) {
                result.modelName = container.contentData.modelName;
            }
            // Note: ContentData proto doesn't have failedAttempts
            return result;
        }
        try {
            const contentData = ContentData.decode(obj._pb);
            const result = {
                content: contentData.content || '',
                stream: false,
                toolCalls: ((_d = contentData.toolCalls) === null || _d === void 0 ? void 0 : _d.map((tc) => ({
                    id: tc.id || '',
                    name: tc.name || '',
                    args: tc.args || '',
                }))) || [],
                finishReason: convertFinishReason(contentData.finishReason),
            };
            // Add optional fields if they exist
            if (contentData.usage) {
                result.usage = {
                    promptTokens: convertLongToNumber(contentData.usage.promptTokens),
                    completionTokens: convertLongToNumber(contentData.usage.completionTokens),
                };
            }
            if (contentData.modelName) {
                result.modelName = contentData.modelName;
            }
            // Note: ContentData proto doesn't have failedAttempts
            return result;
        }
        catch (_e) { }
        handleUnpackError(container, obj, 'ContentData');
    },
    graphError(code, message) {
        const errorMsg = Error.create({ code, message });
        const container = DataContainer.create({ error: errorMsg });
        const bytes = DataContainer.encode(container).finish();
        return { _pb: bytes };
    },
    unpackGraphError(obj) {
        validatePbObject(obj);
        const container = DataContainer.decode(obj._pb);
        if (container.error) {
            return {
                code: container.error.code,
                message: container.error.message,
            };
        }
        const actualType = getType(obj);
        throw new global.Error(`Expected Error (GraphError) message in DataContainer, but found: ${actualType || 'unknown'}`);
    },
    /**
     * Create a DataStreamWithMetadata message with metadata
     * @param {Record<string, any>} metadata - The metadata object (will be
     *     converted to google.protobuf.Struct)
     * @returns {PbBaseType} Object with _pb field containing serialized
     *     DataContainer bytes
     */
    dataStreamWithMetadata(metadata = {}) {
        // Create DataStreamWithMetadata message
        const dsmProto = DataStreamWithMetadata.create();
        // Convert metadata to Struct if provided
        if (metadata !== null && metadata !== undefined) {
            dsmProto.metadata = jsObjectToStruct(metadata);
        }
        // Wrap in DataContainer
        const container = DataContainer.create({
            dataStreamWithMetadata: dsmProto,
        });
        const bytes = DataContainer.encode(container).finish();
        return { _pb: bytes };
    },
    /**
     * Unpack a DataStreamWithMetadata message
     * @param {PbBaseType} obj - Object with _pb field containing serialized
     *     DataContainer bytes
     * @returns {Record<string, any>} The metadata object
     */
    unpackDataStreamWithMetadata(obj) {
        validatePbObject(obj);
        const container = DataContainer.decode(obj._pb);
        // Check both camelCase and snake_case field names
        const dsm = container.dataStreamWithMetadata || container.data_stream_with_metadata;
        if (dsm) {
            // Convert protobuf Struct back to plain JS object
            if (dsm.metadata) {
                return structToObject(dsm.metadata) || {};
            }
            return {};
        }
        handleUnpackError(container, obj, 'DataStreamWithMetadata');
    },
};
