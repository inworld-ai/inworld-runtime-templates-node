"use strict";
/**
 * MCP (Model Context Protocol) enables LLMs to interact with external tools.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MCPClient = void 0;
const node_api_1 = require("../../internal/node_api");
const pb_helpers_1 = require("../../internal/pb_helpers");
const errors_1 = require("../errors");
/**
 * MCP Client class.
 * Connects to MCP servers to enable LLM tool execution and function calling.
 * Supports both local (stdio/process) and remote (HTTP) transports.
 *
 * @example
 * ```typescript
 * // Create MCP client with HTTP transport
 * const mcpClient = await MCPClient.create({
 *   sessionConfig: {
 *     transport: 'http',
 *     endpoint: 'http://localhost:3000',
 *     httpConfig: {
 *       apiKey: process.env.INWORLD_API_KEY || 'fake_api_key',
 *       defaultTimeout: '30s'
 *     }
 *   }
 * });
 *
 * // List available tools
 * const tools = await mcpClient.listTools();
 * console.log(`Available tools: ${tools.tools.map(t => t.name).join(', ')}`);
 *
 * // Call a tool
 * const result = await mcpClient.callTool('calculator', { operation: 'add', a: 5, b: 3 });
 * console.log(`Result: ${result.result}`);
 * ```
 */
class MCPClient {
    /**
     * Creates a new MCPClient instance (internal constructor).
     * Use `MCPClient.create()` static method instead.
     *
     * @param {any} mcpClientInterface - Addon MCPClientInterface instance
     * @internal
     */
    constructor(mcpClientInterface) {
        this.mcpClientInterface = mcpClientInterface;
    }
    /**
     * Creates a new MCPClient instance with the specified configuration.
     * Supports both remote (HTTP) and local (stdio/process) transports.
     *
     * @param {MCPClientCreationConfig} config - MCP client configuration
     * @returns {Promise<MCPClient>} Promise resolving to MCPClient instance
     * @throws {MCPError} If MCP client creation fails
     *
     * @example
     * ```typescript
     * // HTTP transport
     * const httpClient = await MCPClient.create({
     *   sessionConfig: {
     *     transport: 'http',
     *     endpoint: 'http://localhost:3000',
     *     httpConfig: {
     *       apiKey: process.env.INWORLD_API_KEY || 'fake_api_key',
     *       defaultTimeout: '30s'
     *     }
     *   }
     * });
     *
     * // Stdio transport
     * const stdioClient = await MCPClient.create({
     *   sessionConfig: {
     *     transport: 'stdio',
     *     endpoint: 'node mcp-server.js',
     *     stdioConfig: {
     *       env: process.env as Record<string, string>
     *     }
     *   }
     * });
     * ```
     */
    static async create(config) {
        try {
            const env = (0, node_api_1.getInworldAddonEnv)();
            const mcp = env.mcp;
            if (!mcp) {
                throw new errors_1.MCPError('MCP namespace not available in addon environment');
            }
            const factory = mcp.createMCPClientFactory();
            const configPb = pb_helpers_1.PbHelper.MCP.createMCPClientCreationConfig(config);
            const mcpClientInterface = await factory.createMCPClient(configPb);
            return new MCPClient(mcpClientInterface);
        }
        catch (error) {
            if (error instanceof errors_1.MCPError) {
                throw error;
            }
            throw new errors_1.MCPError(`Failed to create MCP client: ${error.message}`, error.stack);
        }
    }
    /**
     * Lists all available tools from the MCP server.
     * Returns tool definitions including names, descriptions, and input schemas.
     *
     * @returns {Promise<ToolList>} List of available tools
     * @throws {MCPError} If listing tools fails
     *
     * @example
     * ```typescript
     * const toolList = await mcpClient.listTools();
     *
     * console.log(`Found ${toolList.tools.length} tools:`);
     * toolList.tools.forEach(tool => {
     *   console.log(`- ${tool.name}: ${tool.description}`);
     *   if (tool.properties) {
     *     const schema = JSON.parse(tool.properties);
     *     console.log(`  Schema:`, schema);
     *   }
     * });
     * ```
     */
    async listTools() {
        try {
            const toolsListPb = await this.mcpClientInterface.listTools();
            return pb_helpers_1.PbHelper.MCP.unpackToolList(toolsListPb);
        }
        catch (error) {
            if (error instanceof errors_1.MCPError) {
                throw error;
            }
            throw new errors_1.MCPError(`Failed to list tools: ${error.message}`, error.stack);
        }
    }
    /**
     * Calls a tool with the specified arguments.
     * Executes the tool on the MCP server and returns the result.
     *
     * @param {ToolCall} toolCall - Tool call with name and arguments
     * @returns {Promise<ToolCallResult>} Tool execution result
     * @throws {MCPError} If tool call fails
     *
     * @example
     * ```typescript
     * // Call a calculator tool
     * const result = await mcpClient.call({
     *   id: 'call-1',
     *   name: 'calculator',
     *   args: JSON.stringify({ operation: 'add', a: 5, b: 3 })
     * });
     *
     * if (result.isError) {
     *   console.error('Tool error:', result.result);
     * } else {
     *   console.log('Tool result:', result.result);
     * }
     * ```
     */
    async call(toolCall) {
        try {
            if (!toolCall.name) {
                throw new errors_1.MCPError('Tool name is required');
            }
            const toolCallPb = pb_helpers_1.PbHelper.MCP.createToolCall(toolCall.id || `call-${Date.now()}`, toolCall.name, typeof toolCall.args === 'string'
                ? JSON.parse(toolCall.args)
                : toolCall.args);
            const resultPb = await this.mcpClientInterface.call(toolCallPb);
            return pb_helpers_1.PbHelper.MCP.unpackToolCallResult(resultPb);
        }
        catch (error) {
            if (error instanceof errors_1.MCPError) {
                throw error;
            }
            throw new errors_1.MCPError(`Failed to call tool: ${error.message}`, error.stack);
        }
    }
    /**
     * Convenience method to call a tool by name with arguments.
     * Automatically generates a tool call ID and handles argument serialization.
     *
     * @param {string} toolName - Name of the tool to call
     * @param {object} args - Tool arguments as an object
     * @returns {Promise<ToolCallResult>} Tool execution result
     * @throws {MCPError} If tool call fails
     *
     * @example
     * ```typescript
     * // Simple tool call
     * const result = await mcpClient.callTool('add', { a: 10, b: 20 });
     * console.log(`Result: ${result.result}`);
     *
     * // Greet tool
     * const greeting = await mcpClient.callTool('greet', { name: 'Alice' });
     * console.log(greeting.result);  // "Hello, Alice!"
     * ```
     */
    async callTool(toolName, args) {
        return this.call({
            id: `call-${Date.now()}`,
            name: toolName,
            args: JSON.stringify(args),
        });
    }
    /**
     * Gets information about a specific tool by name.
     *
     * @param {string} toolName - Name of the tool to find
     * @returns {Promise<Tool | null>} Tool definition or null if not found
     * @throws {MCPError} If listing tools fails
     *
     * @example
     * ```typescript
     * const calculatorTool = await mcpClient.getTool('calculator');
     *
     * if (calculatorTool) {
     *   console.log(`Description: ${calculatorTool.description}`);
     *   console.log(`Schema:`, JSON.parse(calculatorTool.properties || '{}'));
     * } else {
     *   console.log('Tool not found');
     * }
     * ```
     */
    async getTool(toolName) {
        var _a, _b;
        const toolList = await this.listTools();
        return (_b = (_a = toolList.tools) === null || _a === void 0 ? void 0 : _a.find((tool) => tool.name === toolName)) !== null && _b !== void 0 ? _b : null;
    }
    /**
     * Checks if a specific tool is available.
     *
     * @param {string} toolName - Name of the tool to check
     * @returns {Promise<boolean>} True if tool is available
     * @throws {MCPError} If listing tools fails
     *
     * @example
     * ```typescript
     * if (await mcpClient.hasTool('calculator')) {
     *   const result = await mcpClient.callTool('calculator', { operation: 'multiply', a: 6, b: 7 });
     * } else {
     *   console.log('Calculator tool not available');
     * }
     * ```
     */
    async hasTool(toolName) {
        const tool = await this.getTool(toolName);
        return tool !== null;
    }
    /**
     * Calls multiple tools in sequence.
     *
     * @param {ToolCall[]} toolCalls - Array of tool calls to execute
     * @returns {Promise<ToolCallResult[]>} Array of tool results
     * @throws {MCPError} If any tool call fails
     *
     * @example
     * ```typescript
     * const results = await mcpClient.callBatch([
     *   { id: 'call-1', name: 'add', args: JSON.stringify({ a: 1, b: 2 }) },
     *   { id: 'call-2', name: 'add', args: JSON.stringify({ a: 3, b: 4 }) },
     *   { id: 'call-3', name: 'multiply', args: JSON.stringify({ a: 5, b: 6 }) }
     * ]);
     *
     * results.forEach((result, i) => {
     *   console.log(`Call ${i + 1}: ${result.result}`);
     * });
     * ```
     */
    async callBatch(toolCalls) {
        if (!Array.isArray(toolCalls)) {
            throw new errors_1.MCPError('Tool calls must be an array');
        }
        return Promise.all(toolCalls.map((toolCall) => this.call(toolCall)));
    }
    /**
     * Gets all tool names available on the server.
     *
     * @returns {Promise<string[]>} Array of tool names
     * @throws {MCPError} If listing tools fails
     *
     * @example
     * ```typescript
     * const toolNames = await mcpClient.getToolNames();
     * console.log('Available tools:', toolNames.join(', '));
     * ```
     */
    async getToolNames() {
        var _a, _b;
        const toolList = await this.listTools();
        return (_b = (_a = toolList.tools) === null || _a === void 0 ? void 0 : _a.map((tool) => tool.name)) !== null && _b !== void 0 ? _b : [];
    }
    /**
     * Calls a tool and parses the result as JSON.
     *
     * @param {string} toolName - Name of the tool to call
     * @param {object} args - Tool arguments
     * @returns {Promise<any>} Parsed JSON result
     * @throws {MCPError} If tool call fails or result is not valid JSON
     *
     * @example
     * ```typescript
     * // Call a tool that returns JSON
     * const data = await mcpClient.callToolWithJsonResult('get_user', { userId: '123' });
     * console.log('User:', data.name, data.email);
     * ```
     */
    async callToolWithJsonResult(toolName, args) {
        const result = await this.callTool(toolName, args);
        /*
        if (result.isError) {
          throw new MCPError(`Tool returned error: ${result.result}`);
        }*/
        try {
            return JSON.parse(result.result);
        }
        catch (error) {
            throw new errors_1.MCPError(`Failed to parse tool result as JSON: ${error.message}`);
        }
    }
    /**
     * Filters tools by a predicate function.
     *
     * @param {function} predicate - Function to test each tool
     * @returns {Promise<Tool[]>} Filtered array of tools
     * @throws {MCPError} If listing tools fails
     *
     * @example
     * ```typescript
     * // Find all calculation-related tools
     * const mathTools = await mcpClient.filterTools(
     *   tool => tool.description.toLowerCase().includes('math') ||
     *           tool.description.toLowerCase().includes('calculate')
     * );
     *
     * console.log('Math tools:', mathTools.map(t => t.name));
     * ```
     */
    async filterTools(predicate) {
        var _a, _b;
        const toolList = await this.listTools();
        return (_b = (_a = toolList.tools) === null || _a === void 0 ? void 0 : _a.filter(predicate)) !== null && _b !== void 0 ? _b : [];
    }
}
exports.MCPClient = MCPClient;
