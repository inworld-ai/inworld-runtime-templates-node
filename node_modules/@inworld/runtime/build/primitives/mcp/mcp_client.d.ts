/**
 * MCP (Model Context Protocol) enables LLMs to interact with external tools.
 */
import type { ToolCallResult } from '../../common/api/graphs';
import type { ToolList } from '../../common/api/library';
import type { Tool, ToolCall } from '../types';
import type { MCPClientCreationConfig } from './types';
/**
 * MCP Client class.
 * Connects to MCP servers to enable LLM tool execution and function calling.
 * Supports both local (stdio/process) and remote (HTTP) transports.
 *
 * @example
 * ```typescript
 * // Create MCP client with HTTP transport
 * const mcpClient = await MCPClient.create({
 *   sessionConfig: {
 *     transport: 'http',
 *     endpoint: 'http://localhost:3000',
 *     httpConfig: {
 *       apiKey: process.env.INWORLD_API_KEY || 'fake_api_key',
 *       defaultTimeout: '30s'
 *     }
 *   }
 * });
 *
 * // List available tools
 * const tools = await mcpClient.listTools();
 * console.log(`Available tools: ${tools.tools.map(t => t.name).join(', ')}`);
 *
 * // Call a tool
 * const result = await mcpClient.callTool('calculator', { operation: 'add', a: 5, b: 3 });
 * console.log(`Result: ${result.result}`);
 * ```
 */
export declare class MCPClient {
    private mcpClientInterface;
    /**
     * Creates a new MCPClient instance (internal constructor).
     * Use `MCPClient.create()` static method instead.
     *
     * @param {any} mcpClientInterface - Addon MCPClientInterface instance
     * @internal
     */
    constructor(mcpClientInterface: any);
    /**
     * Creates a new MCPClient instance with the specified configuration.
     * Supports both remote (HTTP) and local (stdio/process) transports.
     *
     * @param {MCPClientCreationConfig} config - MCP client configuration
     * @returns {Promise<MCPClient>} Promise resolving to MCPClient instance
     * @throws {MCPError} If MCP client creation fails
     *
     * @example
     * ```typescript
     * // HTTP transport
     * const httpClient = await MCPClient.create({
     *   sessionConfig: {
     *     transport: 'http',
     *     endpoint: 'http://localhost:3000',
     *     httpConfig: {
     *       apiKey: process.env.INWORLD_API_KEY || 'fake_api_key',
     *       defaultTimeout: '30s'
     *     }
     *   }
     * });
     *
     * // Stdio transport
     * const stdioClient = await MCPClient.create({
     *   sessionConfig: {
     *     transport: 'stdio',
     *     endpoint: 'node mcp-server.js',
     *     stdioConfig: {
     *       env: process.env as Record<string, string>
     *     }
     *   }
     * });
     * ```
     */
    static create(config: MCPClientCreationConfig): Promise<MCPClient>;
    /**
     * Lists all available tools from the MCP server.
     * Returns tool definitions including names, descriptions, and input schemas.
     *
     * @returns {Promise<ToolList>} List of available tools
     * @throws {MCPError} If listing tools fails
     *
     * @example
     * ```typescript
     * const toolList = await mcpClient.listTools();
     *
     * console.log(`Found ${toolList.tools.length} tools:`);
     * toolList.tools.forEach(tool => {
     *   console.log(`- ${tool.name}: ${tool.description}`);
     *   if (tool.properties) {
     *     const schema = JSON.parse(tool.properties);
     *     console.log(`  Schema:`, schema);
     *   }
     * });
     * ```
     */
    listTools(): Promise<ToolList>;
    /**
     * Calls a tool with the specified arguments.
     * Executes the tool on the MCP server and returns the result.
     *
     * @param {ToolCall} toolCall - Tool call with name and arguments
     * @returns {Promise<ToolCallResult>} Tool execution result
     * @throws {MCPError} If tool call fails
     *
     * @example
     * ```typescript
     * // Call a calculator tool
     * const result = await mcpClient.call({
     *   id: 'call-1',
     *   name: 'calculator',
     *   args: JSON.stringify({ operation: 'add', a: 5, b: 3 })
     * });
     *
     * if (result.isError) {
     *   console.error('Tool error:', result.result);
     * } else {
     *   console.log('Tool result:', result.result);
     * }
     * ```
     */
    call(toolCall: ToolCall): Promise<ToolCallResult>;
    /**
     * Convenience method to call a tool by name with arguments.
     * Automatically generates a tool call ID and handles argument serialization.
     *
     * @param {string} toolName - Name of the tool to call
     * @param {object} args - Tool arguments as an object
     * @returns {Promise<ToolCallResult>} Tool execution result
     * @throws {MCPError} If tool call fails
     *
     * @example
     * ```typescript
     * // Simple tool call
     * const result = await mcpClient.callTool('add', { a: 10, b: 20 });
     * console.log(`Result: ${result.result}`);
     *
     * // Greet tool
     * const greeting = await mcpClient.callTool('greet', { name: 'Alice' });
     * console.log(greeting.result);  // "Hello, Alice!"
     * ```
     */
    callTool(toolName: string, args: object): Promise<ToolCallResult>;
    /**
     * Gets information about a specific tool by name.
     *
     * @param {string} toolName - Name of the tool to find
     * @returns {Promise<Tool | null>} Tool definition or null if not found
     * @throws {MCPError} If listing tools fails
     *
     * @example
     * ```typescript
     * const calculatorTool = await mcpClient.getTool('calculator');
     *
     * if (calculatorTool) {
     *   console.log(`Description: ${calculatorTool.description}`);
     *   console.log(`Schema:`, JSON.parse(calculatorTool.properties || '{}'));
     * } else {
     *   console.log('Tool not found');
     * }
     * ```
     */
    getTool(toolName: string): Promise<Tool | null>;
    /**
     * Checks if a specific tool is available.
     *
     * @param {string} toolName - Name of the tool to check
     * @returns {Promise<boolean>} True if tool is available
     * @throws {MCPError} If listing tools fails
     *
     * @example
     * ```typescript
     * if (await mcpClient.hasTool('calculator')) {
     *   const result = await mcpClient.callTool('calculator', { operation: 'multiply', a: 6, b: 7 });
     * } else {
     *   console.log('Calculator tool not available');
     * }
     * ```
     */
    hasTool(toolName: string): Promise<boolean>;
    /**
     * Calls multiple tools in sequence.
     *
     * @param {ToolCall[]} toolCalls - Array of tool calls to execute
     * @returns {Promise<ToolCallResult[]>} Array of tool results
     * @throws {MCPError} If any tool call fails
     *
     * @example
     * ```typescript
     * const results = await mcpClient.callBatch([
     *   { id: 'call-1', name: 'add', args: JSON.stringify({ a: 1, b: 2 }) },
     *   { id: 'call-2', name: 'add', args: JSON.stringify({ a: 3, b: 4 }) },
     *   { id: 'call-3', name: 'multiply', args: JSON.stringify({ a: 5, b: 6 }) }
     * ]);
     *
     * results.forEach((result, i) => {
     *   console.log(`Call ${i + 1}: ${result.result}`);
     * });
     * ```
     */
    callBatch(toolCalls: ToolCall[]): Promise<ToolCallResult[]>;
    /**
     * Gets all tool names available on the server.
     *
     * @returns {Promise<string[]>} Array of tool names
     * @throws {MCPError} If listing tools fails
     *
     * @example
     * ```typescript
     * const toolNames = await mcpClient.getToolNames();
     * console.log('Available tools:', toolNames.join(', '));
     * ```
     */
    getToolNames(): Promise<string[]>;
    /**
     * Calls a tool and parses the result as JSON.
     *
     * @param {string} toolName - Name of the tool to call
     * @param {object} args - Tool arguments
     * @returns {Promise<any>} Parsed JSON result
     * @throws {MCPError} If tool call fails or result is not valid JSON
     *
     * @example
     * ```typescript
     * // Call a tool that returns JSON
     * const data = await mcpClient.callToolWithJsonResult('get_user', { userId: '123' });
     * console.log('User:', data.name, data.email);
     * ```
     */
    callToolWithJsonResult(toolName: string, args: object): Promise<any>;
    /**
     * Filters tools by a predicate function.
     *
     * @param {function} predicate - Function to test each tool
     * @returns {Promise<Tool[]>} Filtered array of tools
     * @throws {MCPError} If listing tools fails
     *
     * @example
     * ```typescript
     * // Find all calculation-related tools
     * const mathTools = await mcpClient.filterTools(
     *   tool => tool.description.toLowerCase().includes('math') ||
     *           tool.description.toLowerCase().includes('calculate')
     * );
     *
     * console.log('Math tools:', mathTools.map(t => t.name));
     * ```
     */
    filterTools(predicate: (tool: Tool) => boolean): Promise<Tool[]>;
}
