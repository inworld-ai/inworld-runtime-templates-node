"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextEmbedder = void 0;
const node_api_1 = require("../../internal/node_api");
const pb_helpers_1 = require("../../internal/pb_helpers");
const errors_1 = require("../errors");
/**
 * Text Embedder class.
 * Generates vector embeddings from text for semantic processing.
 *
 * @example
 * ```typescript
 * // Create embedder instance
 * const embedder = await TextEmbedder.create({
 *   localConfig: {
 *     modelPath: 'models/embeddings/all-MiniLM-L6-v2',
 *     device: { type: 'CPU', index: 0 }
 *   }
 * });
 *
 * // Generate single embedding
 * const embedResponse = await embedder.embed("Hello world");
 * console.log(embedResponse.embedding); // [0.123, -0.456, ...]
 *
 * // Generate batch embeddings
 * const embedBatchResponse = await embedder.embedBatch(["text1", "text2", "text3"]);
 * console.log(embedBatchResponse.embeddings); // Array of embeddings
 * ```
 */
class TextEmbedder {
    /**
     * Creates a new TextEmbedder instance (internal constructor).
     * Use `TextEmbedder.create()` static method instead.
     *
     * @param {any} embedderInterface - Addon TextEmbedderInterface instance
     * @internal
     */
    constructor(embedderInterface) {
        this.embedderInterface = embedderInterface;
    }
    /**
     * Creates a new TextEmbedder instance with the specified configuration.
     *
     * @param {TextEmbedderCreationConfig} config - Embedder creation configuration
     * @returns {Promise<TextEmbedder>} Promise resolving to TextEmbedder instance
     * @throws {EmbeddingError} If embedder creation fails
     *
     * @example
     * ```typescript
     * // Local model
     * const embedder = await TextEmbedder.create({
     *   local_config: {
     *     model_path: 'models/embeddings/all-MiniLM-L6-v2',
     *     device: { type: 'CPU', index: 0 }
     *   }
     * });
     *
     * // Remote API
     * const embedder = await TextEmbedder.create({
     *   remoteConfig: {
     *     provider: 'openai',
     *     modelName: 'text-embedding-ada-002',
     *     apiKey: process.env.INWORLD_API_KEY
     *   }
     * });
     * ```
     */
    static async create(config) {
        var _a, _b;
        try {
            const env = (0, node_api_1.getInworldAddonEnv)();
            const embeddings = env.embeddings;
            let configToRuntime = Object.assign({}, config);
            if (!embeddings) {
                throw new errors_1.EmbeddingError('Embeddings namespace not available in addon environment');
            }
            //FIXME: there is a bug on runtime side. getAvailableDevices returns CPU with index -1,
            // actual should be equal to 0.
            if ((config === null || config === void 0 ? void 0 : config.localConfig) && ((_b = (_a = config.localConfig) === null || _a === void 0 ? void 0 : _a.device) === null || _b === void 0 ? void 0 : _b.type) === 'CPU') {
                configToRuntime.localConfig.device.index =
                    configToRuntime.localConfig.device.index === -1
                        ? 0
                        : configToRuntime.localConfig.device.index;
            }
            const configPb = pb_helpers_1.PbHelper.Embeddings.createTextEmbedderCreationConfig(configToRuntime);
            const factory = embeddings.createTextEmbedderFactory();
            const embedderInterface = await factory.createTextEmbedder(configPb);
            return new TextEmbedder(embedderInterface);
        }
        catch (error) {
            if (error instanceof errors_1.EmbeddingError) {
                throw error;
            }
            throw new errors_1.EmbeddingError(`Failed to create TextEmbedder instance: ${error.message}`, error.stack);
        }
    }
    /**
     * Generates an embedding vector for a single text string.
     *
     * @param {string} text - Text to convert to embedding
     * @returns {Promise<EmbedResponse>} Promise resolving to embedding with values array
     * @throws {EmbeddingError} If embedding generation fails
     *
     * @example
     * ```typescript
     * const embedResponse = await embedder.embed("Hello, world!");
     * console.log(embedResponse.embedding); // [0.123, -0.456, 0.789, ...]
     * console.log(embedResponse.embedding.length); // e.g., 384 for all-MiniLM-L6-v2
     * ```
     */
    async embed(text) {
        try {
            if (typeof text !== 'string') {
                throw new errors_1.EmbeddingError('Text must be a string');
            }
            if (text.length === 0) {
                throw new errors_1.EmbeddingError('Text cannot be empty');
            }
            const requestPb = pb_helpers_1.PbHelper.Embeddings.createTextEmbedRequest({ text });
            const embeddingPb = await this.embedderInterface.embed(requestPb);
            return pb_helpers_1.PbHelper.Embeddings.unpackEmbedding(embeddingPb);
        }
        catch (error) {
            if (error instanceof errors_1.EmbeddingError) {
                throw error;
            }
            throw new errors_1.EmbeddingError(`Failed to generate embedding for text: ${error.message}`, error.stack);
        }
    }
    /**
     * Generates embedding vectors for multiple text strings in a batch.
     * This is more efficient than calling `embed()` multiple times.
     *
     * @param {string[]} texts - Array of text strings to convert to embeddings
     * @returns {Promise<EmbedBatchResponse>} Promise resolving to batch of embeddings
     * @throws {EmbeddingError} If batch embedding generation fails
     *
     * @example
     * ```typescript
     * const embedBatchResponse = await embedder.embedBatch([
     *   "First text",
     *   "Second text",
     *   "Third text"
     * ]);
     *
     * embedBatchResponse.embeddings.forEach((embedding, i) => {
     *   console.log(`Embedding ${i}:`, embedding.slice(0, 5));
     * });
     * ```
     */
    async embedBatch(texts) {
        try {
            if (!Array.isArray(texts)) {
                throw new errors_1.EmbeddingError('Texts must be an array');
            }
            if (texts.length === 0) {
                throw new errors_1.EmbeddingError('Texts array cannot be empty');
            }
            if (texts.some((text) => typeof text !== 'string')) {
                throw new errors_1.EmbeddingError('All texts must be strings');
            }
            const textBatchPb = pb_helpers_1.PbHelper.Embeddings.createTextBatch(texts);
            const batchPb = await this.embedderInterface.embedBatch(textBatchPb);
            return pb_helpers_1.PbHelper.Embeddings.unpackEmbeddingBatch(batchPb);
        }
        catch (error) {
            if (error instanceof errors_1.EmbeddingError) {
                throw error;
            }
            throw new errors_1.EmbeddingError(`Failed to generate batch embeddings for ${(texts === null || texts === void 0 ? void 0 : texts.length) || 0} texts: ${error.message}`, error.stack);
        }
    }
    /**
     * Returns a simple array of numbers from an embedding vector.
     * This is a convenience method for working with embedding values.
     *
     * @param {EmbedResponse} embedResponse - EmbedResponse object
     * @returns {number[]} Array of embedding values
     *
     * @example
     * ```typescript
     * const embedding = await embedder.embed("Hello");
     * const values = TextEmbedder.toArray(embedding);
     * // Same as: const values = embedding.embedding;
     * ```
     */
    static toArray(embedResponse) {
        return Array.from(embedResponse.embedding || []);
    }
}
exports.TextEmbedder = TextEmbedder;
