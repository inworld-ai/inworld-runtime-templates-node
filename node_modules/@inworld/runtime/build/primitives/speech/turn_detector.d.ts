/**
 * Turn Detector primitive using N-API addon.
 * Detects when a speaker has completed their conversational turn.
 */
import type { TurnDetectionResult } from '../types';
import { AudioChunk, TurnDetectorConfig, TurnDetectorCreationConfig } from './types';
/**
 * Turn Detector class.
 * Analyzes audio to detect when a speaker has finished their turn in a conversation.
 * Uses machine learning models to predict turn completion probability.
 *
 * @example
 * ```typescript
 * // Create turn detector with local model
 * const turnDetector = await TurnDetector.create({
 *   localConfig: {
 *     modelPath: 'models/turn_detection/pipecat_smart_turn_v3.onnx',
 *     device: { type: 'CPU', index: 0 },
 *     defaultConfig: { threshold: 0.7 }
 *   }
 * });
 *
 * // Detect turn completion in audio
 * const audioChunk = {
 *   data: new Float32Array(audioBuffer),
 *   sampleRate: 16000
 * };
 *
 * const result = await turnDetector.detectTurnCompletion(audioChunk);
 *
 * if (result.prediction === 1 && result.probability > 0.7) {
 *   console.log(`Turn completed with ${(result.probability * 100).toFixed(1)}% confidence`);
 *   // Stop speaking, allow other party to respond
 * }
 * ```
 */
export declare class TurnDetector {
    private turnDetectorInterface;
    /**
     * Creates a new TurnDetector instance (internal constructor).
     * Use `TurnDetector.create()` static method instead.
     *
     * @param {any} turnDetectorInterface - Addon TurnDetectorInterface instance
     * @internal
     */
    constructor(turnDetectorInterface: any);
    /**
     * Creates a new TurnDetector instance with the specified configuration.
     * Currently only supports local (on-device) models.
     *
     * @param {TurnDetectorCreationConfig} config - Turn detector configuration
     * @returns {Promise<TurnDetector>} Promise resolving to TurnDetector instance
     * @throws {TurnDetectorError} If turn detector creation fails
     *
     * @example
     * ```typescript
     * const turnDetector = await TurnDetector.create({
     *   localConfig: {
     *     modelPath: 'models/turn_detection/pipecat_smart_turn_v3.onnx',
     *     device: { type: 'CPU', index: 0 },
     *     defaultConfig: {
     *       threshold: 0.7  // Confidence threshold for turn completion
     *     }
     *   }
     * });
     * ```
     */
    static create(config: TurnDetectorCreationConfig): Promise<TurnDetector>;
    /**
     * Detects whether a turn has been completed in the provided audio.
     * Returns a prediction (0 or 1) and probability (0-1).
     *
     * @param {AudioChunk} audio - Audio chunk to analyze
     * @param {TurnDetectorConfig} config - Optional detection config
     * @returns {Promise<TurnDetectionResult>} Turn detection result
     * @throws {TurnDetectorError} If detection fails
     *
     * @example
     * ```typescript
     * const audioChunk = {
     *   data: new Float32Array(samples),
     *   sampleRate: 16000
     * };
     *
     * const result = await turnDetector.detectTurnCompletion(audioChunk);
     *
     * console.log('Prediction:', result.prediction);  // 0 (not complete) or 1 (complete)
     * console.log('Probability:', result.probability);  // 0.0 to 1.0
     *
     * if (result.prediction === 1 && result.probability > 0.8) {
     *   console.log('High confidence turn completion detected');
     * }
     * ```
     */
    detectTurnCompletion(audio: AudioChunk, config?: TurnDetectorConfig): Promise<TurnDetectionResult>;
    /**
     * Checks if a turn is completed based on prediction and threshold.
     *
     * @param {AudioChunk} audio - Audio chunk to analyze
     * @param {number} threshold - Probability threshold (default: 0.7)
     * @returns {Promise<boolean>} True if turn is complete
     * @throws {TurnDetectorError} If detection fails
     *
     * @example
     * ```typescript
     * const isTurnComplete = await turnDetector.isTurnComplete(audioChunk, 0.8);
     *
     * if (isTurnComplete) {
     *   console.log('Turn is complete, ready for response');
     *   // Switch to listening mode
     * }
     * ```
     */
    isTurnComplete(audio: AudioChunk, threshold?: number): Promise<boolean>;
    /**
     * Continuously monitors audio chunks for turn completion.
     * Useful for real-time conversation systems.
     *
     * @param {AsyncIterable<AudioChunk>} audioStream - Stream of audio chunks
     * @param {TurnDetectorConfig} config - Detection config
     * @returns {AsyncGenerator<TurnDetectionResult>} Stream of detection results
     * @throws {TurnDetectorError} If detection fails
     *
     * @example
     * ```typescript
     * async function monitorTurns(audioStream) {
     *   for await (const result of turnDetector.monitorTurns(audioStream, { threshold: 0.7 })) {
     *     console.log(`Prediction: ${result.prediction}, Probability: ${result.probability}`);
     *
     *     if (result.prediction === 1 && result.probability > 0.8) {
     *       console.log('Turn completed!');
     *       break;  // Stop monitoring
     *     }
     *   }
     * }
     * ```
     */
    monitorTurns(audioStream: AsyncIterable<AudioChunk>, config?: TurnDetectorConfig): AsyncGenerator<TurnDetectionResult>;
    /**
     * Processes multiple audio chunks and returns their detection results.
     *
     * @param {AudioChunk[]} audioChunks - Array of audio chunks
     * @param {TurnDetectorConfig} config - Detection config
     * @returns {Promise<TurnDetectionResult[]>} Array of detection results
     * @throws {TurnDetectorError} If detection fails
     *
     * @example
     * ```typescript
     * const chunks = [chunk1, chunk2, chunk3];
     * const results = await turnDetector.detectBatch(chunks);
     *
     * results.forEach((result, i) => {
     *   console.log(`Chunk ${i + 1}: Prediction=${result.prediction}, Prob=${result.probability}`);
     * });
     * ```
     */
    detectBatch(audioChunks: AudioChunk[], config?: TurnDetectorConfig): Promise<TurnDetectionResult[]>;
    /**
     * Gets the maximum probability from recent audio chunks.
     * Useful for determining the strongest turn completion signal.
     *
     * @param {AudioChunk[]} audioChunks - Recent audio chunks
     * @param {TurnDetectorConfig} config - Detection config
     * @returns {Promise<TurnDetectionResult>} Result with highest probability
     * @throws {TurnDetectorError} If detection fails
     *
     * @example
     * ```typescript
     * const recentChunks = [chunk1, chunk2, chunk3, chunk4, chunk5];
     * const strongest = await turnDetector.getStrongestSignal(recentChunks);
     *
     * if (strongest.probability > 0.9) {
     *   console.log('Very strong turn completion signal detected');
     * }
     * ```
     */
    getStrongestSignal(audioChunks: AudioChunk[], config?: TurnDetectorConfig): Promise<TurnDetectionResult>;
}
