"use strict";
/**
 * Device Registry using N-API addon.
 * Provides information about available compute devices (CPU, GPU, etc.).
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeviceRegistry = void 0;
const node_api_1 = require("../../internal/node_api");
const pb_helpers_1 = require("../../internal/pb_helpers");
const errors_1 = require("../errors");
/**
 * Device Registry class.
 * Queries and lists available compute devices for model execution.
 * Useful for selecting optimal devices for ML model inference.
 *
 * @example
 * ```typescript
 * // Get available devices
 * const devices = await DeviceRegistry.getAvailableDevices();
 *
 * console.log(`Found ${devices.length} devices:`);
 * devices.forEach(device => {
 *   console.log(`- ${device.type} ${device.index}: ${device.info?.name}`);
 *   console.log(`  Memory: ${device.info?.freeMemoryBytes} / ${device.info?.totalMemoryBytes} bytes`);
 * });
 *
 * // Find best GPU
 * const gpus = devices.filter(d => d.type === 'CUDA');
 * if (gpus.length > 0) {
 *   console.log('Using GPU:', gpus[0]);
 * }
 * ```
 */
class DeviceRegistry {
    /**
     * Gets a list of all available compute devices.
     * Returns device descriptors with type, index, and hardware information.
     *
     * @returns {Promise<DeviceDescriptor[]>} Array of available devices
     * @throws {DeviceError} If device query fails
     *
     * @example
     * ```typescript
     * const devices = await DeviceRegistry.getAvailableDevices();
     *
     * devices.forEach(device => {
     *   console.log(`Device: ${device.type} ${device.index}`);
     *
     *   if (device.info) {
     *     console.log(`  Name: ${device.info.name}`);
     *     console.log(`  Free Memory: ${(device.info.freeMemoryBytes / 1024 / 1024).toFixed(2)} MB`);
     *     console.log(`  Total Memory: ${(device.info.totalMemoryBytes / 1024 / 1024).toFixed(2)} MB`);
     *   }
     * });
     * ```
     */
    static async getAvailableDevices() {
        try {
            const env = (0, node_api_1.getInworldAddonEnv)();
            const platform = env.platform;
            if (!platform) {
                throw new errors_1.DeviceError('Platform namespace not available in addon environment');
            }
            const deviceRegistry = platform.getDeviceRegistry();
            const devicesPb = await deviceRegistry.getAvailableDevices();
            // Convert protobuf messages to DeviceDescriptor objects
            const devices = devicesPb.map((devicePb) => pb_helpers_1.PbHelper.Platform.unpackDevice(devicePb));
            return devices;
        }
        catch (error) {
            if (error instanceof errors_1.DeviceError) {
                throw error;
            }
            throw new errors_1.DeviceError(`Failed to get available devices: ${error.message}`, error.stack);
        }
    }
    /**
     * Filters devices by type.
     *
     * @param {DeviceType | string} deviceType - Device type to filter by
     * @returns {Promise<DeviceDescriptor[]>} Devices of specified type
     * @throws {DeviceError} If device query fails
     *
     * @example
     * ```typescript
     * // Get all CUDA GPUs
     * const gpus = await DeviceRegistry.getDevicesByType('CUDA');
     * console.log(`Found ${gpus.length} CUDA devices`);
     *
     * // Get CPU devices
     * const cpus = await DeviceRegistry.getDevicesByType('CPU');
     * ```
     */
    static async getDevicesByType(deviceType) {
        const devices = await DeviceRegistry.getAvailableDevices();
        return devices.filter((device) => device.type === deviceType);
    }
    /**
     * Gets the best available device based on available memory.
     * Prioritizes GPUs over CPUs if available.
     *
     * @returns {Promise<DeviceDescriptor | null>} Best device or null if none available
     * @throws {DeviceError} If device query fails
     *
     * @example
     * ```typescript
     * const bestDevice = await DeviceRegistry.getBestDevice();
     *
     * if (bestDevice) {
     *   console.log(`Using ${bestDevice.type} ${bestDevice.index}`);
     *
     *   // Use device for model creation
     *   const model = await Model.create({
     *     localConfig: {
     *       modelPath: 'model.onnx',
     *       device: {
     *         type: bestDevice.type,
     *         index: bestDevice.index
     *       }
     *     }
     *   });
     * } else {
     *   console.log('No devices available');
     * }
     * ```
     */
    static async getBestDevice() {
        const devices = await DeviceRegistry.getAvailableDevices();
        if (devices.length === 0) {
            return null;
        }
        // Prioritize GPUs (CUDA, METAL, OPENCL) over CPU
        const gpuTypes = ['CUDA', 'METAL', 'OPENCL'];
        const gpus = devices.filter((d) => gpuTypes.includes(d.type));
        if (gpus.length > 0) {
            // Return GPU with most free memory
            return gpus.reduce((best, current) => {
                var _a, _b;
                const bestFree = ((_a = best.info) === null || _a === void 0 ? void 0 : _a.freeMemoryBytes) || 0;
                const currentFree = ((_b = current.info) === null || _b === void 0 ? void 0 : _b.freeMemoryBytes) || 0;
                return currentFree > bestFree ? current : best;
            });
        }
        // Return CPU if no GPUs available
        const cpus = devices.filter((d) => d.type === 'CPU');
        return cpus.length > 0 ? cpus[0] : devices[0];
    }
    /**
     * Gets all GPU devices (CUDA, METAL, OPENCL).
     *
     * @returns {Promise<DeviceDescriptor[]>} Array of GPU devices
     * @throws {DeviceError} If device query fails
     *
     * @example
     * ```typescript
     * const gpus = await DeviceRegistry.getGPUDevices();
     *
     * if (gpus.length > 0) {
     *   console.log('Available GPUs:');
     *   gpus.forEach((gpu, i) => {
     *     console.log(`  ${i + 1}. ${gpu.type} ${gpu.index}: ${gpu.info?.name}`);
     *   });
     * } else {
     *   console.log('No GPUs available, falling back to CPU');
     * }
     * ```
     */
    static async getGPUDevices() {
        const devices = await DeviceRegistry.getAvailableDevices();
        const gpuTypes = ['CUDA', 'METAL', 'OPENCL'];
        return devices.filter((d) => gpuTypes.includes(d.type));
    }
    /**
     * Gets all CPU devices.
     *
     * @returns {Promise<DeviceDescriptor[]>} Array of CPU devices
     * @throws {DeviceError} If device query fails
     *
     * @example
     * ```typescript
     * const cpus = await DeviceRegistry.getCPUDevices();
     * console.log(`${cpus.length} CPU device(s) available`);
     * ```
     */
    static async getCPUDevices() {
        return DeviceRegistry.getDevicesByType('CPU');
    }
    /**
     * Checks if a specific device type is available.
     *
     * @param {DeviceType | string} deviceType - Device type to check
     * @returns {Promise<boolean>} True if device type is available
     * @throws {DeviceError} If device query fails
     *
     * @example
     * ```typescript
     * const hasCuda = await DeviceRegistry.hasDeviceType('CUDA');
     *
     * if (hasCuda) {
     *   console.log('CUDA GPU available, using GPU acceleration');
     * } else {
     *   console.log('No CUDA GPU, using CPU');
     * }
     * ```
     */
    static async hasDeviceType(deviceType) {
        const devices = await DeviceRegistry.getDevicesByType(deviceType);
        return devices.length > 0;
    }
    /**
     * Gets device by type and index.
     *
     * @param {DeviceType | string} deviceType - Device type
     * @param {number} index - Device index
     * @returns {Promise<DeviceDescriptor | null>} Device or null if not found
     * @throws {DeviceError} If device query fails
     *
     * @example
     * ```typescript
     * // Get second CUDA GPU
     * const gpu1 = await DeviceRegistry.getDevice('CUDA', 1);
     *
     * if (gpu1) {
     *   console.log('Using CUDA device 1');
     * } else {
     *   console.log('CUDA device 1 not available');
     * }
     * ```
     */
    static async getDevice(deviceType, index) {
        const devices = await DeviceRegistry.getAvailableDevices();
        return (devices.find((d) => d.type === deviceType && d.index === index) || null);
    }
    /**
     * Gets total and free memory across all devices of a type.
     *
     * @param {DeviceType | string} deviceType - Device type
     * @returns {Promise<{total: number, free: number}>} Memory info in bytes
     * @throws {DeviceError} If device query fails
     *
     * @example
     * ```typescript
     * const cudaMemory = await DeviceRegistry.getTotalMemory('CUDA');
     *
     * console.log(`Total CUDA memory: ${(cudaMemory.total / 1024 / 1024 / 1024).toFixed(2)} GB`);
     * console.log(`Free CUDA memory: ${(cudaMemory.free / 1024 / 1024 / 1024).toFixed(2)} GB`);
     * ```
     */
    static async getTotalMemory(deviceType) {
        const devices = await DeviceRegistry.getDevicesByType(deviceType);
        const total = devices.reduce((sum, device) => { var _a; return sum + (((_a = device.info) === null || _a === void 0 ? void 0 : _a.totalMemoryBytes) || 0); }, 0);
        const free = devices.reduce((sum, device) => { var _a; return sum + (((_a = device.info) === null || _a === void 0 ? void 0 : _a.freeMemoryBytes) || 0); }, 0);
        return { total, free };
    }
    /**
     * Gets summary of all available devices.
     *
     * @returns {Promise<string>} Human-readable device summary
     * @throws {DeviceError} If device query fails
     *
     * @example
     * ```typescript
     * const summary = await DeviceRegistry.getSummary();
     * console.log(summary);
     * // Output:
     * // Available Devices:
     * //   CPU 0: Intel Core i9 (32 cores)
     * //   CUDA 0: NVIDIA RTX 3090 (24 GB)
     * //   CUDA 1: NVIDIA RTX 3080 (10 GB)
     * ```
     */
    static async getSummary() {
        const devices = await DeviceRegistry.getAvailableDevices();
        if (devices.length === 0) {
            return 'No devices available';
        }
        const lines = ['Available Devices:'];
        devices.forEach((device) => {
            var _a;
            const memoryMB = device.info
                ? `${(device.info.totalMemoryBytes / 1024 / 1024).toFixed(0)} MB`
                : 'Unknown';
            lines.push(`  ${device.type} ${device.index}: ${((_a = device.info) === null || _a === void 0 ? void 0 : _a.name) || 'Unknown'} (${memoryMB})`);
        });
        return lines.join('\n');
    }
}
exports.DeviceRegistry = DeviceRegistry;
