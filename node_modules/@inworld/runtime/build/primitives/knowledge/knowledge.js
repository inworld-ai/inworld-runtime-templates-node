"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Knowledge = void 0;
const node_api_1 = require("../../internal/node_api");
const pb_helpers_1 = require("../../internal/pb_helpers");
const errors_1 = require("../errors");
/**
 * Knowledge class for Retrieval-Augmented Generation (RAG).
 * Supports compiling, storing, and retrieving knowledge records for enhanced LLM context.
 *
 * @example
 * ```typescript
 * // Create Knowledge instance with remote config
 * const knowledge = await Knowledge.create({
 *   remoteConfig: {
 *     apiKey: process.env.INWORLD_API_KEY,
 *     defaultTimeout: { seconds: 30 }
 *   }
 * });
 *
 * // Compile knowledge from text records
 * const knowledgeId = 'knowledge/my-knowledge-base';
 * await knowledge.compileKnowledge({
 *   knowledgeId,
 *   records: [
 *     { id: '1', content: 'The capital of France is Paris.' },
 *     { id: '2', content: 'France is a country in Europe.' }
 *   ]
 * });
 *
 * // Retrieve knowledge by search query
 * const results = await knowledge.getKnowledge({
 *   ids: [knowledgeId],
 *   searchQuery: 'capital of France'
 * });
 *
 * // Use retrieved knowledge to augment LLM context
 * for (const record of results.records) {
 *   console.log(`[${record.id}] ${record.content}`);
 * }
 *
 * // Cleanup
 * await knowledge.removeKnowledge(knowledgeId);
 * ```
 */
class Knowledge {
    /**
     * Creates a new Knowledge instance (internal constructor).
     * Use `Knowledge.create()` static method instead.
     *
     * @param {any} knowledgeInterface - Addon KnowledgeInterface instance
     * @internal
     */
    constructor(knowledgeInterface) {
        this.knowledgeInterface = knowledgeInterface;
    }
    /**
     * Creates a new Knowledge instance with the specified configuration.
     * Supports both remote (API-based) and local (embedder-based) configurations.
     *
     * @param {KnowledgeCreationConfig} config - Knowledge configuration
     * @returns {Promise<Knowledge>} Promise resolving to Knowledge instance
     * @throws {KnowledgeError} If Knowledge creation fails
     *
     * @example
     * ```typescript
     * // Remote configuration (cloud-based)
     * const remoteKnowledge = await Knowledge.create({
     *   remoteConfig: {
     *     apiKey: process.env.INWORLD_API_KEY,
     *     endpointOverride: 'https://custom-endpoint.com',
     *     defaultTimeout: { seconds: 30 }
     *   }
     * });
     *
     * // Local configuration (on-device)
     * const localKnowledge = await Knowledge.create({
     *   localConfig: {
     *     embedderConfig: {
     *       localConfig: {
     *         modelPath: 'models/embedders/my-embedder.gguf',
     *         device: { type: 'CPU', index: 0 }
     *       }
     *     },
     *     vectorStoreConfig: {
     *       type: 'faiss',
     *       dimension: 768
     *     }
     *   }
     * });
     * ```
     */
    static async create(config) {
        try {
            const env = (0, node_api_1.getInworldAddonEnv)();
            const knowledgeNamespace = env.knowledge;
            if (!knowledgeNamespace) {
                throw new errors_1.KnowledgeError('Knowledge namespace not available in addon environment');
            }
            const factory = knowledgeNamespace.createKnowledgeFactory();
            const configPb = pb_helpers_1.PbHelper.Knowledge.createKnowledgeCreationConfig(config);
            const knowledgeInterface = await factory.createKnowledge(configPb);
            return new Knowledge(knowledgeInterface);
        }
        catch (error) {
            if (error instanceof errors_1.KnowledgeError) {
                throw error;
            }
            throw new errors_1.KnowledgeError(`Failed to create Knowledge instance: ${error.message}`, error.stack);
        }
    }
    /**
     * Retrieves knowledge records by ID or search query.
     * Can retrieve by specific knowledge IDs, search query, or both.
     *
     * @param {GetKnowledgeRequest} request - Retrieval request
     * @returns {Promise<KnowledgeRecords>} Retrieved knowledge records
     * @throws {KnowledgeError} If retrieval fails
     *
     * @example
     * ```typescript
     * // Retrieve by knowledge ID only
     * const byId = await knowledge.getKnowledge({
     *   ids: ['knowledge/my-knowledge-1', 'knowledge/my-knowledge-2']
     * });
     *
     * // Retrieve by search query (requires knowledge ID)
     * const byQuery = await knowledge.getKnowledge({
     *   ids: ['knowledge/my-knowledge-1'],
     *   searchQuery: 'Paris Eiffel Tower'
     * });
     *
     * // With retrieval config
     * const withConfig = await knowledge.getKnowledge({
     *   ids: ['knowledge/my-knowledge-1'],
     *   searchQuery: 'France',
     *   retrievalConfig: { topK: 5 }
     * });
     *
     * console.log(`Found ${byQuery.records.length} matching records`);
     * ```
     */
    async getKnowledge(request) {
        try {
            if (!request.ids && !request.searchQuery) {
                throw new errors_1.KnowledgeError('Either ids or searchQuery must be provided');
            }
            const requestPb = pb_helpers_1.PbHelper.Knowledge.createGetKnowledgeRequest(request.ids || [], request.searchQuery || '');
            const responsePb = await this.knowledgeInterface.getKnowledge(requestPb);
            return pb_helpers_1.PbHelper.Knowledge.unpackKnowledgeRecords(responsePb);
        }
        catch (error) {
            if (error instanceof errors_1.KnowledgeError) {
                throw error;
            }
            throw new errors_1.KnowledgeError(`Failed to get knowledge: ${error.message}`, error.stack);
        }
    }
    /**
     * Compiles knowledge from an array of text records.
     * Creates embeddings and stores them for later retrieval.
     *
     * @param {CompileKnowledgeRequest} request - Compilation request with knowledge ID and records
     * @returns {Promise<KnowledgeRecords>} Compiled knowledge records
     * @throws {KnowledgeError} If compilation fails
     *
     * @example
     * ```typescript
     * const knowledgeId = 'knowledge/my-docs';
     *
     * const compiled = await knowledge.compileKnowledge({
     *   knowledgeId,
     *   records: [
     *     { id: '1', content: 'Machine learning is a subset of AI.' },
     *     { id: '2', content: 'Deep learning uses neural networks.' },
     *     { id: '3', content: 'Natural language processing handles text.' }
     *   ]
     * });
     *
     * console.log(`Compiled ${compiled.records.length} records`);
     * ```
     */
    async compileKnowledge(request) {
        try {
            if (!request.knowledgeId) {
                throw new errors_1.KnowledgeError('Knowledge ID is required');
            }
            if (!Array.isArray(request.records) || request.records.length === 0) {
                throw new errors_1.KnowledgeError('Records must be a non-empty array');
            }
            const requestPb = pb_helpers_1.PbHelper.Knowledge.createCompileKnowledgeRequest(request.knowledgeId, request.records);
            const responsePb = await this.knowledgeInterface.compileKnowledge(requestPb);
            return pb_helpers_1.PbHelper.Knowledge.unpackKnowledgeRecords(responsePb);
        }
        catch (error) {
            if (error instanceof errors_1.KnowledgeError) {
                throw error;
            }
            throw new errors_1.KnowledgeError(`Failed to compile knowledge: ${error.message}`, error.stack);
        }
    }
    /**
     * Compiles knowledge from a file.
     * Supports various file formats (text, JSON, etc.).
     *
     * @param {CompileKnowledgeFromFileRequest} request - Compilation request with file path
     * @returns {Promise<KnowledgeRecords>} Compiled knowledge records
     * @throws {KnowledgeError} If compilation fails
     *
     * @example
     * ```typescript
     * // Compile from text file
     * const compiled = await knowledge.compileKnowledgeFromFile({
     *   knowledgeId: 'knowledge/docs-from-file',
     *   file: 'path/to/documentation.txt'
     * });
     *
     * console.log(`Compiled ${compiled.records.length} records from file`);
     * ```
     */
    async compileKnowledgeFromFile(request) {
        try {
            if (!request.knowledgeId) {
                throw new errors_1.KnowledgeError('Knowledge ID is required');
            }
            if (!request.file) {
                throw new errors_1.KnowledgeError('File path is required');
            }
            const requestPb = pb_helpers_1.PbHelper.Knowledge.createCompileKnowledgeFromFileRequest(request.knowledgeId, request.file);
            const responsePb = await this.knowledgeInterface.compileKnowledgeFromFile(requestPb);
            return pb_helpers_1.PbHelper.Knowledge.unpackKnowledgeRecords(responsePb);
        }
        catch (error) {
            if (error instanceof errors_1.KnowledgeError) {
                throw error;
            }
            throw new errors_1.KnowledgeError(`Failed to compile knowledge from file: ${error.message}`, error.stack);
        }
    }
    /**
     * Removes knowledge by ID.
     * Deletes all associated records and embeddings.
     *
     * @param {string} knowledgeId - Knowledge ID to remove
     * @returns {Promise<void>}
     * @throws {KnowledgeError} If removal fails
     *
     * @example
     * ```typescript
     * await knowledge.removeKnowledge('knowledge/my-knowledge-base');
     * console.log('Knowledge removed successfully');
     * ```
     */
    async removeKnowledge(knowledgeId) {
        try {
            if (!knowledgeId || typeof knowledgeId !== 'string') {
                throw new errors_1.KnowledgeError('Knowledge ID must be a non-empty string');
            }
            await this.knowledgeInterface.removeKnowledge(knowledgeId);
        }
        catch (error) {
            if (error instanceof errors_1.KnowledgeError) {
                throw error;
            }
            throw new errors_1.KnowledgeError(`Failed to remove knowledge: ${error.message}`, error.stack);
        }
    }
    /**
     * Searches knowledge with a query string.
     * Convenience method that wraps getKnowledge with search query.
     *
     * @param {string[]} knowledgeIds - Knowledge IDs to search
     * @param {string} query - Search query
     * @param {number} topK - Maximum number of results (optional)
     * @returns {Promise<KnowledgeRecords>} Search results
     * @throws {KnowledgeError} If search fails
     *
     * @example
     * ```typescript
     * const results = await knowledge.search(
     *   ['knowledge/docs'],
     *   'How to use the API?',
     *   5  // Top 5 results
     * );
     *
     * for (const record of results.records) {
     *   console.log(`[Score: ${record.metadata?.score}] ${record.content}`);
     * }
     * ```
     */
    async search(knowledgeIds, query, topK) {
        return this.getKnowledge({
            ids: knowledgeIds,
            searchQuery: query,
            retrievalConfig: topK ? { topK } : undefined,
        });
    }
    /**
     * Batch compiles multiple knowledge sets.
     *
     * @param {CompileKnowledgeRequest[]} requests - Array of compilation requests
     * @returns {Promise<KnowledgeRecords[]>} Array of compilation results
     * @throws {KnowledgeError} If any compilation fails
     *
     * @example
     * ```typescript
     * const results = await knowledge.compileBatch([
     *   {
     *     knowledgeId: 'knowledge/category-1',
     *     records: [{ id: '1', content: 'Text 1' }]
     *   },
     *   {
     *     knowledgeId: 'knowledge/category-2',
     *     records: [{ id: '2', content: 'Text 2' }]
     *   }
     * ]);
     *
     * console.log(`Compiled ${results.length} knowledge sets`);
     * ```
     */
    async compileBatch(requests) {
        if (!Array.isArray(requests)) {
            throw new errors_1.KnowledgeError('Requests must be an array');
        }
        return Promise.all(requests.map((request) => this.compileKnowledge(request)));
    }
    /**
     * Batch removes multiple knowledge sets.
     *
     * @param {string[]} knowledgeIds - Array of knowledge IDs to remove
     * @returns {Promise<void>}
     * @throws {KnowledgeError} If any removal fails
     *
     * @example
     * ```typescript
     * await knowledge.removeBatch([
     *   'knowledge/old-docs-1',
     *   'knowledge/old-docs-2',
     *   'knowledge/old-docs-3'
     * ]);
     * ```
     */
    async removeBatch(knowledgeIds) {
        if (!Array.isArray(knowledgeIds)) {
            throw new errors_1.KnowledgeError('Knowledge IDs must be an array');
        }
        await Promise.all(knowledgeIds.map((id) => this.removeKnowledge(id)));
    }
}
exports.Knowledge = Knowledge;
