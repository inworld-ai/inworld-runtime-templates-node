"use strict";
/**
 * Keyword Matcher primitive using N-API addon.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeywordMatcher = void 0;
const node_api_1 = require("../../internal/node_api");
const pb_helpers_1 = require("../../internal/pb_helpers");
const errors_1 = require("../errors");
/**
 * Keyword Matcher class.
 * Matches keywords and phrases in text based on predefined groups.
 * Useful for intent detection, command recognition, and content filtering.
 *
 * @example
 * ```typescript
 * // Create keyword matcher with groups
 * const matcher = await KeywordMatcher.create([
 *   {
 *     name: "greetings",
 *     keywords: ["hello", "hi", "hey", "greetings"]
 *   },
 *   {
 *     name: "farewells",
 *     keywords: ["goodbye", "bye", "see you", "farewell"]
 *   },
 *   {
 *     name: "questions",
 *     keywords: ["what", "when", "where", "why", "how"]
 *   }
 * ]);
 *
 * // Match keywords in text
 * const result = await matcher.matchKeywords("Hello! How are you?");
 *
 * // Check results
 * for (const match of result.matches) {
 *   console.log(`Found "${match.keyword}" in group "${match.groupName}"`);
 * }
 * ```
 */
class KeywordMatcher {
    /**
     * Creates a new KeywordMatcher instance (internal constructor).
     * Use `KeywordMatcher.create()` static method instead.
     *
     * @param {any} matcherInterface - Addon KeywordMatcherInterface instance
     * @internal
     */
    constructor(matcherInterface) {
        this.matcherInterface = matcherInterface;
    }
    /**
     * Creates a new KeywordMatcher instance with the specified keyword groups.
     *
     * @param {KeywordGroup[]} keywordGroups - Array of keyword groups
     * @returns {Promise<KeywordMatcher>} Promise resolving to KeywordMatcher instance
     * @throws {KeywordMatcherError} If matcher creation fails
     *
     * @example
     * ```typescript
     * // Create matcher for intent detection
     * const matcher = await KeywordMatcher.create([
     *   {
     *     name: "order_intent",
     *     keywords: ["buy", "purchase", "order", "get"]
     *   },
     *   {
     *     name: "cancel_intent",
     *     keywords: ["cancel", "refund", "return"]
     *   },
     *   {
     *     name: "help_intent",
     *     keywords: ["help", "support", "assistance", "question"]
     *   }
     * ]);
     * ```
     */
    static async create(keywordGroups) {
        try {
            const env = (0, node_api_1.getInworldAddonEnv)();
            const nlu = env.nlu;
            if (!nlu) {
                throw new errors_1.KeywordMatcherError('NLU namespace not available in addon environment');
            }
            if (!Array.isArray(keywordGroups) || keywordGroups.length === 0) {
                throw new errors_1.KeywordMatcherError('Keyword groups must be a non-empty array');
            }
            // Validate keyword groups
            for (const group of keywordGroups) {
                if (!group.name || typeof group.name !== 'string') {
                    throw new errors_1.KeywordMatcherError('Each keyword group must have a name');
                }
                if (!Array.isArray(group.keywords) || group.keywords.length === 0) {
                    throw new errors_1.KeywordMatcherError(`Keyword group "${group.name}" must have at least one keyword`);
                }
            }
            const factory = nlu.createKeywordMatcherFactory();
            // Convert keyword groups to protobuf format
            const keywordGroupsPb = keywordGroups.map((group) => pb_helpers_1.PbHelper.NLU.createKeywordGroup(group));
            const matcherInterface = await factory.createKeywordMatcher(keywordGroupsPb);
            return new KeywordMatcher(matcherInterface);
        }
        catch (error) {
            if (error instanceof errors_1.KeywordMatcherError) {
                throw error;
            }
            throw new errors_1.KeywordMatcherError(`Failed to create KeywordMatcher instance: ${error.message}`, error.stack);
        }
    }
    /**
     * Matches keywords in the provided text.
     * Returns all matches with their group names and positions.
     *
     * @param {string} text - Text to search for keywords
     * @returns {Promise<KeywordMatcherResponse>} Keyword matches
     * @throws {KeywordMatcherError} If keyword matching fails
     *
     * @example
     * ```typescript
     * const text = "Hello! How are you? What's the weather today?";
     * const result = await matcher.matchKeywords(text);
     *
     * console.log(`Found ${result.matches.length} matches`);
     * result.matches.forEach(match => {
     *   console.log(`- "${match.keyword}" from group "${match.groupName}"`);
     * });
     * ```
     */
    async matchKeywords(text) {
        try {
            if (!text || typeof text !== 'string') {
                throw new errors_1.KeywordMatcherError('Text must be a non-empty string');
            }
            const responsePb = await this.matcherInterface.matchKeywords(text);
            return pb_helpers_1.PbHelper.NLU.unpackKeywordMatcherResponse(responsePb);
        }
        catch (error) {
            if (error instanceof errors_1.KeywordMatcherError) {
                throw error;
            }
            throw new errors_1.KeywordMatcherError(`Failed to match keywords: ${error.message}`, error.stack);
        }
    }
    /**
     * Checks if text contains any keywords from the specified groups.
     *
     * @param {string} text - Text to check
     * @param {string[]} groupNames - Names of groups to check
     * @returns {Promise<boolean>} True if any keywords from specified groups found
     * @throws {KeywordMatcherError} If keyword matching fails
     *
     * @example
     * ```typescript
     * const hasGreeting = await matcher.hasKeywordsFromGroups(
     *   "Hello there!",
     *   ["greetings"]
     * );
     *
     * if (hasGreeting) {
     *   console.log('User said hello!');
     * }
     * ```
     */
    async hasKeywordsFromGroups(text, groupNames) {
        const result = await this.matchKeywords(text);
        return result.matches.some((match) => groupNames.includes(match.groupName));
    }
    /**
     * Gets all matches for specific keyword groups.
     *
     * @param {string} text - Text to search
     * @param {string[]} groupNames - Names of groups to filter
     * @returns {Promise<KeywordMatchResult[]>} Filtered keyword matches
     * @throws {KeywordMatcherError} If keyword matching fails
     *
     * @example
     * ```typescript
     * // Get only question keywords
     * const questions = await matcher.getMatchesForGroups(
     *   "What is your name? How old are you?",
     *   ["questions"]
     * );
     *
     * console.log(`Found ${questions.length} question keywords`);
     * ```
     */
    async getMatchesForGroups(text, groupNames) {
        const result = await this.matchKeywords(text);
        return result.matches.filter((match) => groupNames.includes(match.groupName));
    }
    /**
     * Gets all matched groups (unique group names).
     *
     * @param {string} text - Text to search
     * @returns {Promise<string[]>} Array of unique group names that had matches
     * @throws {KeywordMatcherError} If keyword matching fails
     *
     * @example
     * ```typescript
     * const text = "Hello! I need help with my order.";
     * const groups = await matcher.getMatchedGroups(text);
     *
     * console.log('Detected intents:', groups);
     * // Output: ["greetings", "help_intent", "order_intent"]
     * ```
     */
    async getMatchedGroups(text) {
        const result = await this.matchKeywords(text);
        const uniqueGroups = new Set();
        for (const match of result.matches) {
            uniqueGroups.add(match.groupName);
        }
        return Array.from(uniqueGroups);
    }
    /**
     * Checks if text contains keywords from all specified groups.
     *
     * @param {string} text - Text to check
     * @param {string[]} groupNames - Names of groups that must all be present
     * @returns {Promise<boolean>} True if all specified groups have matches
     * @throws {KeywordMatcherError} If keyword matching fails
     *
     * @example
     * ```typescript
     * // Check if text has both greeting and question
     * const hasGreetingAndQuestion = await matcher.hasAllGroups(
     *   "Hello! What is your name?",
     *   ["greetings", "questions"]
     * );
     *
     * console.log(hasGreetingAndQuestion); // true
     * ```
     */
    async hasAllGroups(text, groupNames) {
        const matchedGroups = await this.getMatchedGroups(text);
        return groupNames.every((group) => matchedGroups.includes(group));
    }
    /**
     * Gets the count of matches per group.
     *
     * @param {string} text - Text to analyze
     * @returns {Promise<Record<string, number>>} Map of group names to match counts
     * @throws {KeywordMatcherError} If keyword matching fails
     *
     * @example
     * ```typescript
     * const text = "What is your name? How are you? Where are you from?";
     * const counts = await matcher.getMatchCountsByGroup(text);
     *
     * console.log(counts);
     * // { "questions": 3 }
     * ```
     */
    async getMatchCountsByGroup(text) {
        const result = await this.matchKeywords(text);
        const counts = {};
        for (const match of result.matches) {
            counts[match.groupName] = (counts[match.groupName] || 0) + 1;
        }
        return counts;
    }
    /**
     * Batch matches keywords in multiple texts.
     *
     * @param {string[]} texts - Array of texts to search
     * @returns {Promise<KeywordMatcherResponse[]>} Array of match results
     * @throws {KeywordMatcherError} If keyword matching fails
     *
     * @example
     * ```typescript
     * const messages = [
     *   "Hello there!",
     *   "I need help with my order",
     *   "Goodbye!"
     * ];
     *
     * const results = await matcher.matchBatch(messages);
     *
     * results.forEach((result, index) => {
     *   console.log(`Message ${index + 1}:`, result.matches);
     * });
     * ```
     */
    async matchBatch(texts) {
        if (!Array.isArray(texts)) {
            throw new errors_1.KeywordMatcherError('Texts must be an array');
        }
        return Promise.all(texts.map((text) => this.matchKeywords(text)));
    }
    /**
     * Finds the most dominant keyword group in text (by match count).
     *
     * @param {string} text - Text to analyze
     * @returns {Promise<{groupName: string, count: number} | null>} Dominant group or null
     * @throws {KeywordMatcherError} If keyword matching fails
     *
     * @example
     * ```typescript
     * const text = "What is it? How does it work? When can I use it?";
     * const dominant = await matcher.getDominantGroup(text);
     *
     * if (dominant) {
     *   console.log(`Primary intent: ${dominant.groupName} (${dominant.count} matches)`);
     * }
     * ```
     */
    async getDominantGroup(text) {
        const counts = await this.getMatchCountsByGroup(text);
        const entries = Object.entries(counts);
        if (entries.length === 0) {
            return null;
        }
        const [groupName, count] = entries.reduce((max, current) => current[1] > max[1] ? current : max);
        return { groupName, count };
    }
}
exports.KeywordMatcher = KeywordMatcher;
