"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NER = void 0;
const node_api_1 = require("../../internal/node_api");
const pb_helpers_1 = require("../../internal/pb_helpers");
const errors_1 = require("../errors");
/**
 * Named Entity Recognition (NER) class.
 * Extracts named entities (people, places, organizations, etc.) from text.
 *
 * @example
 * ```typescript
 * // Create NER instance
 * const ner = await NER.create({
 *   localConfig: {
 *     dictionaryRules: [
 *       {
 *         entityType: 'PERSON',
 *         patterns: ['John', 'Alice', 'Bob']
 *       },
 *       {
 *         entityType: 'ORG',
 *         patterns: ['Google', 'Microsoft', 'Apple']
 *       }
 *     ]
 *   }
 * });
 *
 * // Extract entities
 * const entities = await ner.extractEntities("John works at Google");
 * // Result: [
 * //   { text: "John", type: "PERSON", start: 0, end: 4 },
 * //   { text: "Google", type: "ORG", start: 14, end: 20 }
 * // ]
 * ```
 */
class NER {
    /**
     * Creates a new NER instance (internal constructor).
     * Use `NER.create()` static method instead.
     *
     * @param {any} nerInterface - Addon NERInterface instance
     * @internal
     */
    constructor(nerInterface) {
        this.nerInterface = nerInterface;
    }
    /**
     * Creates a new NER instance with the specified configuration.
     *
     * @param {NERCreationConfig} config - NER creation configuration
     * @returns {Promise<NER>} Promise resolving to NER instance
     * @throws {NERError} If NER creation fails
     *
     * @example
     * ```typescript
     * const ner = await NER.create({
     *   localConfig: {
     *     dictionaryRules: [
     *       {
     *         entityType: 'PERSON',
     *         patterns: ['John Doe', 'Jane Smith']
     *       },
     *       {
     *         entityType: 'LOCATION',
     *         patterns: ['New York', 'San Francisco']
     *       },
     *       {
     *         entityType: 'ORG',
     *         patterns: ['Acme Corp', 'TechCo Inc']
     *       }
     *     ]
     *   }
     * });
     * ```
     */
    static async create(config) {
        try {
            const env = (0, node_api_1.getInworldAddonEnv)();
            const nlu = env.nlu;
            if (!nlu) {
                throw new errors_1.NERError('NLU namespace not available in addon environment');
            }
            const factory = nlu.createNERFactory();
            const configPb = pb_helpers_1.PbHelper.NLU.createNERCreationConfig(config);
            const nerInterface = await factory.createNER(configPb);
            return new NER(nerInterface);
        }
        catch (error) {
            if (error instanceof errors_1.NERError) {
                throw error;
            }
            throw new errors_1.NERError(`Failed to create NER instance: ${error.message}`, error.stack);
        }
    }
    /**
     * Extracts named entities from the provided text.
     * Returns an array of entity matches with their text, type, and positions.
     *
     * @param {string} text - Text to analyze for entities
     * @returns {Promise<EntityMatch[]>} Array of entity matches
     * @throws {NERError} If entity extraction fails
     *
     * @example
     * ```typescript
     * const text = "John Doe works at Microsoft in Seattle";
     * const entities = await ner.extractEntities(text);
     *
     * entities.forEach(entity => {
     *   console.log(`Found ${entity.type}: "${entity.text}" at position ${entity.start}-${entity.end}`);
     * });
     *
     * // Output:
     * // Found PERSON: "John Doe" at position 0-8
     * // Found ORG: "Microsoft" at position 18-27
     * // Found LOCATION: "Seattle" at position 31-38
     * ```
     */
    async extractEntities(text) {
        try {
            if (typeof text !== 'string') {
                throw new errors_1.NERError('Text must be a string');
            }
            if (text.length === 0) {
                // Empty text has no entities
                return [];
            }
            // extractEntities returns a protobuf ExtractEntitiesResponse message
            const responsePb = await this.nerInterface.extractEntities(text);
            // Unpack the response which contains an array of matches
            return pb_helpers_1.PbHelper.NLU.unpackExtractEntitiesResponse(responsePb);
        }
        catch (error) {
            if (error instanceof errors_1.NERError) {
                throw error;
            }
            throw new errors_1.NERError(`Failed to extract entities from text: ${error.message}`, error.stack);
        }
    }
    /**
     * Extracts entities and groups them by type.
     *
     * @param {string} text - Text to analyze
     * @returns {Promise<Record<string, EntityMatch[]>>} Entities grouped by type
     * @throws {NERError} If entity extraction fails
     *
     * @example
     * ```typescript
     * const text = "John and Jane work at Google and Microsoft";
     * const grouped = await ner.extractEntitiesByType(text);
     *
     * console.log(grouped);
     * // {
     * //   PERSON: [
     * //     { text: "John", type: "PERSON", start: 0, end: 4 },
     * //     { text: "Jane", type: "PERSON", start: 9, end: 13 }
     * //   ],
     * //   ORG: [
     * //     { text: "Google", type: "ORG", start: 23, end: 29 },
     * //     { text: "Microsoft", type: "ORG", start: 34, end: 43 }
     * //   ]
     * // }
     * ```
     */
    async extractEntitiesByType(text) {
        const entities = await this.extractEntities(text);
        const grouped = {};
        for (const entity of entities) {
            if (!grouped[entity.entityName]) {
                grouped[entity.entityName] = [];
            }
            grouped[entity.entityName].push(entity);
        }
        return grouped;
    }
    /**
     * Extracts entities of a specific type from text.
     *
     * @param {string} text - Text to analyze
     * @param {string} entityType - Type of entities to extract
     * @returns {Promise<EntityMatch[]>} Array of matching entities
     * @throws {NERError} If entity extraction fails
     *
     * @example
     * ```typescript
     * const text = "John and Jane work at Google and Microsoft";
     * const people = await ner.extractEntitiesOfType(text, 'PERSON');
     *
     * console.log(people);
     * // [
     * //   { text: "John", type: "PERSON", start: 0, end: 4 },
     * //   { text: "Jane", type: "PERSON", start: 9, end: 13 }
     * // ]
     * ```
     */
    async extractEntitiesOfType(text, entityType) {
        const entities = await this.extractEntities(text);
        return entities.filter((entity) => entity.entityName === entityType);
    }
    /**
     * Checks if text contains any entities of a specific type.
     *
     * @param {string} text - Text to analyze
     * @param {string} entityType - Type of entity to check for
     * @returns {Promise<boolean>} True if entities of the type are found
     * @throws {NERError} If entity extraction fails
     *
     * @example
     * ```typescript
     * const text = "John works at Google";
     * const hasPeople = await ner.hasEntityType(text, 'PERSON');
     * console.log(hasPeople); // true
     *
     * const hasLocations = await ner.hasEntityType(text, 'LOCATION');
     * console.log(hasLocations); // false
     * ```
     */
    async hasEntityType(text, entityType) {
        const entities = await this.extractEntitiesOfType(text, entityType);
        return entities.length > 0;
    }
}
exports.NER = NER;
