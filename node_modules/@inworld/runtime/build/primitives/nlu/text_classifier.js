"use strict";
/**
 * Text Classifier primitive using N-API addon.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TextClassifier = void 0;
const node_api_1 = require("../../internal/node_api");
const pb_helpers_1 = require("../../internal/pb_helpers");
const errors_1 = require("../errors");
/**
 * Text Classifier class.
 * Classifies text into predefined categories (e.g., safety, sentiment, custom).
 * Requires a TextEmbedder to generate embeddings for classification.
 *
 * @example
 * ```typescript
 * import { TextEmbedder } from '../embeddings/text_embedder';
 * import { TextClassifier } from './text_classifier';
 *
 * // First, create an embedder
 * const embedder = await TextEmbedder.create({
 *   localConfig: {
 *     modelPath: 'models/embedders/bge-large-en-v1.5.gguf',
 *     device: { type: 'CPU', index: 0 }
 *   }
 * });
 *
 * // Create classifier with embedder
 * const classifier = await TextClassifier.create(embedder, {
 *   modelWeightsPath: 'models/safety/model_weights.json',
 *   supportedClasses: ['hategroup', 'selfharm', 'sexual', 'substance']
 * });
 *
 * // Classify text
 * const result = await classifier.classifyText({
 *   text: "This is a test message"
 * });
 *
 * // Check results
 * for (const cls of result.classes) {
 *   console.log(`${cls.className}: ${cls.confidence}`);
 * }
 * ```
 */
class TextClassifier {
    /**
     * Creates a new TextClassifier instance (internal constructor).
     * Use `TextClassifier.create()` static method instead.
     *
     * @param {any} classifierInterface - Addon TextClassifierInterface instance
     * @internal
     */
    constructor(classifierInterface) {
        this.classifierInterface = classifierInterface;
    }
    /**
     * Creates a new TextClassifier instance with the specified configuration.
     * Requires a TextEmbedder to generate embeddings for text classification.
     *
     * @param {any} embedder - TextEmbedder instance for generating embeddings
     * @param {TextClassifierConfig} config - Text classifier configuration
     * @returns {Promise<TextClassifier>} Promise resolving to TextClassifier instance
     * @throws {TextClassifierError} If classifier creation fails
     *
     * @example
     * ```typescript
     * import { TextEmbedder } from '../embeddings/text_embedder';
     *
     * // Create embedder first
     * const embedder = await TextEmbedder.create({
     *   localConfig: {
     *     modelPath: 'models/embedders/my-embedder.gguf',
     *     device: { type: 'CPU', index: 0 }
     *   }
     * });
     *
     * // Create safety classifier
     * const classifier = await TextClassifier.create(embedder, {
     *   modelWeightsPath: 'models/safety/text_classifier/model_weights.json',
     *   supportedClasses: ['hategroup', 'selfharm', 'sexual', 'sexualminors', 'substance'],
     *   threshold: 0.5
     * });
     * ```
     */
    static async create(embedder, config) {
        var _a;
        try {
            const env = (0, node_api_1.getInworldAddonEnv)();
            const nlu = env.nlu;
            if (!nlu) {
                throw new errors_1.TextClassifierError('NLU namespace not available in addon environment');
            }
            if (!embedder) {
                throw new errors_1.TextClassifierError('TextEmbedder is required');
            }
            const factory = nlu.createTextClassifierFactory();
            const configPb = pb_helpers_1.PbHelper.NLU.createTextClassifierCreationConfig(config);
            // Pass the embedder's internal interface to the factory
            const embedderInterface = embedder.embedderInterface || ((_a = embedder.getInterface) === null || _a === void 0 ? void 0 : _a.call(embedder));
            if (!embedderInterface) {
                throw new errors_1.TextClassifierError('Invalid embedder: cannot access internal interface');
            }
            const classifierInterface = await factory.createTextClassifier(embedderInterface, configPb);
            return new TextClassifier(classifierInterface);
        }
        catch (error) {
            if (error instanceof errors_1.TextClassifierError) {
                throw error;
            }
            throw new errors_1.TextClassifierError(`Failed to create TextClassifier instance: ${error.message}`, error.stack);
        }
    }
    /**
     * Classifies the provided text into predefined categories.
     * Returns classifications with confidence scores.
     *
     * @param {ClassifyTextRequest} request - Classification request with text and optional threshold
     * @returns {Promise<TextClassifierResponse>} Classification results
     * @throws {TextClassifierError} If classification fails
     *
     * @example
     * ```typescript
     * const result = await classifier.classifyText({
     *   text: "This is a test message",
     *   threshold: 0.6  // Optional: override default threshold
     * });
     *
     * // Check if any unsafe content detected
     * if (result.classes.length > 0) {
     *   console.log('Detected unsafe content:');
     *   result.classes.forEach(cls => {
     *     console.log(`  ${cls.className}: ${(cls.confidence * 100).toFixed(2)}%`);
     *   });
     * } else {
     *   console.log('Text is safe');
     * }
     * ```
     */
    async classifyText(request) {
        try {
            if (!request.text || typeof request.text !== 'string') {
                throw new errors_1.TextClassifierError('Text must be a non-empty string');
            }
            const requestPb = pb_helpers_1.PbHelper.NLU.createClassifyTextRequest(request);
            const responsePb = await this.classifierInterface.classifyText(requestPb);
            return pb_helpers_1.PbHelper.NLU.unpackTextClassifierResponse(responsePb);
        }
        catch (error) {
            if (error instanceof errors_1.TextClassifierError) {
                throw error;
            }
            throw new errors_1.TextClassifierError(`Failed to classify text: ${error.message}`, error.stack);
        }
    }
    /**
     * Classifies text and returns only classes exceeding the specified threshold.
     *
     * @param {string} text - Text to classify
     * @param {number} threshold - Minimum confidence threshold (0-1)
     * @returns {Promise<TextClassifierResponse>} Filtered classification results
     * @throws {TextClassifierError} If classification fails
     *
     * @example
     * ```typescript
     * // Only get high-confidence classifications
     * const result = await classifier.classifyTextWithThreshold(
     *   "Sample text",
     *   0.8  // Only return classes with >80% confidence
     * );
     * ```
     */
    async classifyTextWithThreshold(text, threshold) {
        return this.classifyText({ text, threshold });
    }
    /**
     * Checks if text contains any unsafe content based on classification.
     * Returns true if any class exceeds the threshold.
     *
     * @param {string} text - Text to check
     * @param {number} threshold - Optional threshold (uses config default if not provided)
     * @returns {Promise<boolean>} True if unsafe content detected
     * @throws {TextClassifierError} If classification fails
     *
     * @example
     * ```typescript
     * const text = "User message";
     * const isUnsafe = await classifier.isUnsafe(text);
     *
     * if (isUnsafe) {
     *   console.log('Content blocked: unsafe content detected');
     * } else {
     *   console.log('Content is safe to display');
     * }
     * ```
     */
    async isUnsafe(text, threshold) {
        const result = await this.classifyText({
            text,
            threshold,
        });
        return result.classes.length > 0;
    }
    /**
     * Checks if text contains specific unsafe categories.
     *
     * @param {string} text - Text to check
     * @param {string[]} categories - Categories to check for
     * @param {number} threshold - Optional threshold
     * @returns {Promise<boolean>} True if any specified category detected
     * @throws {TextClassifierError} If classification fails
     *
     * @example
     * ```typescript
     * // Check for specific safety categories
     * const hasHate = await classifier.containsCategories(
     *   "User message",
     *   ['hategroup', 'harassment']
     * );
     *
     * if (hasHate) {
     *   console.log('Message contains hate speech');
     * }
     * ```
     */
    async containsCategories(text, categories, threshold) {
        const result = await this.classifyText({ text, threshold });
        return result.classes.some((cls) => categories.includes(cls.className.toLowerCase()));
    }
    /**
     * Gets the highest confidence classification for the text.
     * Returns null if no classifications exceed the threshold.
     *
     * @param {string} text - Text to classify
     * @param {number} threshold - Optional threshold
     * @returns {Promise<{className: string, confidence: number} | null>} Top classification or null
     * @throws {TextClassifierError} If classification fails
     *
     * @example
     * ```typescript
     * const top = await classifier.getTopClassification("Sample text");
     *
     * if (top) {
     *   console.log(`Top category: ${top.className} (${top.confidence})`);
     * } else {
     *   console.log('No significant classification');
     * }
     * ```
     */
    async getTopClassification(text, threshold) {
        const result = await this.classifyText({ text, threshold });
        if (result.classes.length === 0) {
            return null;
        }
        // Find the classification with highest confidence
        return result.classes.reduce((max, cls) => cls.confidence > max.confidence ? cls : max);
    }
    /**
     * Batch classifies multiple texts.
     *
     * @param {string[]} texts - Array of texts to classify
     * @param {number} threshold - Optional threshold
     * @returns {Promise<TextClassifierResponse[]>} Array of classification results
     * @throws {TextClassifierError} If classification fails
     *
     * @example
     * ```typescript
     * const texts = [
     *   "First message",
     *   "Second message",
     *   "Third message"
     * ];
     *
     * const results = await classifier.classifyBatch(texts);
     *
     * results.forEach((result, index) => {
     *   console.log(`Text ${index + 1}:`, result.classes);
     * });
     * ```
     */
    async classifyBatch(texts, threshold) {
        if (!Array.isArray(texts)) {
            throw new errors_1.TextClassifierError('Texts must be an array');
        }
        return Promise.all(texts.map((text) => this.classifyText({ text, threshold })));
    }
}
exports.TextClassifier = TextClassifier;
