"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.logger = exports.startSpanWithParent = exports.startSpanWithAttributes = exports.startSpan = exports.Span = exports.configureMetric = exports.init = exports.shutdown = exports.metric = void 0;
const default_1 = require("../internal/default");
const inworld_1 = require("../internal/error/inworld");
const node_api_1 = require("../internal/node_api");
const pb_helpers_1 = require("../internal/pb_helpers");
const auth_1 = require("../internal/utils/auth");
const compat_1 = require("./compat");
const types_1 = require("./types");
const SDK_NAME = 'Inworld Runtime Node.js SDK';
const SDK_VERSION = require('../../package.json').version;
const SpanWrapperClass = node_api_1.SpanWrapper;
const spanFactory = new SpanWrapperClass();
let initialized = false;
function buildTelemetryConfig(props) {
    const { apiKey, exporterType = types_1.ExporterType.Remote, appName = default_1.Default.telemetry.telemetryAppName, appVersion = default_1.Default.telemetry.telemetryAppVersion, endpoint, logger, tracer, sdkName, sdkVersion, flushTimeoutMs = default_1.Default.telemetry.flushTimeoutMs, shutdownTimeoutMs = default_1.Default.telemetry.shutdownTimeoutMs, } = props;
    const resolvedEndpoint = endpoint || (0, auth_1.getAuthEndpointFromEnv)();
    const resolvedLogger = logger
        ? (0, compat_1.mapLoggerConfigToProto)(logger)
        : (0, compat_1.mapLoggerConfigToProto)({
            sinkAbslLogs: true,
            level: types_1.LogLevel.Info,
        });
    const protoConfig = {
        serviceName: appName,
        serviceVersion: appVersion,
        apiKey,
        endpoint: resolvedEndpoint,
        exporterType: (0, compat_1.mapExporterTypeToProto)(exporterType),
        sdkName: sdkName !== null && sdkName !== void 0 ? sdkName : SDK_NAME,
        sdkVersion: sdkVersion !== null && sdkVersion !== void 0 ? sdkVersion : SDK_VERSION,
        logger: resolvedLogger,
        tracer: (0, compat_1.mapTracerConfigToProto)(tracer),
        flushTimeoutMs,
        shutdownTimeoutMs,
    };
    return protoConfig;
}
/**
 * Metric recording utilities
 * @description Provides functions to record different types of metrics with
 * optional tags. All helpers throw {@link InworldError} if telemetry is not
 * initialized via {@link initTelemetry}.
 */
exports.metric = {
    /**
     * Records an unsigned integer counter metric
     * @param {string} name - The name of the metric to record
     * @param {number} value - The counter value to record
     * @param {Record<string, string>} [tags] - Optional key-value tags for the
     *     metric
     * @example
     * ```typescript
     * metric.recordCounterUInt('requests_total', 1, { endpoint: '/api/users',
     * method: 'GET' });
     * ```
     */
    recordCounterUInt(name, value, tags) {
        ensureTelemetryInitialized();
        spanFactory.recordMetric(pb_helpers_1.PbHelper.Telemetry.createRecordMetricRequest({
            name,
            counter: { uint64Value: value },
            attributes: tags,
        }));
    },
    /**
     * Records a double precision counter metric
     * @param {string} name - The name of the metric to record
     * @param {number} value - The counter value to record
     * @param {Record<string, string>} [tags] - Optional key-value tags for the
     *     metric
     * @example
     * ```typescript
     * metric.recordCounterDouble('bytes_processed', 1024.5, { data_type: 'json'
     * });
     * ```
     */
    recordCounterDouble(name, value, tags) {
        ensureTelemetryInitialized();
        spanFactory.recordMetric(pb_helpers_1.PbHelper.Telemetry.createRecordMetricRequest({
            name,
            counter: { doubleValue: value },
            attributes: tags,
        }));
    },
    /**
     * Records an integer gauge metric
     * @param {string} name - The name of the metric to record
     * @param {number} value - The gauge value to record
     * @param {Record<string, string>} [tags] - Optional key-value tags for the
     *     metric
     * @example
     * ```typescript
     * metric.recordGaugeInt('active_connections', 42, { server: 'web-01' });
     * ```
     */
    recordGaugeInt(name, value, tags) {
        ensureTelemetryInitialized();
        spanFactory.recordMetric(pb_helpers_1.PbHelper.Telemetry.createRecordMetricRequest({
            name,
            gauge: { int64Value: value },
            attributes: tags,
        }));
    },
    /**
     * Records a double precision gauge metric
     * @param {string} name - The name of the metric to record
     * @param {number} value - The gauge value to record
     * @param {Record<string, string>} [tags] - Optional key-value tags for the
     *     metric
     * @example
     * ```typescript
     * metric.recordGaugeDouble('cpu_usage_percent', 75.5, { core: '0' });
     * ```
     */
    recordGaugeDouble(name, value, tags) {
        ensureTelemetryInitialized();
        spanFactory.recordMetric(pb_helpers_1.PbHelper.Telemetry.createRecordMetricRequest({
            name,
            gauge: { doubleValue: value },
            attributes: tags,
        }));
    },
    /**
     * Records an unsigned integer histogram metric
     * @param {string} name - The name of the metric to record
     * @param {number} value - The value to record in the histogram
     * @param {Record<string, string>} [tags] - Optional key-value tags for the
     *     metric
     * @example
     * ```typescript
     * metric.recordHistogramUInt('request_duration_ms', 150, { endpoint:
     * '/api/data' });
     * ```
     */
    recordHistogramUInt(name, value, tags) {
        ensureTelemetryInitialized();
        spanFactory.recordMetric(pb_helpers_1.PbHelper.Telemetry.createRecordMetricRequest({
            name,
            histogram: { uint64Value: value },
            attributes: tags,
        }));
    },
    /**
     * Records a double precision histogram metric
     * @param {string} name - The name of the metric to record
     * @param {number} value - The value to record in the histogram
     * @param {Record<string, string>} [tags] - Optional key-value tags for the
     *     metric
     * @example
     * ```typescript
     * metric.recordHistogramDouble('memory_usage_mb', 512.75, { process:
     * 'worker-1' });
     * ```
     */
    recordHistogramDouble(name, value, tags) {
        ensureTelemetryInitialized();
        spanFactory.recordMetric(pb_helpers_1.PbHelper.Telemetry.createRecordMetricRequest({
            name,
            histogram: { doubleValue: value },
            attributes: tags,
        }));
    },
};
/**
 * Shuts down the telemetry system
 * @description Stops telemetry collection and cleans up all resources. Safe to
 * call multiple times.
 * @example
 * ```typescript
 * // Gracefully shutdown telemetry before application exit
 * shutdown();
 * ```
 */
const shutdown = () => {
    if (!initialized) {
        return;
    }
    node_api_1.telemetryNamespace.shutdown();
    initialized = false;
};
exports.shutdown = shutdown;
// FIXME: temporary for for telemetry initialization until we improve public API.
const globalTelemetryConfig = new Map();
/**
 * Initializes the telemetry system
 * @description Sets up telemetry collection with the provided configuration
 * @param {TelemetryConfig} props - Configuration for telemetry initialization
 * @throws {InworldError} When apiKey is missing or initialization fails
 * @example
 * ```typescript
 * init({
 *   apiKey: 'your-api-key',
 *   appName: 'my-application',
 *   appVersion: '1.0.0',
 *   logger: { level: LogLevel.INFO },
 *   tracer: { samplingRate: 0.1 }
 * });
 * ```
 */
const init = (props) => {
    if (!(props === null || props === void 0 ? void 0 : props.apiKey)) {
        throw new inworld_1.InworldError('apiKey is required to initialize telemetry');
    }
    if (initialized) {
        (0, exports.shutdown)();
    }
    // Temporary Swap appName and appVersion from global in case of telemetry initialization override
    let appName = props.appName;
    let appVersion = props.appVersion;
    if (appName) {
        globalTelemetryConfig.set('appName', appName);
    }
    else {
        appName = globalTelemetryConfig.get('appName');
    }
    if (appVersion) {
        globalTelemetryConfig.set('appVersion', appVersion);
    }
    else {
        appVersion = globalTelemetryConfig.get('appVersion');
    }
    const protoConfig = buildTelemetryConfig(Object.assign(Object.assign({}, props), { appName,
        appVersion }));
    try {
        const configPbRequest = pb_helpers_1.PbHelper.Telemetry.createConfigureTelemetryRequest({
            config: protoConfig,
        });
        node_api_1.telemetryNamespace.configure(configPbRequest);
        initialized = true;
        if (protoConfig.endpoint) {
            process.env.INWORLD_ENDPOINT = protoConfig.endpoint;
        }
    }
    catch (error) {
        throw new inworld_1.InworldError('Failed to initialize telemetry', error);
    }
};
exports.init = init;
/**
 * Configures a metric with the telemetry system
 * @description Registers a metric definition for later use in recording data
 * @param {MetricConfig} config - Configuration for the metric to
 *     register
 * @throws {InworldError} When metric name is missing or configuration fails
 * @example
 * ```typescript
 * configureMetric({
 *   metricType: MetricType.COUNTER_UINT,
 *   name: 'requests_total',
 *   description: 'Total number of HTTP requests',
 *   unit: 'requests'
 * });
 * ```
 */
const configureMetric = (config) => {
    if (!(config === null || config === void 0 ? void 0 : config.name)) {
        throw new inworld_1.InworldError('Metric name is required');
    }
    const protoMetric = Object.assign({ name: config.name, description: config.description, unit: config.unit }, (0, compat_1.mapMetricTypeToProto)(config.metricType));
    node_api_1.telemetryNamespace.configureMetric(pb_helpers_1.PbHelper.Telemetry.createMetricConfig(protoMetric));
};
exports.configureMetric = configureMetric;
/**
 * Span class for distributed tracing
 * @description Represents a span in distributed tracing, allowing you to track
 * operations and add attributes
 */
class Span {
    /**
     * Creates a new Span instance
     * @param {NativeSpan} nativeSpan - The native span reference from SpanWrapper
     * @internal
     */
    constructor(nativeSpan) {
        this.nativeSpan = nativeSpan;
    }
    /**
     * Sets a string attribute on the span
     * @param {string} key - The attribute key
     * @param {string} value - The attribute value
     */
    setAttribute(key, value) {
        if (this.nativeSpan && typeof this.nativeSpan.setAttribute === 'function') {
            this.nativeSpan.setAttribute(key, value);
        }
    }
    /**
     * Sets an array of strings as an attribute on the span
     * @param {string} key - The attribute key
     * @param {string[]} values - The array of string values
     * @description Currently only supports setting individual attributes. Array
     * values are joined with commas.
     */
    setAttributeArray(key, values) {
        this.setAttribute(key, values.join(','));
    }
    /**
     * Sets the span status to OK
     * @description Marks the span as successfully completed
     */
    setOK() {
        if (this.nativeSpan && typeof this.nativeSpan.setOk === 'function') {
            this.nativeSpan.setOk();
        }
    }
    /**
     * Sets the span status to Error with a description
     * @param {string} description - Description of the error
     * @description Marks the span as failed with an error description
     */
    setError(description) {
        if (this.nativeSpan && typeof this.nativeSpan.setError === 'function') {
            this.nativeSpan.setError(description);
        }
    }
    /**
     * Ends the span
     * @description Marks the span as completed and sends it to the telemetry
     * system
     */
    end() {
        if (this.nativeSpan && typeof this.nativeSpan.end === 'function') {
            this.nativeSpan.end();
        }
    }
    /**
     * Retrieves span traces from the capture queue.
     * @param {number} count - Maximum number of spans to dequeue.
     * @returns {DequeueSpanTracesResponse} Dequeued span data.
     * @throws {InworldError} When telemetry has not been initialized.
     * @description Requires `tracer.enableSpanCapture` to be set when
     * calling {@link initTelemetry}. The queue is FIFO and consumes entries on
     * read.
     */
    dequeueSpanTraces(count) {
        ensureTelemetryInitialized();
        const response = this.nativeSpan.dequeueSpanTraces(count);
        return pb_helpers_1.PbHelper.Telemetry.unpackDequeueSpanTracesResponse(response);
    }
    /**
     * Gets the native span reference
     * @returns {NativeSpan} The native span reference
     * @internal
     */
    getNativeSpan() {
        return this.nativeSpan;
    }
}
exports.Span = Span;
/**
 * Starts a new span for distributed tracing
 * @param {string} name - The name of the span
 * @returns {Span} A new span instance
 */
const startSpan = (name) => {
    ensureTelemetryInitialized();
    try {
        const nativeSpan = spanFactory.startSpan(name);
        return new Span(nativeSpan);
    }
    catch (error) {
        throw new inworld_1.InworldError('Failed to start span', error);
    }
};
exports.startSpan = startSpan;
/**
 * Starts a new span with initial attributes
 * @param {string} name - The name of the span
 * @param {Record<string, string>} attributes - Initial attributes to set on the
 *     span
 * @returns {Span} A new span instance with the specified attributes
 */
const startSpanWithAttributes = (name, attributes) => {
    const span = (0, exports.startSpan)(name);
    for (const [key, value] of Object.entries(attributes)) {
        span.setAttribute(key, value);
    }
    return span;
};
exports.startSpanWithAttributes = startSpanWithAttributes;
/**
 * Starts a new span with a parent span for distributed tracing
 * @param {string} name - The name of the span
 * @param {Record<string, string>} attributes - Initial attributes to set on the
 *     span
 * @param {Span[]} _links - Array of spans to link to this span (not yet
 *     implemented)
 * @param {Span} parent - The parent span
 * @returns {Span} A new span instance with parent relationship
 * @throws {InworldError} When telemetry has not been initialized
 * @description The parent must originate from this SDK (i.e. created via {@link
 * startSpan}). Links are reserved for future support.
 */
const startSpanWithParent = (name, attributes, _links, parent) => {
    ensureTelemetryInitialized();
    try {
        const nativeSpan = parent
            .getNativeSpan()
            .startSpan(name, parent.getNativeSpan());
        const span = new Span(nativeSpan);
        for (const [key, value] of Object.entries(attributes)) {
            span.setAttribute(key, value);
        }
        return span;
    }
    catch (error) {
        throw new inworld_1.InworldError('Failed to start span with parent', error);
    }
};
exports.startSpanWithParent = startSpanWithParent;
/**
 * Logging utilities
 * @description Provides functions to log messages with different levels and
 * optional context
 */
exports.logger = {
    /**
     * Logs a message with the specified log level
     * @param {LogLevel} level - The log level for the message
     * @param {string} message - The message to log
     * @param {Record<string, string>} [context] - Optional key-value context for
     *     the log message
     * @param {ProcessContext} [_processContext] - Optional process context to add
     *     execution info (not implemented)
     * @throws {InworldError} When telemetry has not been initialized
     * @example
     * ```typescript
     * logger.log(LogLevel.INFO, 'User logged in', { userId: '123', method:
     * 'oauth' }); logger.log(LogLevel.ERROR, 'Database connection failed', {});
     * ```
     */
    log(level, message, context, _processContext) {
        ensureTelemetryInitialized();
        const request = {
            logLevel: (0, compat_1.mapLogLevelToProto)(level),
            message,
            attributes: context,
        };
        spanFactory.logMessage(pb_helpers_1.PbHelper.Telemetry.createLogMessageRequest(request));
    },
    /**
     * Logs a trace level message
     * @param {string} message - The message to log
     * @param {Record<string, string>} [context] - Optional key-value context for
     *     the log message
     * @param {ProcessContext} [processContext] - Optional process context to add
     *     execution info
     * @example
     * ```typescript
     * logger.trace('Entering function processData', { functionName:
     * 'processData', args: 'user123' }); logger.trace('Processing node', {},
     * processContext);
     * ```
     */
    trace(message, context, processContext) {
        this.log(types_1.LogLevel.Trace, message, context, processContext);
    },
    /**
     * Logs a debug level message
     * @param {string} message - The message to log
     * @param {Record<string, string>} [context] - Optional key-value context for
     *     the log message
     * @param {ProcessContext} [processContext] - Optional process context to add
     *     execution info
     * @example
     * ```typescript
     * logger.debug('Processing user data', { userId: '123', operation: 'update'
     * }); logger.debug('Node processing', {}, processContext);
     * ```
     */
    debug(message, context, processContext) {
        this.log(types_1.LogLevel.Debug, message, context, processContext);
    },
    /**
     * Logs an info level message
     * @param {string} message - The message to log
     * @param {Record<string, string>} [context] - Optional key-value context for
     *     the log message
     * @param {ProcessContext} [processContext] - Optional process context to add
     *     execution info
     * @example
     * ```typescript
     * logger.info('User successfully authenticated', { userId: '123', provider:
     * 'google' }); logger.info('Node execution completed', {}, processContext);
     * ```
     */
    info(message, context, processContext) {
        this.log(types_1.LogLevel.Info, message, context, processContext);
    },
    /**
     * Logs a warning level message
     * @param {string} message - The message to log
     * @param {Record<string, string>} [context] - Optional key-value context for
     *     the log message
     * @param {ProcessContext} [processContext] - Optional process context to add
     *     execution info
     * @example
     * ```typescript
     * logger.warn('API rate limit approaching', { currentUsage: '80%', endpoint:
     * '/api/users' }); logger.warn('Node processing slow', {}, processContext);
     * ```
     */
    warn(message, context, processContext) {
        this.log(types_1.LogLevel.Warn, message, context, processContext);
    },
    /**
     * Logs an error level message
     * @param {string} message - The message to log
     * @param {Record<string, string>} [context] - Optional key-value context for
     *     the log message
     * @param {ProcessContext} [processContext] - Optional process context to add
     *     execution info
     * @example
     * ```typescript
     * logger.error('Database connection failed', { error: 'ECONNREFUSED', host:
     * 'db.example.com' }); logger.error('Node execution failed', { error:
     * 'timeout' }, processContext);
     * ```
     */
    error(message, context, processContext) {
        this.log(types_1.LogLevel.Error, message, context, processContext);
    },
};
function ensureTelemetryInitialized() {
    if (!initialized) {
        throw new inworld_1.InworldError('Telemetry has not been initialized. Call initTelemetry() first.');
    }
}
