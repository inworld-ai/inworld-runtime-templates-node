"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapExporterTypeToProto = mapExporterTypeToProto;
exports.mapLogLevelToProto = mapLogLevelToProto;
exports.mapMetricTypeToProto = mapMetricTypeToProto;
exports.mapLoggerConfigToProto = mapLoggerConfigToProto;
exports.mapTracerConfigToProto = mapTracerConfigToProto;
const default_1 = require("../internal/default");
const env_1 = require("../internal/env");
const types_1 = require("./types");
function mapExporterTypeToProto(exporterType) {
    switch (exporterType) {
        case types_1.ExporterType.Local:
            return 'EXPORTER_TYPE_LOCAL';
        case types_1.ExporterType.Remote:
        default:
            return 'EXPORTER_TYPE_REMOTE';
    }
}
function mapLogLevelToProto(level) {
    switch (level) {
        case types_1.LogLevel.Trace:
            return 'LOG_LEVEL_TRACE';
        case types_1.LogLevel.Debug:
            return 'LOG_LEVEL_DEBUG';
        case types_1.LogLevel.Warn:
            return 'LOG_LEVEL_WARN';
        case types_1.LogLevel.Error:
            return 'LOG_LEVEL_ERROR';
        case types_1.LogLevel.Info:
        default:
            return 'LOG_LEVEL_INFO';
    }
}
function mapMetricTypeToProto(metricType) {
    switch (metricType) {
        case types_1.MetricType.CounterDouble:
            return {
                metricKind: 'METRIC_KIND_COUNTER',
                valueType: 'METRIC_VALUE_TYPE_DOUBLE',
            };
        case types_1.MetricType.CounterUInt:
            return {
                metricKind: 'METRIC_KIND_COUNTER',
                valueType: 'METRIC_VALUE_TYPE_INTEGER',
            };
        case types_1.MetricType.GaugeDouble:
            return {
                metricKind: 'METRIC_KIND_GAUGE',
                valueType: 'METRIC_VALUE_TYPE_DOUBLE',
            };
        case types_1.MetricType.GaugeInt:
            return {
                metricKind: 'METRIC_KIND_GAUGE',
                valueType: 'METRIC_VALUE_TYPE_INTEGER',
            };
        case types_1.MetricType.HistogramDouble:
            return {
                metricKind: 'METRIC_KIND_HISTOGRAM',
                valueType: 'METRIC_VALUE_TYPE_DOUBLE',
            };
        case types_1.MetricType.HistogramUInt:
        default:
            return {
                metricKind: 'METRIC_KIND_HISTOGRAM',
                valueType: 'METRIC_VALUE_TYPE_INTEGER',
            };
    }
}
function mapLoggerConfigToProto(config) {
    var _a, _b;
    if (!config) {
        return undefined;
    }
    return {
        logLevel: mapLogLevelToProto(config.level),
        sinkAbslLogs: (_b = (_a = config.sinkAbslLogs) !== null && _a !== void 0 ? _a : env_1.Env.telemetry.enableAbslLogs) !== null && _b !== void 0 ? _b : default_1.Default.telemetry.logger.sinkAbslLogs,
    };
}
function mapTracerConfigToProto(config) {
    if (!config) {
        return undefined;
    }
    const tracerConfig = {};
    if (config.samplingRate) {
        tracerConfig.samplingRate = config.samplingRate;
    }
    else {
        tracerConfig.samplingRate = default_1.Default.telemetry.tracer.samplingRate;
    }
    if (config.spanDumpPath) {
        tracerConfig.spanDumpPath = config.spanDumpPath;
    }
    else {
    }
    if (config.enableSpanCapture) {
        tracerConfig.enableSpanCapture = config.enableSpanCapture;
    }
    else {
        tracerConfig.enableSpanCapture = default_1.Default.telemetry.tracer.enableSpanCapture;
    }
    if (config.maxSpanCaptureQueueSize) {
        tracerConfig.maxSpanCaptureQueueSize = config.maxSpanCaptureQueueSize;
    }
    else {
        tracerConfig.maxSpanCaptureQueueSize =
            default_1.Default.telemetry.tracer.maxSpanCaptureQueueSize;
    }
    return tracerConfig;
}
