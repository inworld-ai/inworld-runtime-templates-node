const fs = require('fs');
const os = require('os');
const path = require('path');
const decompress = require('decompress');
const decompressTargz = require('decompress-targz');
const decompressUnzip = require('decompress-unzip');
const { execSync } = require('child_process');
const https = require('https');
const { pipeline } = require('stream');
const { promisify } = require('util');
const streamPipeline = promisify(pipeline);

/**
 * Normalize a version tag by removing 'v' prefix if present
 * @param {string} input - The tag to normalize
 * @returns {string|null} The normalized tag or null if invalid
 */
function normalizeTag(input) {
  if (!input) return null;
  const trimmed = String(input).trim();
  if (!trimmed) return null;
  return trimmed.startsWith('v') ? trimmed.slice(1) : trimmed;
}

/**
 * Resolve version tag from environment variable or version file
 * @returns {string|null} The resolved tag or null if not found
 */
function resolveTagFromEnvOrFile() {
  const fromEnv = normalizeTag(process.env.INWORLD_RUNTIME_RELEASE_TAG);
  if (fromEnv) return fromEnv;
  try {
    const raw = fs.readFileSync(
      path.join(__dirname, '..', 'runtime-binaries-version.txt'),
      'utf8',
    );
    const firstLine = raw.split(/\r?\n/).find((l) => l.trim().length > 0) || '';
    return normalizeTag(firstLine);
  } catch (_) {
    return null;
  }
}

/**
 * Fetch JSON from a URL with authentication
 * @param {string} url - The URL to fetch
 * @param {string} token - The GitHub token for authentication
 * @returns {Promise<any>} The parsed JSON response
 */
async function getJson(url, token) {
  return new Promise((resolve, reject) => {
    https
      .get(
        url,
        {
          headers: {
            'User-Agent': 'node.js',
            Authorization: `token ${token}`,
          },
        },
        (res) => {
          let data = '';
          res.on('data', (chunk) => (data += chunk));
          res.on('end', () => {
            if (res.statusCode !== 200) {
              reject(
                new Error(`Failed to fetch JSON: ${res.statusCode} ${data}`),
              );
            } else {
              resolve(JSON.parse(data));
            }
          });
        },
      )
      .on('error', reject);
  });
}

/**
 * Download a specific asset from a GitHub release
 * @param {string} owner - The repository owner
 * @param {string} repo - The repository name
 * @param {string} tag - The release tag
 * @param {string} assetName - The name of the asset to download
 * @param {string} destPath - The destination path for the downloaded file
 * @param {string} token - The GitHub token for authentication
 * @returns {Promise<void>}
 */
async function downloadGithubAsset(
  owner,
  repo,
  tag,
  assetName,
  destPath,
  token,
) {
  const releaseUrl = `https://api.github.com/repos/${owner}/${repo}/releases/tags/v${tag}`;
  const release = await getJson(releaseUrl, token);
  const asset = release.assets.find((a) => a.name === assetName);
  if (!asset) {
    throw new Error(`Asset '${assetName}' not found in release ${tag}`);
  }

  const headers = {
    'User-Agent': 'node.js',
    Authorization: `token ${token}`,
    Accept: 'application/octet-stream',
  };
  const downloadUrl = `https://api.github.com/repos/${owner}/${repo}/releases/assets/${asset.id}`;

  return new Promise((resolve, reject) => {
    https
      .get(downloadUrl, { headers }, (res) => {
        if (res.statusCode === 302 && res.headers.location) {
          return https
            .get(res.headers.location, { headers }, (redirectedRes) => {
              if (redirectedRes.statusCode !== 200) {
                return reject(
                  new Error(
                    `Redirected download failed: ${redirectedRes.statusCode}`,
                  ),
                );
              }
              const fileStream = fs.createWriteStream(destPath);
              redirectedRes.pipe(fileStream);
              fileStream.on('finish', () => fileStream.close(resolve));
            })
            .on('error', reject);
        }
        if (res.statusCode !== 200) {
          return reject(new Error(`Download failed: ${res.statusCode}`));
        }
        const fileStream = fs.createWriteStream(destPath);
        res.pipe(fileStream);
        fileStream.on('finish', () => fileStream.close(resolve));
      })
      .on('error', reject);
  });
}

/**
 * Extract Node addon binary and all supporting libraries from an archive
 * @param {string} archivePath - Path to the archive file
 * @param {string} targetDir - Target directory for extraction
 * @param {boolean} isZip - Whether the archive is a zip file (true) or tar.gz (false)
 */
async function extractNodeAddonOnly(archivePath, targetDir, isZip) {
  const plugins = isZip ? [decompressUnzip()] : [decompressTargz()];

  let allFiles;
  try {
    allFiles = await decompress(archivePath, { plugins });
    allFiles.forEach((file, index) => {
      if (index < 50) { // Limit output to first 50 files
        console.log(`  - ${file.path} (${file.type})`);
      }
    });
    if (allFiles.length > 50) {
      console.log(`  ... and ${allFiles.length - 50} more files`);
    }
  } catch (scanError) {
    console.error(`Error scanning archive: ${scanError.message}`);
  }

  const files = await decompress(archivePath, targetDir, {
    plugins,
    filter: (file) => {
      // Extract everything from the lib directory
      const isInLib = file.path.startsWith('lib/') || file.path === 'lib';
      return isInLib;
    },
    map: (file) => {
      // Preserve the original path structure within lib directory
      return file;
    },
  });


  if (files.length === 0) {
    throw new Error(
      `No files found in lib directory. Archive contained ${allFiles ? allFiles.length : 'unknown'} files.`,
    );
  }

  // Verify that inworld.node was extracted
  const addonPath = path.join(targetDir, 'lib', 'inworld.node');
  if (!fs.existsSync(addonPath)) {
    throw new Error(
      `Addon binary (inworld.node) not found after extraction. Archive contained ${allFiles ? allFiles.length : 'unknown'} files.`,
    );
  }

  // Set proper permissions for all extracted files
  const libDir = path.join(targetDir, 'lib');
  if (fs.existsSync(libDir)) {
    const setPermissionsRecursively = (dir) => {
      const entries = fs.readdirSync(dir, { withFileTypes: true });
      for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);
        if (entry.isDirectory()) {
          setPermissionsRecursively(fullPath);
        } else if (entry.isFile()) {
          // Set executable permissions for .node, .dylib, .so, .dll files
          const ext = path.extname(entry.name);
          if (ext === '.node' || ext === '.dylib' || ext === '.so' || ext === '.dll') {
            fs.chmodSync(fullPath, 0o755);
          } else {
            fs.chmodSync(fullPath, 0o644);
          }
        }
      }
    };
    setPermissionsRecursively(libDir);
  }
}

/**
 * Verify that a tag follows the expected version format
 * @param {string} tag - The tag to verify
 * @returns {boolean} True if the tag format is valid
 */
function verifyTagFormat(tag) {
  const tagRe = /^\d+\.\d+\.\d+(-rc\d+)?$/;
  return tagRe.test(tag);
}

/**
 * Get the platform target key for the current system
 * @returns {{key: string, mapped: string, platform: string}} Platform information
 */
function getPlatformTargetKey() {
  const platform = os.platform();
  const arch = os.arch();
  const platformArchMap = {
    win32_x64: 'windows_x64',
    darwin_arm64: 'darwin_aarch64',
    linux_x64: 'linux_x86_64',
    linux_arm64: 'linux_aarch64',
  };
  const key = `${platform}_${arch}`;
  const mapped = platformArchMap[key];
  if (!mapped) {
    throw new Error(`Unsupported platform/arch: ${platform} ${arch}`);
  }
  return { key, mapped, platform };
}

/**
 * Download and extract a specific asset from GitHub release
 * @param {Object} params - The parameters object
 * @param {string} params.tag - The release tag
 * @param {string} params.mapped - The mapped platform string
 * @param {string} params.platform - The platform name
 * @param {string} params.targetDir - The target directory for extraction
 * @param {string} params.token - The GitHub token for authentication
 * @param {string} params.suffix - The asset suffix (e.g., 'cpu_full_node')
 * @param {Function} params.extractFn - The extraction function to use
 * @returns {Promise<void>}
 */
async function downloadAndExtractAsset({
  tag,
  mapped,
  platform,
  targetDir,
  token,
  suffix,
  extractFn,
}) {
  const ext = platform === 'win32' ? 'zip' : 'tar.gz';
  const assetName = `inworld_api_${tag}_${mapped}_${suffix}.${ext}`;
  const destPath = path.join(os.tmpdir(), assetName);

  await downloadGithubAsset(
    'inworld-ai',
    'inworld-framework-cpp',
    tag,
    assetName,
    destPath,
    token,
  );

  await extractFn(destPath, targetDir, platform === 'win32');
}

/**
 * Download and extract Node addon binaries from GitHub release
 */
async function downloadUnzipBinaries() {
  const { key, mapped, platform } = getPlatformTargetKey();

  const token = process.env.GITHUB_TOKEN;

  const resolvedTag = resolveTagFromEnvOrFile();

  if (!resolvedTag) {
    throw new Error(
      `INWORLD_RUNTIME_RELEASE_TAG is not set and runtime-binaries-version.txt is missing or invalid`,
    );
  }
  if (!verifyTagFormat(resolvedTag)) {
    throw new Error(
      `Invalid tag format: ${resolvedTag}. Should be 1.2.3(-rc1)`,
    );
  }

  const targetDir = path.join(__dirname, '..', 'bin', key);
  fs.rmSync(targetDir, { recursive: true, force: true });
  fs.mkdirSync(targetDir, { recursive: true });

  // Download and extract Node addon binary only
  await downloadAndExtractAsset({
    tag: resolvedTag,
    mapped,
    platform,
    targetDir,
    token,
    suffix: 'cpu_full_node',
    extractFn: extractNodeAddonOnly,
  });

  // Write version file after successful download and extraction
  const versionFilePath = path.join(targetDir, 'version.txt');
  fs.writeFileSync(versionFilePath, resolvedTag, 'utf8');
}

module.exports = {
  downloadUnzipBinaries,
  extractNodeAddonOnly,
};

if (require.main === module) {
  downloadUnzipBinaries().catch((err) => {
    console.error(err);
    process.exit(1);
  });
}
