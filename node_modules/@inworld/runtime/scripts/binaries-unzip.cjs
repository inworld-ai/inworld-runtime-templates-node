const fs = require('fs');
const os = require('os');
const path = require('path');
const decompress = require('decompress');
const decompressTargz = require('decompress-targz');
const decompressUnzip = require('decompress-unzip');
const {
  downloadUnzipBinaries,
  extractNodeAddonOnly,
} = require('./download-unzip-binaries.cjs');

/**
 * Check if Node binary and supporting libraries are already properly extracted and valid
 * @param {string} targetDir - The target directory to check
 * @returns {boolean} True if the Node binary and essential files exist
 */
function areBinariesValid(targetDir) {
  const libDir = path.join(targetDir, 'lib');
  
  // Check if lib directory exists
  if (!fs.existsSync(libDir)) {
    return false;
  }

  // Check for inworld.node file (Node addon binary) - this is the essential file
  const nodeBinaryPath = path.join(libDir, 'inworld.node');
  if (!fs.existsSync(nodeBinaryPath)) {
    return false;
  }

  // Check that lib directory contains more than just inworld.node
  // (supporting libraries like .dylib/.so/.dll should also be present)
  try {
    const libContents = fs.readdirSync(libDir);
    // Expect at least inworld.node plus some supporting libraries
    return libContents.length > 1;
  } catch (err) {
    return false;
  }
}

async function unzipBinaries() {
  const platform = os.platform();
  const arch = os.arch();
  const platformArch = `${platform}_${arch}`;

  console.log(`[unzipBinaries] Platform: ${platform}, Arch: ${arch}, Combined: ${platformArch}`);

  const binDir = path.join(__dirname, '..', 'bin');
  console.log(`[unzipBinaries] Binary directory: ${binDir}`);
  
  const sourceZip = path.join(binDir, `${platformArch}.zip`);
  const sourceTgz = path.join(binDir, `${platformArch}.tar.gz`);
  
  // Also look for pre-fetched official Node archives: inworld_api_*_cpu_full_node.* for this platform
  const platformMap = {
    darwin_arm64: 'darwin_aarch64',
    linux_x64: 'linux_x86_64',
    linux_arm64: 'linux_aarch64',
    win32_x64: 'windows_x64',
  };
  const mapped = platformMap[platformArch] || '';
  console.log(`[unzipBinaries] Platform mapping: ${platformArch} -> ${mapped}`);
  
  const archivePattern = new RegExp(
    `^inworld_api_.*_${mapped}_.*\\.(?:tar\\.gz|zip)$`,
  );
  
  console.log(`[unzipBinaries] Scanning bin directory for archives...`);
  const binEntries = fs.readdirSync(binDir);
  console.log(`[unzipBinaries] Found ${binEntries.length} entries in bin directory:`);
  binEntries.forEach(entry => console.log(`  - ${entry}`));
  
  const apiArchives = binEntries.filter((f) => archivePattern.test(f));
  console.log(`[unzipBinaries] Matching API archives: ${apiArchives.length > 0 ? apiArchives.join(', ') : 'none'}`);
  
  const apiArchiveNode = apiArchives.find((f) => f.includes('_cpu_full_node.'));
  console.log(`[unzipBinaries] Node archive: ${apiArchiveNode || 'not found'}`);
  const targetDir = path.join(binDir, platformArch);
  const versionFilePath = path.join(targetDir, 'version.txt');
  
  console.log(`[unzipBinaries] Target directory: ${targetDir}`);

  // Extract version from archive filename
  let currentVersion = null;
  if (apiArchiveNode) {
    // Extract version from inworld_api_VERSION_platform pattern
    const versionMatch = apiArchiveNode.match(/inworld_api_([^_]+)_/);
    currentVersion = versionMatch ? versionMatch[1] : null;
    console.log(`[unzipBinaries] Extracted version from Node archive: ${currentVersion}`);
  } else if (fs.existsSync(sourceZip) || fs.existsSync(sourceTgz)) {
    // For custom archives, use filename as version
    const archiveName = fs.existsSync(sourceZip) ? path.basename(sourceZip) : path.basename(sourceTgz);
    currentVersion = archiveName;
    console.log(`[unzipBinaries] Using custom archive name as version: ${currentVersion}`);
  } else {
    // Try to get version from runtime-binaries-version.txt for download case
    try {
      const frameworkVersionPath = path.join(__dirname, '..', 'runtime-binaries-version.txt');
      if (fs.existsSync(frameworkVersionPath)) {
        currentVersion = fs.readFileSync(frameworkVersionPath, 'utf8').trim();
        console.log(`[unzipBinaries] Read version from runtime-binaries-version.txt: ${currentVersion}`);
      } else {
        console.log(`[unzipBinaries] runtime-binaries-version.txt not found`);
      }
    } catch (err) {
      console.log(`Could not read runtime-binaries-version.txt: ${err.message}`);
    }
  }

  // Check existing version
  let existingVersion = null;
  if (fs.existsSync(versionFilePath)) {
    try {
      existingVersion = fs.readFileSync(versionFilePath, 'utf8').trim();
      console.log(`[unzipBinaries] Existing version in cache: ${existingVersion}`);
    } catch (err) {
      console.log(`Could not read version file: ${err.message}`);
    }
  } else {
    console.log(`[unzipBinaries] No existing version file found`);
  }

  // Check if Node binary is already valid and properly extracted
  if (fs.existsSync(targetDir) && areBinariesValid(targetDir)) {
    // If versions match, use cached binary
    if (currentVersion && existingVersion === currentVersion) {
      console.log(`Using cached Node binary v${currentVersion} in ${targetDir}`);
      return;
    }
    // If no version info available but binary is valid, keep it
    if (!currentVersion && !existingVersion) {
      console.log(`Node binary already present and valid in ${targetDir}, skipping extraction`);
      return;
    }
    // If binary is valid but version changed, log and continue
    console.log(`Version changed (${existingVersion} → ${currentVersion}), but Node binary is valid. Keeping existing binary.`);
    // Update version file to match current version
    if (currentVersion) {
      try {
        fs.writeFileSync(versionFilePath, currentVersion, 'utf8');
        console.log(`Updated version file to: ${currentVersion}`);
      } catch (err) {
        console.log(`Warning: Could not write version file: ${err.message}`);
      }
    }
    return;
  }

  console.log(`Version changed (${existingVersion} → ${currentVersion}) or no cache found. Extracting Node binary...`);

  const hasZip = fs.existsSync(sourceZip);
  const hasTgz = fs.existsSync(sourceTgz);
  const hasApiNode = Boolean(apiArchiveNode);
  
  console.log(`[unzipBinaries] Archive availability check:`);
  console.log(`  - Custom ZIP (${sourceZip}): ${hasZip}`);
  console.log(`  - Custom TGZ (${sourceTgz}): ${hasTgz}`);
  console.log(`  - API Node archive: ${hasApiNode}`);
  
  if (!hasZip && !hasTgz && !hasApiNode) {
    // Allow skipping binary download via environment variable
    if (process.env.SKIP_BINARY_SETUP === 'true') {
      console.log('No local archives found and SKIP_BINARY_SETUP=true, skipping download');
      return;
    }
    
    console.log(
      `No local archive found for ${platformArch}. Attempting to download release assets (using INWORLD_RUNTIME_RELEASE_TAG or runtime-binaries-version.txt) ...`,
    );
    await downloadUnzipBinaries();
    if (fs.existsSync(targetDir)) {
      console.log(`Using downloaded Node binary in ${targetDir}`);
      // Try to write version file for downloaded binary
      if (currentVersion) {
        try {
          fs.writeFileSync(versionFilePath, currentVersion, 'utf8');
          console.log(`Wrote version file for downloaded Node binary: ${currentVersion}`);
        } catch (err) {
          console.log(`Warning: Could not write version file: ${err.message}`);
        }
      }
      return;
    }
    throw new Error(
      `No prebuilt archive found for ${platform} ${arch}. Expected one of: ${sourceZip} or ${sourceTgz}. ` +
        `Also attempted to download via scripts/download-unzip-binaries.cjs but target directory was not created.`,
    );
  }

  console.log(`[unzipBinaries] Cleaning target directory: ${targetDir}`);
  fs.rmSync(targetDir, { recursive: true, force: true });
  fs.mkdirSync(targetDir, { recursive: true });

  // Extract Node addon binary only
  if (hasApiNode) {
    console.log(`[unzipBinaries] Extracting from API Node archive: ${apiArchiveNode}`);
    try {
      const nodeFullPath = path.join(binDir, apiArchiveNode);
      const nodeIsZip = apiArchiveNode.endsWith('.zip');
      console.log(`[unzipBinaries] Full path: ${nodeFullPath}`);
      console.log(`[unzipBinaries] Is ZIP: ${nodeIsZip}`);
      await extractNodeAddonOnly(nodeFullPath, targetDir, nodeIsZip);
    } catch (extractError) {
      console.warn(`Warning: Failed to extract Node binary from archive: ${extractError.message}`);
      // Check if binary was already present before extraction attempt
      if (areBinariesValid(targetDir)) {
        console.log('Node binary is valid despite extraction error, continuing...');
      } else {
        throw extractError;
      }
    }
  } else {
    // Extract from custom archive (legacy support)
    console.log(`[unzipBinaries] Extracting from custom archive (legacy support)`);
    const archive = fs.existsSync(sourceZip) ? sourceZip : sourceTgz;
    const isZip = fs.existsSync(sourceZip);
    console.log(`[unzipBinaries] Archive to extract: ${archive}`);
    console.log(`[unzipBinaries] Is ZIP: ${isZip}`);
    
    await extractNodeAddonOnly(archive, targetDir, isZip);
  }

  // Write version file after successful extraction
  if (currentVersion) {
    try {
      fs.writeFileSync(versionFilePath, currentVersion, 'utf8');
      console.log(`Wrote version file: ${currentVersion}`);
    } catch (err) {
      console.log(`Warning: Could not write version file: ${err.message}`);
    }
  }
}

unzipBinaries();
