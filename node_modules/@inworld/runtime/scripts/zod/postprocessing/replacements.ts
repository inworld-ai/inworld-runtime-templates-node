import * as z from 'zod';

/**
 * Configuration for postprocessing generated Zod schemas
 * This file contains all the mappings, transformers, and replacements
 * that are applied to the generated schemas to customize their behavior
 */

// Declare schemas that will exist in generated code (for type checking in FIELD_MODIFIERS)
// These are not imported, they're just declared to avoid linter errors
type AnySchema = {
  parse: (value: any) => any & Record<any, any>;
  default: (value: any) => any & Record<any, any>;
};
type AnyTypeGuard = (
  obj: unknown,
) => obj is any extends Record<any, any> ? Record<any, any> : Record<any, any>;
declare const ResponseFormatSchema: AnySchema;
declare const isText: AnyTypeGuard;
declare const TextSchema: AnySchema;

// Configuration: Add suffix to type names (e.g., "Interface" -> ContentItemInterface)
export const TYPE_SUFFIX = 'Interface';
export const ADD_TYPE_SUFFIX = false; // Set to false to disable suffix

// Configuration: Generate type guard helpers (e.g., isText)
export const GENERATE_TYPE_GUARDS = true;

// Configuration: Run eslint --fix on generated files
export const RUN_ESLINT = true;

// Configuration: Files to exclude from bundle generation
export const EXCLUDE_FROM_BUNDLE = ['descriptors.json'];

/**
 * Enum mappings for transforming friendly values to protobuf values
 *
 * Key format: "schema-file#enumName" where schema-file is the JSON schema file name
 * Value: Map of friendly values to protobuf values
 *
 * @example
 * [
 *   'ai.inworld.runtime.v1.data.SomeType.jsonschema.strict.json#someEnum',
 *   {
 *     friendly_value: 'PROTOBUF_VALUE',
 *   },
 * ]
 */
export const ENUM_MAPPINGS = new Map<string, Record<string, string>>([
  // ============================================================
  // library.json enums
  // ============================================================

  // DeviceSelection.type - library.platform
  [
    'ai.inworld.runtime.v1.library.platform.DeviceSelection.jsonschema.strict.json#type',
    {
      CPU: 'DEVICE_TYPE_CPU',
      CUDA: 'DEVICE_TYPE_CUDA',
      Metal: 'DEVICE_TYPE_METAL',
      ROCm: 'DEVICE_TYPE_ROCM',
      // unspecified: 'DEVICE_TYPE_UNSPECIFIED', // Should not be available for customers
    },
  ],

  // Device.type - library.platform
  [
    'ai.inworld.runtime.v1.library.platform.Device.jsonschema.strict.json#type',
    {
      CPU: 'DEVICE_TYPE_CPU',
      CUDA: 'DEVICE_TYPE_CUDA',
      Metal: 'DEVICE_TYPE_METAL',
      ROCm: 'DEVICE_TYPE_ROCM',
      // unspecified: 'DEVICE_TYPE_UNSPECIFIED', // Should not be available for customers
    },
  ],

  // TurnPrediction.status - library.speech
  [
    'ai.inworld.runtime.v1.library.speech.TurnPrediction.jsonschema.strict.json#status',
    {
      Incomplete: 'TURN_INCOMPLETE',
      Complete: 'TURN_COMPLETE',
      // unspecified: 'TURN_STATUS_UNSPECIFIED', // Should not be available for customers
    },
  ],

  // ImageUrl.detail - library.llm
  [
    'ai.inworld.runtime.v1.library.llm.ImageUrl.jsonschema.strict.json#detail',
    {
      auto: 'IMAGE_DETAIL_AUTO',
      low: 'IMAGE_DETAIL_LOW',
      high: 'IMAGE_DETAIL_HIGH',
      // unspecified: 'IMAGE_DETAIL_UNSPECIFIED', // Should not be available for customers
    },
  ],

  // GenerateContentChatRequest.responseFormat - library.llm
  [
    'ai.inworld.runtime.v1.library.llm.GenerateContentChatRequest.jsonschema.strict.json#responseFormat',
    {
      text: 'RESPONSE_FORMAT_TEXT',
      json: 'RESPONSE_FORMAT_JSON',
      json_schema: 'RESPONSE_FORMAT_JSON_SCHEMA',
      // unspecified: 'RESPONSE_FORMAT_UNSPECIFIED', // Should not be available for customers
    },
  ],

  // ============================================================
  // graphs.json enums
  // ============================================================

  // LLMChatRequest.responseFormat - graphs.schema
  [
    'ai.inworld.runtime.v1.graphs.schema.LLMChatRequest.jsonschema.strict.json#responseFormat',
    {
      text: 'RESPONSE_FORMAT_TEXT',
      json: 'RESPONSE_FORMAT_JSON',
      json_schema: 'RESPONSE_FORMAT_JSON_SCHEMA',
      // unspecified: 'RESPONSE_FORMAT_UNSPECIFIED', // Should not be available for customers
    },
  ],

  // LLMChatRoutingRequest.responseFormat - graphs.schema
  [
    'ai.inworld.runtime.v1.graphs.schema.LLMChatRoutingRequest.jsonschema.strict.json#responseFormat',
    {
      text: 'RESPONSE_FORMAT_TEXT',
      json: 'RESPONSE_FORMAT_JSON',
      json_schema: 'RESPONSE_FORMAT_JSON_SCHEMA',
      // unspecified: 'RESPONSE_FORMAT_UNSPECIFIED', // Should not be available for customers
    },
  ],

  // LLMChatNodeExecutionConfig.responseFormat - graphs.builtin.nodes
  [
    'ai.inworld.runtime.v1.graphs.builtin.nodes.LLMChatNodeExecutionConfig.jsonschema.strict.json#responseFormat',
    {
      text: 'RESPONSE_FORMAT_TEXT',
      json: 'RESPONSE_FORMAT_JSON',
      json_schema: 'RESPONSE_FORMAT_JSON_SCHEMA',
      // unspecified: 'RESPONSE_FORMAT_UNSPECIFIED', // Should not be available for customers
    },
  ],

  // Add more enum mappings here as needed
]);

/**
 * Property transformers for custom property validation and transformation
 *
 * This map allows you to customize the validation and transformation logic for specific properties
 * in the generated Zod schemas. This is useful when you want to:
 * - Accept multiple types for a property (e.g., string or object)
 * - Transform input values (e.g., convert objects to JSON strings)
 * - Add custom validation logic beyond what the JSON schema provides
 *
 * Key format: "schema-file#properties#propertyName"
 *   - schema-file: The name of the JSON schema file (e.g., "ai.inworld.runtime.v1.configs.llm.Tool.jsonschema.strict.json")
 *   - properties: Literal string "properties" (for future extension to support nested paths)
 *   - propertyName: The name of the property to transform (e.g., "properties")
 *
 * Value: Arrow function that returns Zod schema code
 *   - Must be valid Zod schema code starting with `z.`
 *   - Can include transformers using `.transform()`
 *   - Can use union types, refinements, and any other Zod features
 *
 * @example
 * // Accept number or string, converting string to number
 * [
 *   'ai.inworld.runtime.v1.configs.SomeType.jsonschema.strict.json#properties#someProperty',
 *   () => { z.union([z.number(), z.string()]).transform((val) => typeof val === 'string' ? parseInt(val) : val) },
 * ]
 */
export const PROPERTY_TRANSFORMERS = new Map<string, () => void>([
  [
    // Tool.properties - library.llm
    'ai.inworld.runtime.v1.library.llm.Tool.jsonschema.strict.json#properties#properties',
    // Accept both string and object for the Tool.properties field
    // If an object is provided, automatically convert it to a JSON string
    // This allows users to pass either:
    //   - properties: '{"type": "object", "properties": {...}}'  (string)
    //   - properties: {type: "object", properties: {...}}        (object)
    () => {
      z.union([z.string(), z.record(z.string(), z.any())]).transform((val) => {
        if (typeof val === 'object') {
          return JSON.stringify(val);
        }
        return val;
      });
    },
  ],
  [
    // MultimodalContent.text - graphs.schema
    'ai.inworld.runtime.v1.graphs.schema.MultimodalContent.jsonschema.strict.json#properties#text',
    () => {
      z.string()
        .transform((val) => {
          if (isText(val)) {
            return val.value;
          }
          return TextSchema.parse(val);
        })
        .optional();
    },
  ],
  // Add more property transformers here as needed
]);

/**
 * Field modifiers for overriding field values in existing schema objects
 *
 * This map allows you to override the complete field value in generated Zod schemas.
 * Unlike PROPERTY_TRANSFORMERS which replaces entire property definitions,
 * this replaces just the field value while preserving the field name and structure.
 * This is useful when you want to:
 * - Add default values to fields
 * - Override the optional/required behavior
 * - Add additional validation like .min(), .max(), etc.
 * - Completely change the field schema reference
 *
 * Key format: "schema-file#propertyName"
 *   - schema-file: The name of the JSON schema file (e.g., "ai.inworld.runtime.v1.data.LLMChatRequest.jsonschema.strict.json")
 *   - propertyName: The name of the property to modify (e.g., "responseFormat")
 *
 * Value: Arrow function that returns the complete Zod schema for the field
 *   - Must be a valid Zod schema starting with a schema reference
 *   - Can include modifiers like .default(), .optional(), etc.
 *   - Will completely replace the existing field value
 *
 * @example
 * // Add default value
 * [
 *   'ai.inworld.runtime.v1.data.SomeType.jsonschema.strict.json#someField',
 *   () => { SomeSchema.default('value') },
 * ]
 */
export const FIELD_MODIFIERS = new Map<string, () => void>([
  [
    // LLMChatRequest.responseFormat - graphs.schema
    'ai.inworld.runtime.v1.graphs.schema.LLMChatRequest.jsonschema.strict.json#responseFormat',
    () => {
      ResponseFormatSchema.default('RESPONSE_FORMAT_TEXT').optional();
    },
  ],
  [
    // ToolChoice.value - library.llm
    'ai.inworld.runtime.v1.library.llm.ToolChoice.jsonschema.strict.json#value',
    () => {
      z.string().optional();
    },
  ],
  [
    // IntentMatch.score - library.nlu
    'ai.inworld.runtime.v1.library.nlu.IntentMatch.jsonschema.strict.json#score',
    () => {
      z.number();
    },
  ],
  [
    // Message.toolCallId - library.llm
    'ai.inworld.runtime.v1.library.llm.Message.jsonschema.strict.json#toolCallId',
    () => {
      z.string().optional();
    },
  ],
  // Note: AudioFrame was renamed to AudioChunk and moved to ai.inworld.runtime.v1.library.speech
  // The data field is now a base64-encoded string instead of Float32Array
  // Note: Embedding schema was removed from library.json
  // Add more field modifiers here as needed
]);

/**
 * Exact schema replacements for postprocessing
 *
 * This map allows you to perform exact text replacements on generated schema properties.
 * This is useful when the generated schema produces something like z.union([z.number(), SomeEnumSchema])
 * but you want to simplify it to just z.number().
 *
 * Key format: Exact string to search for (must match exactly including whitespace)
 * Value: String to replace it with
 *
 * @example
 * // Simplify union
 * ['z.union([z.string(), SomeEnumSchema])', 'z.string()']
 */
export const SCHEMA_REPLACEMENTS = new Map<string, string>([
  ['z.union([z.number(), FrequencyPenaltyEnumSchema])', 'z.number()'],
  [
    'z.array(z.union([z.number(), SpeakingRateEnumSchema])).optional()',
    'z.array(z.number()).optional()',
  ],
  ['z.union([z.number(), SpeakingRateEnumSchema])', 'z.number()'],
  [
    'z.array(z.union([z.number(), EndTimeEnumSchema])).optional()',
    'z.array(z.number()).optional()',
  ],
  ['z.union([z.number(), ScoreEnumSchema])', 'z.number()'],
  // Add more exact replacements here as needed
]);

/**
 * Helper function to convert arrow function body to string
 *
 * @param {() => void} arrowFunction - Arrow function to convert
 * @param {string} transformerKey - Key for logging
 * @returns {string} The function body as a string
 */
export const arrowFunctionBodyToString = (
  arrowFunction: () => void,
  transformerKey: string,
): string => {
  const result = arrowFunction
    .toString()
    .replace(/^[^(]*\([^)]*\)\s*=>\s*{?|\}?$/g, '')
    .replace(/;\s*$/, '');

  console.log(`Result for transforming key ${transformerKey}:${result}`);
  return result;
};
