#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

/**
 * Recursively find all TypeScript files in a directory
 * @param {string} dir - Directory to search
 * @param {string[]} extensions - File extensions to include
 * @returns {string[]} Array of file paths
 */
function findFiles(dir, extensions = ['.ts', '.tsx', '.js', '.jsx']) {
  let results = [];

  if (!fs.existsSync(dir)) {
    return results;
  }

  const list = fs.readdirSync(dir);

  for (const file of list) {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);

    if (stat && stat.isDirectory()) {
      // Skip node_modules and other common directories
      if (!['node_modules', '.git', 'build', 'dist'].includes(file)) {
        results = results.concat(findFiles(filePath, extensions));
      }
    } else {
      const ext = path.extname(file);
      if (extensions.includes(ext)) {
        results.push(filePath);
      }
    }
  }

  return results;
}

/**
 * Extract all exported function objects and their methods from expose_binary.ts
 * @param {string} filePath - Path to expose_binary.ts
 * @returns {Object} Object with function objects and their methods
 */
function extractExposedMethods(filePath) {
  const content = fs.readFileSync(filePath, 'utf8');
  const methods = {};
  
  // Match exported const declarations with Functions suffix
  const exportRegex = /export const (\w+Functions) = \{([\s\S]*?)\n\};/g;
  let match;
  
  while ((match = exportRegex.exec(content)) !== null) {
    const objectName = match[1];
    const objectBody = match[2];
    
    // Split the object body into lines for better analysis
    const lines = objectBody.split('\n');
    const objectMethods = [];
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      
      // Skip empty lines and comments
      if (!line || line.startsWith('//')) {
        continue;
      }
      
      // Look for method definitions that are not commented out
      const methodMatch = line.match(/^(\w+):\s*inworld\.func\(/);
      if (methodMatch) {
        const methodName = methodMatch[1];
        objectMethods.push(methodName);
      }
    }
    
    if (objectMethods.length > 0) {
      methods[objectName] = objectMethods;
    }
  }
  
  return methods;
}

/**
 * Count commented methods in expose_binary.ts
 * @param {string} filePath - Path to expose_binary.ts
 * @returns {number} Number of commented methods
 */
function countCommentedMethods(filePath) {
  const content = fs.readFileSync(filePath, 'utf8');
  let commentedCount = 0;
  
  // Match exported const declarations with Functions suffix
  const exportRegex = /export const (\w+Functions) = \{([\s\S]*?)\n\};/g;
  let match;
  
  while ((match = exportRegex.exec(content)) !== null) {
    const objectBody = match[2];
    const lines = objectBody.split('\n');
    
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i].trim();
      
      // Look for commented method definitions
      const commentedMethodMatch = line.match(/^\/\/\s*(\w+):\s*inworld\.func\(/);
      if (commentedMethodMatch) {
        commentedCount++;
      }
    }
  }
  
  return commentedCount;
}

/**
 * Check if a method is used in any of the source files
 * @param {string} objectName - Name of the function object (e.g., 'OptionalEmbeddingMatcherConfigFunctions')
 * @param {string} methodName - Name of the method (e.g., 'newWithValue')
 * @param {string[]} sourceFiles - Array of source file paths to search
 * @param {string} exposeBinaryPath - Path to expose_binary.ts to exclude from search
 * @returns {boolean} True if the method is used
 */
function isMethodUsed(objectName, methodName, sourceFiles, exposeBinaryPath) {
  // Patterns to search for:
  // 1. ObjectName.methodName
  // 2. destructured: { methodName } from ObjectName (less common but possible)
  const patterns = [
    new RegExp(`${objectName}\\.${methodName}\\b`, 'g'),
    new RegExp(`\\b${methodName}\\b.*${objectName}`, 'g'), // for destructured imports
  ];

  for (const filePath of sourceFiles) {
    // Skip the expose_binary.ts file itself
    if (path.resolve(filePath) === path.resolve(exposeBinaryPath)) {
      continue;
    }

    try {
      const content = fs.readFileSync(filePath, 'utf8');

      for (const pattern of patterns) {
        if (pattern.test(content)) {
          return true;
        }
      }
    } catch (error) {
      console.warn(
        `Warning: Could not read file ${filePath}: ${error.message}`,
      );
    }
  }

  return false;
}

/**
 * Main function to find unused bindings
 */
function main() {
  const projectRoot = path.resolve(__dirname, '../..');
  const exposeBinaryPath = path.join(projectRoot, 'src/expose_binary.ts');
  const srcDir = path.join(projectRoot, 'src');

  console.log('üîç Scanning for unused bindings...\n');
  console.log(`üìÅ Project root: ${projectRoot}`);
  console.log(`üìÑ Bindings file: ${exposeBinaryPath}`);
  console.log(`üìÇ Source directory: ${srcDir}\n`);

  // Check if expose_binary.ts exists
  if (!fs.existsSync(exposeBinaryPath)) {
    console.error(`‚ùå Error: ${exposeBinaryPath} not found`);
    process.exit(1);
  }

    // Extract all methods from expose_binary.ts
  console.log('üìã Extracting exposed methods...');
  const exposedMethods = extractExposedMethods(exposeBinaryPath);
  const commentedMethodsCount = countCommentedMethods(exposeBinaryPath);
  
  const totalObjects = Object.keys(exposedMethods).length;
  const totalActiveMethods = Object.values(exposedMethods).reduce(
    (sum, methods) => sum + methods.length,
    0,
  );
  
  console.log(
    `   Found ${totalObjects} function objects with ${totalActiveMethods} active methods`,
  );
  console.log(`   Found ${commentedMethodsCount} commented methods (excluded from analysis)\n`);

  // Find all source files
  console.log('üìÇ Finding source files...');
  const sourceFiles = findFiles(srcDir);
  console.log(`   Found ${sourceFiles.length} source files\n`);

  // Check usage for each method
  console.log('üîé Checking method usage...\n');

  const unusedMethods = [];
  let checkedCount = 0;

  for (const [objectName, methods] of Object.entries(exposedMethods)) {
    for (const methodName of methods) {
      checkedCount++;
      const isUsed = isMethodUsed(
        objectName,
        methodName,
        sourceFiles,
        exposeBinaryPath,
      );

      if (!isUsed) {
        unusedMethods.push(`${objectName}.${methodName}`);
      }

              // Progress indicator
        if (checkedCount % 50 === 0) {
          console.log(`   Checked ${checkedCount}/${totalActiveMethods} methods...`);
        }
    }
  }

  // Results
  console.log(`\n‚úÖ Analysis complete! Checked ${totalActiveMethods} active methods.\n`);

  if (unusedMethods.length === 0) {
    console.log(
      'üéâ No unused methods found! All bindings appear to be in use.',
    );
  } else {
    console.log(
      `‚ùå Found ${unusedMethods.length} potentially unused methods:\n`,
    );

    // Group by object for better readability
    const groupedUnused = {};
    for (const method of unusedMethods) {
      const [objectName, methodName] = method.split('.');
      if (!groupedUnused[objectName]) {
        groupedUnused[objectName] = [];
      }
      groupedUnused[objectName].push(methodName);
    }

    for (const [objectName, methods] of Object.entries(groupedUnused)) {
      console.log(`üì¶ ${objectName}:`);
      for (const method of methods.sort()) {
        console.log(`   ‚Ä¢ ${method}`);
      }
      console.log();
    }

    console.log(
      '‚ö†Ô∏è  Note: This analysis may have false positives if methods are:',
    );
    console.log('   - Used dynamically (e.g., via string keys)');
    console.log('   - Used in generated code or external files');
    console.log('   - Used through complex import patterns');
    console.log('   - Required for future functionality');
    
    // Throw an error to fail the script/CI
    console.log('\nüí• Throwing error due to unused methods found.');
    throw new Error(`Found ${unusedMethods.length} unused methods in src/expose_binary.ts. Please comment them out or verify they are needed.`);
  }
}

// Run the script
if (require.main === module) {
  main();
}

module.exports = {
  findFiles,
  extractExposedMethods,
  countCommentedMethods,
  isMethodUsed,
};
