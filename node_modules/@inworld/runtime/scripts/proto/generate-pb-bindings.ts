#!/usr/bin/env ts-node

import fs from 'fs';
import path from 'path';
import protobuf from 'protobufjs';

const REPO_ROOT = path.resolve(__dirname, '..', '..');
const PB_FILE_PATH = path.resolve(REPO_ROOT, 'src/internal/pb.ts');
const DESCRIPTORS_PATH = path.resolve(
  REPO_ROOT,
  'src/internal/generated/descriptors.json',
);
const OUTPUT_PATH = path.resolve(
  REPO_ROOT,
  'src/internal/generated/pb-bindings.ts',
);

const GENERATED_HEADER = `/**
 * DO NOT EDIT.
 * This file is autogenerated by scripts/proto/generate-pb-bindings.ts
 */
`;

type DescriptorNode = {
  nested?: Record<string, DescriptorNode>;
  fields?: Record<string, unknown>;
  oneofs?: Record<string, unknown>;
};

type ProtoDescriptorEntry = {
  fullName: string;
  pascalFullName: string;
  typeName: string;
};

const RUNTIME_NAMESPACE_PREFIX = ['ai', 'inworld', 'runtime', 'v1'];

/**
 * Mappings for types that have been renamed in the new proto structure.
 * Maps old alias names (used in pb.ts) to new type names in descriptors.
 */
const ALIAS_TYPE_MAPPINGS: Record<string, string> = {
  AudioFrame: 'AudioChunk',
  LLMMessage: 'Message',
  TextClassifierResponse: 'ClassifyTextResponse',
  KnowledgeCompilationRequest: 'CompileKnowledgeRequest',
  KnowledgeGetRequest: 'GetKnowledgeRequest',
  ConfigsEmbedRequest: 'EmbedRequest',
};

function loadDescriptors(): DescriptorNode {
  if (!fs.existsSync(DESCRIPTORS_PATH)) {
    throw new Error(`Descriptors file not found at ${DESCRIPTORS_PATH}`);
  }

  const raw = fs.readFileSync(DESCRIPTORS_PATH, 'utf-8');
  return JSON.parse(raw) as DescriptorNode;
}

function toPascalCase(input: string): string {
  return input
    .split(/[^A-Za-z0-9]/)
    .filter(Boolean)
    .map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1))
    .join('');
}

function collectMessageTypes(
  node: DescriptorNode,
  pathSegments: string[] = [],
  acc: ProtoDescriptorEntry[] = [],
): ProtoDescriptorEntry[] {
  if (!node || typeof node !== 'object') {
    return acc;
  }

  if (node.fields || node.oneofs) {
    const fullName = pathSegments.join('.');
    const pascalFullName = pathSegments.map(toPascalCase).join('');
    acc.push({
      fullName,
      pascalFullName,
      typeName: pathSegments[pathSegments.length - 1],
    });
  }

  if (node.nested) {
    for (const [name, child] of Object.entries(node.nested)) {
      collectMessageTypes(child, [...pathSegments, name], acc);
    }
  }

  return acc;
}

function loadAliasesFromPbFile(): string[] {
  if (!fs.existsSync(PB_FILE_PATH)) {
    throw new Error(`pb.ts not found at ${PB_FILE_PATH}`);
  }

  const content = fs.readFileSync(PB_FILE_PATH, 'utf-8');
  const match = content.match(
    /const\s*{\s*([^}]+)\s*}\s*=\s*createProtoTypeBindings\s*\(/m,
  );

  if (!match) {
    throw new Error(
      'Unable to locate createProtoTypeBindings destructuring in pb.ts',
    );
  }

  return match[1]
    .split(',')
    .map((item) => item.trim())
    .filter(Boolean);
}

function resolveAliasToFullName(
  alias: string,
  descriptors: ProtoDescriptorEntry[],
): string {
  // Check if the alias has been renamed in new proto structure
  const mappedTypeName = ALIAS_TYPE_MAPPINGS[alias];
  const typeNameToFind = mappedTypeName || alias;

  let matches = descriptors.filter(
    (entry) => entry.typeName === typeNameToFind,
  );

  if (matches.length === 0) {
    matches = getSpecialCaseMatches(alias, descriptors);
  }

  if (matches.length === 0) {
    throw new Error(`Unable to resolve alias "${alias}" to a descriptor.`);
  }

  if (matches.length === 1) {
    return matches[0].fullName;
  }

  return selectPreferredMatch(matches).fullName;
}

function getSpecialCaseMatches(
  alias: string,
  descriptors: ProtoDescriptorEntry[],
): ProtoDescriptorEntry[] {
  // Check if the alias has a type mapping (renamed types)
  const mappedTypeName = ALIAS_TYPE_MAPPINGS[alias];

  if (alias.startsWith('GoogleProtobuf')) {
    const typeName = alias.replace('GoogleProtobuf', '');
    if (typeName) {
      return descriptors.filter(
        (entry) =>
          entry.typeName === typeName &&
          entry.fullName.startsWith('google.protobuf.'),
      );
    }
  }

  // Handle shorter Google prefix (e.g., GoogleStruct -> google.protobuf.Struct)
  if (alias.startsWith('Google') && alias !== 'GoogleProtobuf') {
    const typeName = alias.replace('Google', '');
    if (typeName) {
      return descriptors.filter(
        (entry) =>
          entry.typeName === typeName &&
          entry.fullName.startsWith('google.protobuf.'),
      );
    }
  }

  // Data* aliases -> look in graphs.schema (new structure)
  if (alias.startsWith('Data')) {
    const baseName = alias.slice(4); // Remove 'Data' prefix
    const typeName = mappedTypeName || baseName || alias;
    return descriptors.filter(
      (entry) =>
        entry.typeName === typeName &&
        entry.fullName.includes('.graphs.schema.'),
    );
  }

  // LLM* aliases -> look in library.llm or graphs.schema
  if (alias.startsWith('LLM') && alias !== 'LLM') {
    const baseName = alias.slice(3); // Remove 'LLM' prefix
    const typeName = mappedTypeName || baseName;
    if (typeName) {
      return descriptors.filter(
        (entry) =>
          entry.typeName === typeName &&
          (entry.fullName.includes('.library.llm.') ||
            entry.fullName.includes('.graphs.schema.')),
      );
    }
  }

  // Configs* aliases -> look in library.* subpackages (new structure)
  if (alias.startsWith('Configs')) {
    const baseName = alias.replace('Configs', '');
    const typeName = mappedTypeName || baseName;
    if (typeName) {
      return descriptors.filter(
        (entry) =>
          entry.typeName === typeName &&
          (entry.fullName.includes('.library.telemetry.') ||
            entry.fullName.includes('.library.speech.') ||
            entry.fullName.includes('.library.embeddings.') ||
            entry.fullName.includes('.library.core.') ||
            entry.fullName.includes('.graphs.execution.') ||
            entry.fullName.includes('.graphs.spec.')),
      );
    }
  }

  return [];
}

function selectPreferredMatch(
  matches: ProtoDescriptorEntry[],
): ProtoDescriptorEntry {
  const namespaceRank = (fullName: string) => {
    // graphs.schema has the core data types (DataContainer, Text, Audio, etc.)
    if (fullName.includes('.graphs.schema.')) return 1;
    // library subpackages
    if (fullName.includes('.library.llm.')) return 2;
    if (fullName.includes('.library.speech.')) return 3;
    if (fullName.includes('.library.nlu.')) return 4;
    if (fullName.includes('.library.knowledge.')) return 5;
    if (fullName.includes('.library.embeddings.')) return 6;
    if (fullName.includes('.library.telemetry.')) return 7;
    if (fullName.includes('.library.platform.')) return 8;
    if (fullName.includes('.library.mcp.')) return 9;
    if (fullName.includes('.library.serp.')) return 10;
    if (fullName.includes('.library.core.')) return 11;
    // graphs other subpackages
    if (fullName.includes('.graphs.execution.')) return 12;
    if (fullName.includes('.graphs.spec.')) return 13;
    if (fullName.includes('.graphs.builtin.')) return 14;
    if (fullName.includes('.graphs.')) return 15;
    // google types
    if (fullName.startsWith('google.')) return 50;
    return 99;
  };

  return matches.sort((a, b) => {
    const rankDiff = namespaceRank(a.fullName) - namespaceRank(b.fullName);
    if (rankDiff !== 0) {
      return rankDiff;
    }
    return a.fullName.length - b.fullName.length;
  })[0];
}

function makeUniqueAlias(baseAlias: string, usedAliases: Set<string>): string {
  let alias = baseAlias;
  let counter = 1;

  while (usedAliases.has(alias) || !alias) {
    alias = `${baseAlias}_${counter}`;
    counter += 1;
  }

  usedAliases.add(alias);
  return alias;
}

function trimRuntimeNamespace(fullName: string): string[] {
  const segments = fullName.split('.');

  if (
    segments.length >= RUNTIME_NAMESPACE_PREFIX.length &&
    RUNTIME_NAMESPACE_PREFIX.every(
      (segment, idx) => segments[idx] === RUNTIME_NAMESPACE_PREFIX[idx],
    )
  ) {
    return segments.slice(RUNTIME_NAMESPACE_PREFIX.length);
  }

  return segments;
}

function getAutoAlias(entry: ProtoDescriptorEntry): string {
  const trimmedSegments = trimRuntimeNamespace(entry.fullName);
  if (trimmedSegments.length > 0) {
    const firstSegment = trimmedSegments[0];
    const lastSegment = trimmedSegments[trimmedSegments.length - 1];
    const aliasSegments =
      firstSegment === lastSegment
        ? [firstSegment]
        : [firstSegment, lastSegment];

    const alias = aliasSegments
      .map((segment) => toPascalCase(segment))
      .join('');

    if (alias) {
      return alias;
    }
  }

  return toPascalCase(entry.typeName);
}

function buildResolvedEntries(
  descriptorEntries: ProtoDescriptorEntry[],
  aliasesFromPb: string[],
): { alias: string; fullName: string }[] {
  const resolvedEntries: { alias: string; fullName: string }[] = [];
  const usedFullNames = new Set<string>();
  const usedAliases = new Set<string>();

  aliasesFromPb.forEach((alias) => {
    const fullName = resolveAliasToFullName(alias, descriptorEntries);
    resolvedEntries.push({ alias, fullName });
    usedFullNames.add(fullName);
    usedAliases.add(alias);
  });

  descriptorEntries.forEach((entry) => {
    if (usedFullNames.has(entry.fullName)) {
      return;
    }

    const baseAlias = getAutoAlias(entry);
    const alias = makeUniqueAlias(baseAlias, usedAliases);

    resolvedEntries.push({ alias, fullName: entry.fullName });
    usedFullNames.add(entry.fullName);
  });

  return resolvedEntries.sort((a, b) => a.alias.localeCompare(b.alias));
}

function buildOutput(entries: { alias: string; fullName: string }[]): string {
  const fullNameLines = entries
    .map(({ alias, fullName }) => `  ${alias}: '${fullName}' as const,`)
    .join('\n');

  const bindingLines = entries
    .map(({ alias }) => `  ${alias}: Type;`)
    .join('\n');

  const lookupLines = entries
    .map(
      ({ alias, fullName }) => `    ${alias}: root.lookupType('${fullName}'),`,
    )
    .join('\n');

  return `${GENERATED_HEADER}import type { Root, Type } from 'protobufjs';

export const PROTO_TYPE_FULL_NAMES = {
${fullNameLines}
};

export type ProtoTypeName = keyof typeof PROTO_TYPE_FULL_NAMES;

export type ProtoTypeBindings = {
${bindingLines}
};

export function createProtoTypeBindings(root: Root): ProtoTypeBindings {
  return {
${lookupLines}
  };
}
`;
}

function run(): void {
  const descriptorsJson = loadDescriptors();
  const descriptorEntries = collectMessageTypes(descriptorsJson);
  const aliases = loadAliasesFromPbFile();
  const resolvedEntries = buildResolvedEntries(descriptorEntries, aliases);

  const root = protobuf.Root.fromJSON(descriptorsJson as protobuf.INamespace);
  resolvedEntries.forEach(({ alias, fullName }) => {
    try {
      root.lookupType(fullName);
    } catch (error) {
      throw new Error(
        `Failed to lookup type "${fullName}" for alias "${alias}": ${String(
          error,
        )}`,
      );
    }
  });

  const output = buildOutput(resolvedEntries);
  fs.writeFileSync(OUTPUT_PATH, output, 'utf-8');
  console.log(`âœ“ Generated ${OUTPUT_PATH}`);
}

run();
