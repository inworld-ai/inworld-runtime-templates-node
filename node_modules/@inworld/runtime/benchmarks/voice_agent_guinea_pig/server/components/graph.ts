import {
  CustomNode,
  FakeRemoteLLMComponent,
  FakeTTSComponent,
  Graph,
  GraphBuilder,
  GraphTypes,
  ProcessContext,
  ProxyNode,
  RemoteLLMChatNode,
  RemoteSTTNode,
  RemoteTTSNode,
  TextChunkingNode,
} from '@inworld/runtime/graph';

import { TEXT_CONFIG, TTS_SAMPLE_RATE } from '../../constants';
import {
  AudioInput,
  CreateGraphPropsInterface,
  State,
  TextInput,
} from '../types';
import { EventFactory } from './event_factory';

const useRealComponents = () =>
  process.env.USE_REAL_GRAPH_COMPONENTS === 'true' ||
  process.env.USE_REAL_GRAPH_COMPONENTS === '1';

export class InworldGraphWrapper {
  graph: Graph;

  private constructor({ graph }: { graph: Graph }) {
    this.graph = graph;
  }

  async destroy() {
    await this.graph.stop();
  }

  static async create(props: CreateGraphPropsInterface) {
    const {
      apiKey,
      llmModelName,
      llmProvider,
      voiceId,
      connections,
      withAudioInput = false,
      ttsModelId,
    } = props;

    const postfix = withAudioInput ? '-with-audio-input' : '-with-text-input';

    // Custom node to build a LLM chat request from the state.
    class DialogPromptBuilderNode extends CustomNode {
      process(
        _context: ProcessContext,
        state: State,
      ): GraphTypes.LLMChatRequest {
        // Convert state messages to LLMMessageInterface format
        const conversationMessages = state.messages.map((msg) => ({
          role: msg.role,
          content: msg.content,
        }));

        return new GraphTypes.LLMChatRequest({
          messages: conversationMessages,
        });
      }
    }

    // Custom node to update the state with the user's input this turn.
    class UpdateStateNode extends CustomNode {
      process(_context: ProcessContext, input: TextInput): State {
        const { text, interactionId, key } = input;
        const connection = connections[key];
        if (connection?.unloaded) {
          throw Error(`Session unloaded for key:${key}`);
        }
        if (!connection) {
          throw Error(`Failed to read connection for key:${key}`);
        }
        const state = connections[key].state;
        if (!state) {
          throw Error(`Failed to read state from connection for key:${key}`);
        }
        connections[key].state.messages.push({
          role: 'user',
          content: text,
          id: interactionId,
        });
        connections[key].ws.send(
          JSON.stringify(
            EventFactory.text(text, interactionId, {
              isUser: true,
            }),
          ),
        );
        return connections[key].state;
      }
    }

    const dialogPromptBuilderNode = new DialogPromptBuilderNode({
      id: `dialog-prompt-builder-node${postfix}`,
    });
    const updateStateNode = new UpdateStateNode();

    const llmComponent = new FakeRemoteLLMComponent({
      id: `llm-node${postfix}`,
      provider: 'fake-provider',
      modelName: 'fake-model',
    });

    const llmNode = new RemoteLLMChatNode({
      id: `llm-node${postfix}`,
      ...(useRealComponents()
        ? {
            provider: llmProvider,
            modelName: llmModelName,
            stream: true,
            textGenerationConfig: TEXT_CONFIG,
          }
        : { llmComponent }),
    });

    const textChunkingNode = new TextChunkingNode({
      id: `text-chunking-node${postfix}`,
    });

    const ttsComponent = new FakeTTSComponent({
      id: 'tts-component-async',
      loadTestConfig: {
        firstChunkDelay: 200, // I/O-bound: heavy delays
        sampleRate: 48000,
        errorProbability: 0.0, // 2% error rate
        chunksPerRequest: 20,
        interChunkDelay: 100, // Total delay: ~2200ms per request
        collectMetrics: true,
      },
    });
    const ttsNode = new RemoteTTSNode({
      id: `tts-node${postfix}`,
      ...(useRealComponents()
        ? {
            speakerId: voiceId,
            modelId: ttsModelId,
            sampleRate: TTS_SAMPLE_RATE,
            temperature: 0.8,
            speakingRate: 1,
          }
        : { ttsComponent }),
    });

    const graphName = `voice-agent${postfix}`;
    const graphBuilder = new GraphBuilder({
      id: graphName,
      apiKey,
      enableRemoteConfig: false,
    });

    graphBuilder
      .addNode(updateStateNode)
      .addNode(dialogPromptBuilderNode)
      .addNode(llmNode)
      .addNode(textChunkingNode)
      .addNode(ttsNode)
      .addEdge(updateStateNode, dialogPromptBuilderNode)
      .addEdge(dialogPromptBuilderNode, llmNode)
      .addEdge(llmNode, textChunkingNode)
      .addEdge(textChunkingNode, ttsNode);

    if (withAudioInput) {
      // Custom node to join the result from STT and the original input metadata to form
      // the final text input.
      class TextInputNode extends CustomNode {
        process(
          _context: ProcessContext,
          audioInput: AudioInput,
          text: string,
        ): TextInput {
          const { audio: _audio, ...rest } = audioInput as any;
          return { text, ...(rest as object) } as TextInput;
        }
      }

      // Custom node to extract the audio data from the audio input to pass to the stt node
      class AudioFilterNode extends CustomNode {
        process(_context: ProcessContext, input: AudioInput): GraphTypes.Audio {
          return new GraphTypes.Audio({
            data: input.audio.data,
            sampleRate: input.audio.sampleRate,
          });
        }
      }

      // start node to pass the audio input to both the audio filter and text input nodes.
      const audioInputNode = new ProxyNode();

      const textInputNode = new TextInputNode();
      const audioFilterNode = new AudioFilterNode();
      const sttNode = new RemoteSTTNode();

      graphBuilder
        .addNode(audioInputNode)
        .addNode(audioFilterNode)
        .addNode(sttNode)
        .addNode(textInputNode)
        .addEdge(audioInputNode, textInputNode)
        .addEdge(audioInputNode, audioFilterNode)
        .addEdge(audioFilterNode, sttNode)
        .addEdge(sttNode, textInputNode)
        .addEdge(textInputNode, updateStateNode)
        .setStartNode(audioInputNode);
    } else {
      graphBuilder.setStartNode(updateStateNode);
    }

    graphBuilder.setEndNode(ttsNode);

    const graph = graphBuilder.build();

    return new InworldGraphWrapper({
      graph,
    });
  }
}
