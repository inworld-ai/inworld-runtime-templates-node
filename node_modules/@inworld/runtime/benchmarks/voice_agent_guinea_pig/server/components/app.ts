import { VAD } from '@inworld/runtime/primitives/vad';
import { v4 } from 'uuid';
const { validationResult } = require('express-validator');

import {
  configureMetric,
  initTelemetry,
  metric,
  MetricType,
  shutdownTelemetry,
  TelemetryLogLevel,
} from '@inworld/runtime/telemetry';

import { SPEECH_THRESHOLD } from '../../constants';
import { parseEnvironmentVariables } from '../helpers';
import { Connection } from '../types';
import { EventFactory } from './event_factory';
import { InworldGraphWrapper } from './graph';

export class InworldApp {
  apiKey: string;
  llmModelName: string;
  llmProvider: string;
  voiceId: string;
  vadModelPath: string;
  interruptionEnabled: boolean;
  ttsModelId: string;
  connections: {
    [key: string]: Connection;
  } = {};

  vadClient: any;

  graphWithAudioInput: InworldGraphWrapper;
  graphWithTextInput: InworldGraphWrapper;

  promptTemplate: string;

  async initialize() {
    this.connections = {};

    // Parse the environment variables
    const env = parseEnvironmentVariables();

    this.apiKey = env.apiKey;
    this.llmModelName = env.llmModelName;
    this.llmProvider = env.llmProvider;
    this.voiceId = env.voiceId;
    this.vadModelPath = env.vadModelPath;
    this.interruptionEnabled = env.interruptionEnabled;
    this.ttsModelId = env.ttsModelId;

    // Initialize the VAD client
    console.log('Loading VAD model from:', this.vadModelPath);
    this.vadClient = await VAD.create({
      localConfig: {
        modelPath: this.vadModelPath,
        device: { type: 'DEVICE_TYPE_CPU', index: 0 },
        defaultConfig: { speechThreshold: SPEECH_THRESHOLD },
      },
    });

    this.graphWithTextInput = await InworldGraphWrapper.create({
      apiKey: this.apiKey,
      llmModelName: this.llmModelName,
      llmProvider: this.llmProvider,
      voiceId: this.voiceId,
      connections: this.connections,
      ttsModelId: this.ttsModelId,
    });

    this.graphWithAudioInput = await InworldGraphWrapper.create({
      apiKey: this.apiKey,
      llmModelName: this.llmModelName,
      llmProvider: this.llmProvider,
      voiceId: this.voiceId,
      connections: this.connections,
      withAudioInput: true,
      ttsModelId: this.ttsModelId,
    });
  }

  async load(req: any, res: any) {
    res.setHeader('Content-Type', 'application/json');

    const errors = validationResult(req);

    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    const agent = {
      ...req.body.agent,
      id: v4(),
    };

    this.connections[req.query.key] = {
      state: {
        messages: [
          {
            role: 'system',
            content: this.createSystemMessage(agent),
            id: v4(),
          },
        ],
        agent,
        userName: req.body.userName,
      },
      ws: null,
    };

    res.end(JSON.stringify({ agent }));
  }

  private createSystemMessage(agent: any) {
    return `You are: "${agent.name}". Your persona is: "${agent.description}". Your motivation is: "${agent.motivation}".`;
  }

  unload(req: any, res: any) {
    res.setHeader('Content-Type', 'application/json');

    const errors = validationResult(req);

    if (!errors.isEmpty()) {
      return res.status(400).json({ errors: errors.array() });
    }

    this.connections[req.query.key].unloaded = true;

    res.end(JSON.stringify({ message: 'Session unloaded' }));
  }

  initTelemetry() {
    initTelemetry({
      apiKey: process.env.INWORLD_API_KEY,
      appName: 'Voice Agent Load Test Guinea Pig',
      appVersion: '1.0.0',
      logger: {
        level: TelemetryLogLevel.Error,
      },
    });
    configureMetric({
      metricType: MetricType.CounterDouble,
      name: 'memory.rss',
      description:
        'Resident Set Size, is the amount of space occupied in the main memory device (that is a subset of the total allocated memory) for the process, including all C++ and JavaScript objects and code.',
      unit: 'megabytes',
    });
    configureMetric({
      metricType: MetricType.CounterDouble,
      name: 'memory.heapTotal',
      description: 'Refers to V8s memory usage.',
      unit: 'megabytes',
    });
    configureMetric({
      metricType: MetricType.CounterDouble,
      name: 'memory.heapUsed',
      description: 'Refers to V8s memory usage.',
      unit: 'megabytes',
    });
    configureMetric({
      metricType: MetricType.CounterUInt,
      name: 'cpu.user',
      description: 'user CPU time usage of the current process',
      unit: 'microseconds',
    });
    configureMetric({
      metricType: MetricType.CounterUInt,
      name: 'cpu.system',
      description: 'system CPU time usage of the current process',
      unit: 'microseconds',
    });
  }

  private collectMetricsInterval: NodeJS.Timeout;
  startCollectingMetrics() {
    this.collectMetricsInterval = setInterval(() => {
      const cpuUsage = EventFactory.cpuSnapshot();
      const memoryUsage = EventFactory.memorySnapshot();
      metric.recordCounterUInt('cpu.system', cpuUsage.data.system);
      metric.recordCounterUInt('cpu.user', cpuUsage.data.user);
      metric.recordCounterDouble('memory.heapUsed', memoryUsage.data.heapUsed);
      metric.recordCounterDouble(
        'memory.heapTotal',
        memoryUsage.data.heapTotal,
      );
      metric.recordCounterDouble('memory.rss', memoryUsage.data.rss);
    }, 5000);
  }

  stopCollectingMetrics() {
    clearInterval(this.collectMetricsInterval);
  }

  shutdown() {
    this.connections = {};
    this.graphWithTextInput.destroy();
    this.graphWithAudioInput.destroy();
    this.stopCollectingMetrics();
    shutdownTelemetry();
  }
}
