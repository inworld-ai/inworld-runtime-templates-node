import 'dotenv/config';

const minimist = require('minimist');

import {
  CustomNode,
  GraphBuilder,
  ProcessContext,
} from '@inworld/runtime/graph';

const usage = `
Usage:
    yarn node-custom-reverse-load-test "Hello, how can I help you?" \\n
    --threads=<number>[optional, 1 will be used by default - number of concurrent operations] \\n
    --requests_per_thread=<number>[optional, 1 will be used by default - requests each thread makes] \\n
    --config=<config>[optional, fast/medium/slow/cpu-intensive - fast will be used by default] \\n
    
Note: This is a pure CPU-bound load test for custom text processing (no external APIs)
Architecture: Single CustomReverseNode
Total requests = threads × requests_per_thread
Execution: Event loop concurrency with async operations

Timing Metrics:
  • Graph initialization: One-time setup cost (components, connections, validation)
  • Request processing: Recurring cost per request (text reversal + artificial delays)
  • In production: Initialize once, process many requests (amortized init cost)
  
Workload Configurations:
  fast          - Minimal delays (~1ms/request) - pure CPU processing
  medium        - Light delays (~10ms/request) - simulated I/O
  slow          - Heavy delays (~100ms/request) - simulated heavy I/O
  cpu-intensive - Complex text processing with iterations`;

// Custom reverse node with configurable processing delays
class CustomReverseNode extends CustomNode {
  private config: any;

  constructor(config: any = {}) {
    super();
    this.config = config;
  }

  async process(_context: ProcessContext, input: string): Promise<string> {
    // Add artificial delay based on configuration to simulate different workloads
    if (this.config.processingDelayMs > 0) {
      await new Promise((resolve) =>
        setTimeout(resolve, this.config.processingDelayMs),
      );
    }

    let result = input;

    // Different processing complexity based on config
    if (this.config.iterations) {
      // CPU-intensive: multiple iterations of text processing
      for (let i = 0; i < this.config.iterations; i++) {
        result = result.split('').reverse().join('');
        // Add some additional CPU work
        if (this.config.cpuIntensive) {
          result = result.split(' ').reverse().join(' ');
        }
      }
    } else {
      // Simple reverse
      result = input.split('').reverse().join('');
    }

    return result;
  }
}

// Thread-safe statistics collection
class LoadTestStats {
  totalRequests = 0;
  successfulRequests = 0;
  failedRequests = 0;
  totalProcessingTimeMs = 0;
  errorMessages: string[] = [];

  addRequest() {
    this.totalRequests++;
  }

  addSuccessfulRequest(processingTimeMs: number) {
    this.successfulRequests++;
    this.totalProcessingTimeMs += processingTimeMs;
  }

  addFailedRequest(errorMessage: string) {
    this.failedRequests++;
    this.errorMessages.push(errorMessage);
  }

  getSuccessRate(): number {
    return this.totalRequests > 0
      ? (this.successfulRequests / this.totalRequests) * 100
      : 0;
  }

  getAverageProcessingTime(): number {
    return this.successfulRequests > 0
      ? this.totalProcessingTimeMs / this.successfulRequests
      : 0;
  }

  getThroughput(totalTestTimeMs: number): number {
    return totalTestTimeMs > 0
      ? (this.totalRequests / totalTestTimeMs) * 1000
      : 0; // requests per second
  }
}

// Configuration presets for different workload types
function getLoadTestConfig(configName: string) {
  switch (configName) {
    case 'fast':
      return {
        processingDelayMs: 1, // Minimal delay - mostly CPU
        iterations: 1,
        cpuIntensive: false,
        description: 'Pure CPU processing with minimal delays',
      };
    case 'medium':
      return {
        processingDelayMs: 10, // Light I/O simulation
        iterations: 1,
        cpuIntensive: false,
        description: 'Light I/O simulation with text processing',
      };
    case 'slow':
      return {
        processingDelayMs: 100, // Heavy I/O simulation
        iterations: 1,
        cpuIntensive: false,
        description: 'Heavy I/O simulation with text processing',
      };
    case 'cpu-intensive':
      return {
        processingDelayMs: 1, // Minimal delays
        iterations: 10, // Multiple iterations
        cpuIntensive: true, // Additional CPU work
        description: 'CPU-intensive text processing with multiple iterations',
      };
    default:
      throw new Error(
        `Invalid config '${configName}'. Use: fast, medium, slow, or cpu-intensive`,
      );
  }
}

// Main execution
run().catch((error) => {
  console.error('Main execution error:', error);
  process.exit(1);
});

async function run() {
  const { text, apiKey, threads, requestsPerThread, config } = parseArgs();

  console.log('\n=== Custom Reverse Node Load Test ===');
  console.log(`Architecture: Single CustomReverseNode`);
  console.log(`Configuration: ${config}`);
  console.log(`Threads: ${threads}`);
  console.log(`Requests per thread: ${requestsPerThread}`);
  console.log(`Total requests: ${threads * requestsPerThread}`);
  console.log(`Text: "${text}"`);

  await runAsyncMode({
    text,
    apiKey,
    threads,
    requestsPerThread,
    config,
  });
}

async function runAsyncMode({
  text,
  apiKey,
  threads,
  requestsPerThread,
  config,
}: {
  text: string;
  apiKey: string;
  threads: number;
  requestsPerThread: number;
  config: string;
}) {
  // Initialize statistics tracking
  const stats = new LoadTestStats();
  const totalRequests = threads * requestsPerThread;

  // Warn about very high concurrent operations
  if (totalRequests > 10000) {
    console.log(
      `⚠️  Warning: ${totalRequests} total requests in async mode may cause high memory usage.`,
    );
  }

  const initStartTime = Date.now();

  const loadTestConfig = getLoadTestConfig(config);
  console.log(`Workload: ${loadTestConfig.description}`);

  const customNode = new CustomReverseNode(loadTestConfig);

  const graph = new GraphBuilder({
    id: 'custom_reverse_load_test_graph',
    apiKey,
    enableRemoteConfig: false,
  })
    .addNode(customNode)
    .setStartNode(customNode)
    .setEndNode(customNode)
    .build();

  const initEndTime = Date.now();
  const initializationTime = initEndTime - initStartTime;

  console.log(
    `✅ Custom reverse graph ready - ONE instance will handle all requests`,
  );
  console.log(`⏱️  Graph initialization time: ${initializationTime}ms`);

  console.log('Starting async custom reverse load test...');
  const testStartTime = Date.now();

  // Create worker thread promises
  const workerPromises = Array.from(
    { length: threads },
    async (_, threadIndex) => {
      const threadId = threadIndex + 1;
      const workerResults: any[] = [];

      // Each worker makes multiple requests
      for (
        let requestIndex = 0;
        requestIndex < requestsPerThread;
        requestIndex++
      ) {
        const globalRequestNumber = threadId * 1000 + requestIndex + 1; // Unique request ID
        stats.addRequest();

        try {
          const startTime = Date.now();

          const { outputStream } = await graph.start(text);
          const result = await outputStream.next();
          let processedText: string | null = null;

          await result.processResponse({
            string: (data: string) => {
              processedText = data;
            },
            default: (data) => {
              console.log('Unprocessed data:', data);
            },
          });

          const endTime = Date.now();
          const duration = endTime - startTime;

          // Check if the request was successful
          if (processedText !== null && processedText.length > 0) {
            stats.addSuccessfulRequest(duration);

            workerResults.push({
              threadId,
              requestIndex: requestIndex + 1,
              globalRequestNumber,
              success: true,
              duration,
              originalText: text,
              reversedText: processedText,
              textLength: text.length,
            });
          } else {
            const errorMsg = `Thread ${threadId} Request ${requestIndex + 1}: No processed text returned`;
            stats.addFailedRequest(errorMsg);

            workerResults.push({
              threadId,
              requestIndex: requestIndex + 1,
              globalRequestNumber,
              success: false,
              duration,
              error: errorMsg,
            });
          }
        } catch (error) {
          const errorMsg = `Thread ${threadId} Request ${requestIndex + 1}: Exception: ${error instanceof Error ? error.message : String(error)}`;
          stats.addFailedRequest(errorMsg);

          workerResults.push({
            threadId,
            requestIndex: requestIndex + 1,
            globalRequestNumber,
            success: false,
            error: errorMsg,
          });
        }
      }

      return workerResults;
    },
  );

  // Wait for all worker threads to complete
  const workerResults = await Promise.all(workerPromises);

  // Flatten all results from all workers
  const results = workerResults.flat();

  const testEndTime = Date.now();
  const totalTestTime = testEndTime - testStartTime;

  // Print comprehensive results
  console.log('\n=== Custom Reverse Load Test Results ===');
  console.log(
    `Graph initialization time: ${initializationTime}ms (one-time cost)`,
  );
  console.log(
    `Request processing time: ${totalTestTime}ms (${totalRequests} requests)`,
  );
  console.log(
    `Total time (init + requests): ${initializationTime + totalTestTime}ms`,
  );
  console.log(`Total requests: ${stats.totalRequests}`);
  console.log(`Successful requests: ${stats.successfulRequests}`);
  console.log(`Failed requests: ${stats.failedRequests}`);

  if (stats.totalRequests > 0) {
    console.log(`Success rate: ${stats.getSuccessRate().toFixed(2)}%`);

    if (stats.successfulRequests > 0) {
      console.log(
        `Average processing time: ${stats.getAverageProcessingTime().toFixed(2)}ms`,
      );
    }

    console.log(
      `Throughput: ${stats.getThroughput(totalTestTime).toFixed(2)} requests/second`,
    );
  }

  // Show first few errors if any
  if (stats.errorMessages.length > 0) {
    console.log('\nFirst few errors:');
    const errorCount = Math.min(5, stats.errorMessages.length);
    for (let i = 0; i < errorCount; i++) {
      console.log(`  ${stats.errorMessages[i]}`);
    }
    if (stats.errorMessages.length > 5) {
      console.log(`  ... and ${stats.errorMessages.length - 5} more errors`);
    }
  }

  // Show aggregated statistics for successful requests
  const successfulResults = results.filter((r) => r.success);
  if (successfulResults.length > 0) {
    console.log(
      `\nAggregated statistics for ${successfulResults.length} successful requests:`,
    );

    const durations = successfulResults.map((r: any) => r.duration);
    const textLengths = successfulResults.map((r: any) => r.textLength);

    // Calculate statistics
    const minDuration = Math.min(...durations);
    const maxDuration = Math.max(...durations);
    const avgDuration = durations.reduce((a, b) => a + b, 0) / durations.length;

    const minTextLength = Math.min(...textLengths);
    const maxTextLength = Math.max(...textLengths);
    const avgTextLength =
      textLengths.reduce((a, b) => a + b, 0) / textLengths.length;

    console.log(
      `  Processing time: min=${minDuration}ms, max=${maxDuration}ms, avg=${avgDuration.toFixed(1)}ms`,
    );
    console.log(
      `  Text length: min=${minTextLength}, max=${maxTextLength}, avg=${avgTextLength.toFixed(1)} chars`,
    );

    // Show first 3 and last 3 results as examples
    if (successfulResults.length >= 3) {
      console.log('\nFirst 3 successful requests:');
      successfulResults.slice(0, 3).forEach((result: any) => {
        const preview =
          result.reversedText.length > 50
            ? result.reversedText.substring(0, 47) + '...'
            : result.reversedText;
        console.log(
          `  Thread ${result.threadId} Request ${result.requestIndex}: ${result.duration}ms, "${preview}"`,
        );
      });

      if (successfulResults.length > 3) {
        console.log('Last 3 successful requests:');
        successfulResults.slice(-3).forEach((result: any) => {
          const preview =
            result.reversedText.length > 50
              ? result.reversedText.substring(0, 47) + '...'
              : result.reversedText;
          console.log(
            `  Thread ${result.threadId} Request ${result.requestIndex}: ${result.duration}ms, "${preview}"`,
          );
        });
      }
    } else {
      // For very small result sets, show all results
      console.log('\nAll successful requests:');
      successfulResults.forEach((result: any) => {
        const preview =
          result.reversedText.length > 50
            ? result.reversedText.substring(0, 47) + '...'
            : result.reversedText;
        console.log(
          `  Thread ${result.threadId} Request ${result.requestIndex}: ${result.duration}ms, "${preview}"`,
        );
      });
    }

    // Show a sample of original vs reversed text
    if (successfulResults.length > 0) {
      const sample = successfulResults[0];
      console.log(
        `\nSample transformation:\n  Original: "${sample.originalText}"\n  Reversed: "${sample.reversedText}"`,
      );
    }
  }
}

function parseArgs(): {
  text: string;
  apiKey: string;
  threads: number;
  requestsPerThread: number;
  config: string;
} {
  const argv = minimist(process.argv.slice(2));

  if (argv.help) {
    console.log(usage);
    process.exit(0);
  }

  const text = argv._?.join(' ') || '';
  // Use fake API key since this is a local custom node test
  const apiKey =
    process.env.INWORLD_API_KEY || 'fake-api-key-for-custom-node-testing';

  // Support both old --runs parameter and new --threads parameter for backwards compatibility
  const threads = parseInt(argv.threads) || parseInt(argv.runs) || 1;
  const requestsPerThread = parseInt(argv.requests_per_thread) || 1;
  const config = argv.config || 'fast';

  if (!text) {
    throw new Error(`You need to provide text.\\n${usage}`);
  }

  if (threads < 1) {
    throw new Error(`Threads must be at least 1.\\n${usage}`);
  }

  if (requestsPerThread < 1) {
    throw new Error(`Requests per thread must be at least 1.\\n${usage}`);
  }

  // Validate config
  if (!['fast', 'medium', 'slow', 'cpu-intensive'].includes(config)) {
    throw new Error(
      `Invalid config '${config}'. Use: fast, medium, slow, or cpu-intensive.\\n${usage}`,
    );
  }

  return { text, apiKey, threads, requestsPerThread, config };
}
