import 'dotenv/config';

const minimist = require('minimist');

import {
  CustomNode,
  FakeTTSComponent,
  GraphBuilder,
  GraphTypes,
  ProcessContext,
  RemoteTTSNode,
} from '@inworld/runtime/graph';

import { DEFAULT_VOICE_ID, SAMPLE_RATE } from './constants';

const usage = `
Usage:
    yarn node-two-node-tts-load-test "Hello, how can I help you?" \\n
    --voiceName=<voice-id>[optional, ${DEFAULT_VOICE_ID} will be used by default] \\n
    --threads=<number>[optional, 1 will be used by default - number of concurrent operations] \\n
    --requests_per_thread=<number>[optional, 1 will be used by default - requests each thread makes] \\n
    --config=<config>[optional, fast/medium/slow/cpu-intensive - fast will be used by default] \\n
    
Note: This uses FakeTTSComponent for load testing (no real TTS API calls or API key required)
Architecture: RemoteTTSNode -> CustomStreamReaderNode (2-node pipeline)
Total requests = threads × requests_per_thread
Execution: Event loop concurrency with async operations

Timing Metrics:
  • Graph initialization: One-time setup cost (components, connections, validation)
  • Request processing: Recurring cost per request (TTS + custom processing)
  • In production: Initialize once, process many requests (amortized init cost)
  
Workload Configurations:
  fast          - Light I/O delays (~120ms/request)
  medium        - Heavy I/O delays (~2200ms/request)  
  slow          - Very heavy I/O delays (~25s/request)
  cpu-intensive - Minimal delays, more chunks`;

// Custom node that processes TTS output stream
class CustomStreamReaderNode extends CustomNode {
  async process(
    _context: ProcessContext,
    input: GraphTypes.TTSOutputStream,
  ): Promise<{
    initialText: string;
    audioDataLength: number;
    chunkCount: number;
  }> {
    let initialText = '';
    let allAudioData: number[] = [];
    let chunkCount = 0;

    console.log('=== CustomStreamReaderNode::process', input);
    for await (const chunk of input) {
      console.log('=== CustomStreamReaderNode::process chunk');
      if (chunk.text) initialText += chunk.text;
      if (chunk.audio?.data) {
        allAudioData = allAudioData.concat(Array.from(chunk.audio.data));
      }
      chunkCount++;
    }

    console.log('=== CustomStreamReaderNode:: returning', allAudioData.length);
    return {
      initialText,
      audioDataLength: allAudioData.length,
      chunkCount,
    };
  }
}

// Thread-safe statistics collection
class LoadTestStats {
  totalRequests = 0;
  successfulRequests = 0;
  failedRequests = 0;
  totalProcessingTimeMs = 0;
  errorMessages: string[] = [];

  addRequest() {
    this.totalRequests++;
  }

  addSuccessfulRequest(processingTimeMs: number) {
    this.successfulRequests++;
    this.totalProcessingTimeMs += processingTimeMs;
  }

  addFailedRequest(errorMessage: string) {
    this.failedRequests++;
    this.errorMessages.push(errorMessage);
  }

  getSuccessRate(): number {
    return this.totalRequests > 0
      ? (this.successfulRequests / this.totalRequests) * 100
      : 0;
  }

  getAverageProcessingTime(): number {
    return this.successfulRequests > 0
      ? this.totalProcessingTimeMs / this.successfulRequests
      : 0;
  }

  getThroughput(totalTestTimeMs: number): number {
    return totalTestTimeMs > 0
      ? (this.totalRequests / totalTestTimeMs) * 1000
      : 0; // requests per second
  }
}

// Configuration presets matching the original load test
function getLoadTestConfig(configName: string) {
  switch (configName) {
    case 'fast':
      return {
        firstChunkDelayMs: 20, // I/O-bound: mostly delays
        sampleRate: SAMPLE_RATE,
        errorProbability: 0.0,
        chunksPerRequest: 10,
        interChunkDelayMs: 10, // Total delay: ~120ms per request
        collectMetrics: true,
      };
    case 'medium':
      return {
        firstChunkDelayMs: 200, // I/O-bound: heavy delays
        sampleRate: SAMPLE_RATE,
        errorProbability: 0.0,
        chunksPerRequest: 20,
        interChunkDelayMs: 100, // Total delay: ~2200ms per request
        collectMetrics: true,
      };
    case 'slow':
      return {
        firstChunkDelayMs: 800, // I/O-bound: very heavy delays
        sampleRate: 22050,
        errorProbability: 0.0,
        chunksPerRequest: 50,
        interChunkDelayMs: 500, // Total delay: ~25800ms per request
        collectMetrics: true,
      };
    case 'cpu-intensive':
      return {
        firstChunkDelay: 1, // Minimal delays
        sampleRate: SAMPLE_RATE,
        errorProbability: 0.0,
        chunksPerRequest: 100, // Many chunks = more CPU work
        interChunkDelay: 1, // Minimal delays
        collectMetrics: true,
      };
    default:
      throw new Error(
        `Invalid config '${configName}'. Use: fast, medium, slow, or cpu-intensive`,
      );
  }
}

// Main execution
run().catch((error) => {
  console.error('Main execution error:', error);
  process.exit(1);
});

async function run() {
  const { text, voiceName, apiKey, threads, requestsPerThread, config } =
    parseArgs();

  console.log('\n=== Two-Node Concurrent TTS Load Test ===');
  console.log(`Architecture: RemoteTTSNode -> CustomStreamReaderNode`);
  console.log(`Configuration: ${config}`);
  console.log(`Threads: ${threads}`);
  console.log(`Requests per thread: ${requestsPerThread}`);
  console.log(`Total requests: ${threads * requestsPerThread}`);
  console.log(`Text: "${text}"`);

  await runAsyncMode({
    text,
    voiceName,
    apiKey,
    threads,
    requestsPerThread,
    config,
  });
}

async function runAsyncMode({
  text,
  voiceName,
  apiKey,
  threads,
  requestsPerThread,
  config,
}: {
  text: string;
  voiceName: string;
  apiKey: string;
  threads: number;
  requestsPerThread: number;
  config: string;
}) {
  // Initialize statistics tracking
  const stats = new LoadTestStats();
  const totalRequests = threads * requestsPerThread;

  // Warn about very high concurrent operations
  if (totalRequests > 1000) {
    console.log(
      `⚠️  Warning: ${totalRequests} total requests in async mode may cause high memory usage.`,
    );
  }

  const initStartTime = Date.now();

  const loadTestConfig = getLoadTestConfig(config);

  const ttsComponent = new FakeTTSComponent({
    id: 'tts-component-two-node-async',
    loadTestConfig,
  });

  const ttsNode = new RemoteTTSNode({
    id: 'tts-node-two-node-async',
    ttsComponent,
    speakerId: voiceName,
    sampleRate: loadTestConfig.sampleRate,
  });

  const customNode = new CustomStreamReaderNode({
    id: 'custom-stream-reader-node',
  });

  const graph = new GraphBuilder({
    id: 'two_node_tts_graph_async',
    apiKey,
    enableRemoteConfig: false,
  })
    .addComponent(ttsComponent)
    .addNode(ttsNode)
    .addNode(customNode)
    .addEdge(ttsNode, customNode)
    .setStartNode(ttsNode)
    .setEndNode(customNode)
    .build();

  const initEndTime = Date.now();
  const initializationTime = initEndTime - initStartTime;

  console.log(
    `✅ Two-node graph ready - ONE instance will handle all requests`,
  );
  console.log(`⏱️  Graph initialization time: ${initializationTime}ms`);

  console.log('Starting async two-node load test...');
  const testStartTime = Date.now();

  // Create worker thread promises
  const workerPromises = Array.from(
    { length: threads },
    async (_, threadIndex) => {
      const threadId = threadIndex + 1;
      const workerResults: any[] = [];

      // Each worker makes multiple requests
      for (
        let requestIndex = 0;
        requestIndex < requestsPerThread;
        requestIndex++
      ) {
        const globalRequestNumber = threadId * 1000 + requestIndex + 1; // Unique request ID
        stats.addRequest();

        try {
          const startTime = Date.now();

          const { outputStream } = await graph.start(text);
          const result = await outputStream.next();
          let processedData: any = null;

          await result.processResponse({
            Custom: (data: any) => {
              processedData = data as {
                initialText: string;
                audioDataLength: number;
                chunkCount: number;
              };
            },
            default: (data) => {
              console.log('Unprocessed data:', data);
            },
          });

          const endTime = Date.now();
          const duration = endTime - startTime;

          // Check if the request was successful
          if (
            processedData &&
            processedData.audioDataLength > 0 &&
            processedData.chunkCount > 0
          ) {
            stats.addSuccessfulRequest(duration);

            // Only create audio files for successful requests (limit file creation for large tests)
            let outputPath: string | undefined;
            if (totalRequests <= 10) {
              // For small tests, we could generate audio files, but since we only have audioDataLength,
              // we'll skip file generation and just report the metrics
              outputPath = `Would generate: node_two_node_tts_output_t${threadId}_r${requestIndex + 1}.wav`;
            }

            workerResults.push({
              threadId,
              requestIndex: requestIndex + 1,
              globalRequestNumber,
              success: true,
              duration,
              chunkCount: processedData.chunkCount,
              audioDataLength: processedData.audioDataLength,
              outputPath,
              initialText: processedData.initialText,
            });
          } else {
            const errorMsg = `Thread ${threadId} Request ${requestIndex + 1}: No data processed (chunkCount: ${processedData?.chunkCount || 0}, audioLength: ${processedData?.audioDataLength || 0})`;
            stats.addFailedRequest(errorMsg);

            workerResults.push({
              threadId,
              requestIndex: requestIndex + 1,
              globalRequestNumber,
              success: false,
              duration,
              chunkCount: processedData?.chunkCount || 0,
              audioDataLength: processedData?.audioDataLength || 0,
              error: errorMsg,
            });
          }
        } catch (error) {
          const errorMsg = `Thread ${threadId} Request ${requestIndex + 1}: Exception: ${error instanceof Error ? error.message : String(error)}`;
          stats.addFailedRequest(errorMsg);

          workerResults.push({
            threadId,
            requestIndex: requestIndex + 1,
            globalRequestNumber,
            success: false,
            error: errorMsg,
          });
        }
      }

      return workerResults;
    },
  );

  // Wait for all worker threads to complete
  const workerResults = await Promise.all(workerPromises);

  // Flatten all results from all workers
  const results = workerResults.flat();

  const testEndTime = Date.now();
  const totalTestTime = testEndTime - testStartTime;

  // Print comprehensive results
  console.log('\n=== Two-Node Load Test Results ===');
  console.log(
    `Graph initialization time: ${initializationTime}ms (one-time cost)`,
  );
  console.log(
    `Request processing time: ${totalTestTime}ms (${totalRequests} requests)`,
  );
  console.log(
    `Total time (init + requests): ${initializationTime + totalTestTime}ms`,
  );
  console.log(`Total requests: ${stats.totalRequests}`);
  console.log(`Successful requests: ${stats.successfulRequests}`);
  console.log(`Failed requests: ${stats.failedRequests}`);

  if (stats.totalRequests > 0) {
    console.log(`Success rate: ${stats.getSuccessRate().toFixed(2)}%`);

    if (stats.successfulRequests > 0) {
      console.log(
        `Average processing time: ${stats.getAverageProcessingTime().toFixed(2)}ms`,
      );
    }

    console.log(
      `Throughput: ${stats.getThroughput(totalTestTime).toFixed(2)} requests/second`,
    );
  }

  // Show first few errors if any
  if (stats.errorMessages.length > 0) {
    console.log('\nFirst few errors:');
    const errorCount = Math.min(5, stats.errorMessages.length);
    for (let i = 0; i < errorCount; i++) {
      console.log(`  ${stats.errorMessages[i]}`);
    }
    if (stats.errorMessages.length > 5) {
      console.log(`  ... and ${stats.errorMessages.length - 5} more errors`);
    }
  }

  // Show aggregated statistics for successful requests
  const successfulResults = results.filter((r) => r.success);
  if (successfulResults.length > 0) {
    console.log(
      `\nAggregated statistics for ${successfulResults.length} successful requests:`,
    );

    const durations = successfulResults.map((r: any) => r.duration);
    const chunkCounts = successfulResults.map((r: any) => r.chunkCount);
    const audioDataLengths = successfulResults.map(
      (r: any) => r.audioDataLength,
    );

    // Calculate statistics
    const minDuration = Math.min(...durations);
    const maxDuration = Math.max(...durations);
    const avgDuration = durations.reduce((a, b) => a + b, 0) / durations.length;

    const minChunks = Math.min(...chunkCounts);
    const maxChunks = Math.max(...chunkCounts);
    const avgChunks =
      chunkCounts.reduce((a, b) => a + b, 0) / chunkCounts.length;

    const minAudioLength = Math.min(...audioDataLengths);
    const maxAudioLength = Math.max(...audioDataLengths);
    const avgAudioLength =
      audioDataLengths.reduce((a, b) => a + b, 0) / audioDataLengths.length;

    console.log(
      `  Processing time: min=${minDuration}ms, max=${maxDuration}ms, avg=${avgDuration.toFixed(1)}ms`,
    );
    console.log(
      `  Chunks per run: min=${minChunks}, max=${maxChunks}, avg=${avgChunks.toFixed(1)}`,
    );
    console.log(
      `  Audio samples: min=${minAudioLength}, max=${maxAudioLength}, avg=${avgAudioLength.toFixed(0)}`,
    );

    // Show first 3 and last 3 results as examples
    if (successfulResults.length >= 3) {
      console.log('\nFirst 3 successful requests:');
      successfulResults.slice(0, 3).forEach((result: any) => {
        console.log(
          `  Thread ${result.threadId} Request ${result.requestIndex}: ${result.duration}ms, ${result.chunkCount} chunks, ${result.audioDataLength} samples`,
        );
      });

      if (successfulResults.length > 3) {
        console.log('Last 3 successful requests:');
        successfulResults.slice(-3).forEach((result: any) => {
          console.log(
            `  Thread ${result.threadId} Request ${result.requestIndex}: ${result.duration}ms, ${result.chunkCount} chunks, ${result.audioDataLength} samples`,
          );
        });
      }
    } else {
      // For very small result sets, show all results
      console.log('\nAll successful requests:');
      successfulResults.forEach((result: any) => {
        console.log(
          `  Thread ${result.threadId} Request ${result.requestIndex}: ${result.duration}ms, ${result.chunkCount} chunks, ${result.audioDataLength} samples`,
        );
      });
    }
  }
}

function parseArgs(): {
  text: string;
  voiceName: string;
  apiKey: string;
  threads: number;
  requestsPerThread: number;
  config: string;
} {
  const argv = minimist(process.argv.slice(2));

  if (argv.help) {
    console.log(usage);
    process.exit(0);
  }

  const text = argv._?.join(' ') || '';
  const voiceName = argv.voiceName || DEFAULT_VOICE_ID;
  // Use fake API key for load testing since FakeTTSComponent doesn't make real API calls
  const apiKey = process.env.INWORLD_API_KEY || 'fake-api-key-for-load-testing';

  // Support both old --runs parameter and new --threads parameter for backwards compatibility
  const threads = parseInt(argv.threads) || parseInt(argv.runs) || 1;
  const requestsPerThread = parseInt(argv.requests_per_thread) || 1;
  const config = argv.config || 'fast';

  if (!text) {
    throw new Error(`You need to provide text.\\n${usage}`);
  }

  if (threads < 1) {
    throw new Error(`Threads must be at least 1.\\n${usage}`);
  }

  if (requestsPerThread < 1) {
    throw new Error(`Requests per thread must be at least 1.\\n${usage}`);
  }

  // Validate config
  if (!['fast', 'medium', 'slow', 'cpu-intensive'].includes(config)) {
    throw new Error(
      `Invalid config '${config}'. Use: fast, medium, slow, or cpu-intensive.\\n${usage}`,
    );
  }

  return { text, voiceName, apiKey, threads, requestsPerThread, config };
}
