import {
  GraphOutputStream,
  RemoteLLMCompletionNode,
  RemoteTTSNode,
  SequentialGraphBuilder,
  TextChunkingNode,
} from '@inworld/runtime/graph';

main();

async function main() {
  const llmNode = new RemoteLLMCompletionNode({
    textGenerationConfig: {
      maxNewTokens: 50,
    },
    stream: true,
  });

  const graph = new SequentialGraphBuilder({
    id: 'test-graph',
    nodes: [llmNode, new TextChunkingNode(), new RemoteTTSNode()],
  }).build();

  let executionCount = 0;

  // Function to process a stream
  const processStream = async (stream: GraphOutputStream) => {
    await stream.next().then(async (response) => {
      await response.processResponse({
        TTSOutputStream: async (stream) => {
          for await (const _chunk of stream) {
            process.stdout.write('Processing chunk... \n');
          }
        },
      });
    });
  };

  // Add 10 new executions every second continuously
  setInterval(() => {
    console.log(
      `\n--- Adding 10 new executions (total: ${executionCount + 10}) ---`,
    );

    for (let i = 0; i < 10; i++) {
      executionCount++;
      console.log('start execution', executionCount);
      const { outputStream } = graph.start('Hello, world!');

      // Process each stream asynchronously without blocking
      processStream(outputStream).catch((error) => {
        console.error(`Error processing execution ${executionCount}:`, error);
      });
    }
  }, 1000); // Every 1000ms (1 second)

  // Keep the process running
  console.log('Started continuous execution scheduler. Press Ctrl+C to stop.');
}
