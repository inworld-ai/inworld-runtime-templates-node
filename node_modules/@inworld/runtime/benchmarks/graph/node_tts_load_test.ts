import 'dotenv/config';

import * as fs from 'fs';
import * as path from 'path';

const minimist = require('minimist');
const wavEncoder = require('wav-encoder');

import {
  FakeTTSComponent,
  GraphBuilder,
  GraphTypes,
  RemoteTTSNode,
} from '@inworld/runtime/graph';

import {
  DEFAULT_TTS_MODEL_ID,
  DEFAULT_VOICE_ID,
  SAMPLE_RATE,
} from './constants';

const OUTPUT_DIRECTORY = path.join(
  __dirname,
  '..',
  '..',
  'data-output',
  'tts_samples',
);

const usage = `
Usage:
    yarn node-tts-load-test "Hello, how can I help you?" \\n
    --mode=<mode>[optional, fake/real - fake will be used by default] \\n
    --voiceName=<voice-id>[optional, ${DEFAULT_VOICE_ID} will be used by default] \\n
    --modelId=<model-id>[optional for real mode, ${DEFAULT_TTS_MODEL_ID} will be used by default] \\n
    --threads=<number>[optional, 1 will be used by default - number of concurrent operations] \\n
    --requests_per_thread=<number>[optional, 1 will be used by default - requests each thread makes] \\n
    --config=<config>[optional, fast/medium/slow/cpu-intensive - fast will be used by default] \\n
    
Modes:
  fake - Uses FakeTTSComponent for load testing (no real TTS API calls, no API key required)
  real - Uses actual TTS API calls (requires INWORLD_API_KEY environment variable)

Total requests = threads Ã— requests_per_thread
Execution: Event loop concurrency with async operations

Timing Metrics:
  â€¢ Graph initialization: One-time setup cost (components, connections, validation)
  â€¢ Request processing: Recurring cost per request (actual TTS processing)
  â€¢ In production: Initialize once, process many requests (amortized init cost)
  
Workload Configurations (only applies to fake mode):
  fast          - Light I/O delays (~120ms/request)
  medium        - Heavy I/O delays (~2200ms/request)  
  slow          - Very heavy I/O delays (~25s/request)
  cpu-intensive - Minimal delays, more chunks`;

// Statistics collection that accumulates all metrics on the fly
class LoadTestStats {
  totalRequests = 0;
  successfulRequests = 0;
  failedRequests = 0;
  totalProcessingTimeMs = 0;
  errorMessages: string[] = [];

  // Metrics tracked on the fly
  minDuration = Infinity;
  maxDuration = -Infinity;
  minChunks = Infinity;
  maxChunks = -Infinity;
  totalChunks = 0;
  minAudioLength = Infinity;
  maxAudioLength = -Infinity;
  totalAudioLength = 0;

  addRequest() {
    this.totalRequests++;
  }

  addSuccessfulRequest(
    processingTimeMs: number,
    threadId: number,
    requestIndex: number,
    resultCount: number,
    audioDataLength: number,
  ) {
    this.successfulRequests++;
    this.totalProcessingTimeMs += processingTimeMs;

    // Update min/max metrics
    this.minDuration = Math.min(this.minDuration, processingTimeMs);
    this.maxDuration = Math.max(this.maxDuration, processingTimeMs);
    this.minChunks = Math.min(this.minChunks, resultCount);
    this.maxChunks = Math.max(this.maxChunks, resultCount);
    this.totalChunks += resultCount;
    this.minAudioLength = Math.min(this.minAudioLength, audioDataLength);
    this.maxAudioLength = Math.max(this.maxAudioLength, audioDataLength);
    this.totalAudioLength += audioDataLength;
  }

  addFailedRequest(errorMessage: string) {
    this.failedRequests++;
    this.errorMessages.push(errorMessage);
  }

  getSuccessRate(): number {
    return this.totalRequests > 0
      ? (this.successfulRequests / this.totalRequests) * 100
      : 0;
  }

  getAverageProcessingTime(): number {
    return this.successfulRequests > 0
      ? this.totalProcessingTimeMs / this.successfulRequests
      : 0;
  }

  getAverageChunks(): number {
    return this.successfulRequests > 0
      ? this.totalChunks / this.successfulRequests
      : 0;
  }

  getAverageAudioLength(): number {
    return this.successfulRequests > 0
      ? this.totalAudioLength / this.successfulRequests
      : 0;
  }

  getThroughput(totalTestTimeMs: number): number {
    return totalTestTimeMs > 0
      ? (this.totalRequests / totalTestTimeMs) * 1000
      : 0; // requests per second
  }

  hasDetailedStats(): boolean {
    return this.successfulRequests > 0 && this.minDuration !== Infinity;
  }
}

// Configuration presets matching C++ version
function getLoadTestConfig(configName: string) {
  switch (configName) {
    case 'fast':
      return {
        firstChunkDelayMs: 20, // I/O-bound: mostly delays
        sampleRate: SAMPLE_RATE,
        errorProbability: 0.0,
        chunksPerRequest: 10,
        interChunkDelayMs: 10, // Total delay: ~120ms per request
        collectMetrics: true,
      };
    case 'medium':
      return {
        firstChunkDelayMs: 200, // I/O-bound: heavy delays
        sampleRate: SAMPLE_RATE,
        errorProbability: 0.0, // 2% error rate
        chunksPerRequest: 20,
        interChunkDelayMs: 100, // Total delay: ~2200ms per request
        collectMetrics: true,
      };
    case 'slow':
      return {
        firstChunkDelayMs: 800, // I/O-bound: very heavy delays
        sampleRate: 22050,
        errorProbability: 0.0, // 15% error rate
        chunksPerRequest: 50,
        interChunkDelayMs: 500, // Total delay: ~25800ms per request
        collectMetrics: true,
      };
    case 'cpu-intensive':
      // Hypothetical CPU-bound config (for comparison)
      return {
        firstChunkDelay: 1, // Minimal delays
        sampleRate: SAMPLE_RATE,
        errorProbability: 0.0,
        chunksPerRequest: 100, // Many chunks = more CPU work
        interChunkDelay: 1, // Minimal delays
        collectMetrics: true,
      };
    default:
      throw new Error(
        `Invalid config '${configName}'. Use: fast, medium, slow, or cpu-intensive`,
      );
  }
}

// Main execution - async mode only
run().catch((error) => {
  console.error('Main execution error:', error);
  process.exit(1);
});

async function run() {
  const {
    text,
    mode,
    modelId,
    voiceName,
    apiKey,
    threads,
    requestsPerThread,
    config,
  } = parseArgs();

  console.log('\n=== Concurrent TTS Load Test ===');
  console.log(`Mode: ${mode}`);
  console.log(`Configuration: ${config}`);
  console.log(`Threads: ${threads}`);
  console.log(
    `Requests per thread: ${requestsPerThread === -1 ? 'infinite (Ctrl+C to stop)' : requestsPerThread}`,
  );
  if (requestsPerThread === -1) {
    console.log(`Total requests: infinite (Ctrl+C to stop)`);
  } else {
    console.log(`Total requests: ${threads * requestsPerThread}`);
  }
  console.log(`Text: "${text}"`);
  if (mode === 'real') {
    console.log(`Model ID: ${modelId}`);
    console.log(`Voice Name: ${voiceName}`);
  }

  await runAsyncMode({
    text,
    mode,
    modelId,
    voiceName,
    apiKey,
    threads,
    requestsPerThread,
    config,
  });
}

async function runAsyncMode({
  text,
  mode,
  modelId,
  voiceName,
  apiKey,
  threads,
  requestsPerThread,
  config,
}: {
  text: string;
  mode: string;
  modelId: string;
  voiceName: string;
  apiKey: string;
  threads: number;
  requestsPerThread: number;
  config: string;
}) {
  // Initialize statistics tracking
  const stats = new LoadTestStats();
  const isInfiniteMode = requestsPerThread === -1;
  const totalRequests = isInfiniteMode ? Infinity : threads * requestsPerThread;

  // Memory optimization: No result objects stored - all metrics tracked on the fly
  console.log(
    `ðŸ”§ Memory optimized: Statistics collected on-the-fly (no result objects stored)`,
  );

  // Flag to handle graceful shutdown
  let shouldStop = false;

  // Set up Ctrl+C handler for infinite mode
  if (isInfiniteMode) {
    console.log(
      '\nâš ï¸  Running in infinite mode. Press Ctrl+C to stop gracefully...',
    );

    process.on('SIGINT', () => {
      console.log(
        '\nðŸ›‘ Stopping gracefully... (press Ctrl+C again to force quit)',
      );
      shouldStop = true;

      // Force quit if pressed twice
      process.once('SIGINT', () => {
        console.log('\nðŸ’¥ Force quitting...');
        process.exit(1);
      });
    });
  }

  // Warn about very high concurrent operations (skip for infinite mode)
  if (!isInfiniteMode && totalRequests > 1000) {
    console.log(
      `âš ï¸  Warning: ${totalRequests} total requests in async mode may cause high memory usage.`,
    );
  }

  const initStartTime = Date.now();

  let ttsNode: RemoteTTSNode;
  let ttsComponent: FakeTTSComponent | undefined;

  if (mode === 'fake') {
    const loadTestConfig = getLoadTestConfig(config);

    ttsComponent = new FakeTTSComponent({
      id: 'tts-component-async',
      loadTestConfig,
    });

    ttsNode = new RemoteTTSNode({
      id: 'tts-node-async',
      ttsComponent,
      speakerId: voiceName,
      sampleRate: loadTestConfig.sampleRate,
    });
  } else {
    // Real mode - create TTS node without fake component (like in node_tts.ts)
    ttsNode = new RemoteTTSNode({
      id: 'tts-node-async',
      speakerId: voiceName,
      modelId,
      sampleRate: SAMPLE_RATE,
      temperature: 0.8,
      speakingRate: 1,
    });
  }

  const graph = new GraphBuilder({
    id: 'node_tts_graph_async',
    apiKey,
    enableRemoteConfig: false,
  })
    .addNode(ttsNode)
    .setStartNode(ttsNode)
    .setEndNode(ttsNode)
    .build();

  const initEndTime = Date.now();
  const initializationTime = initEndTime - initStartTime;

  console.log(`âœ… Graph ready - ONE instance will handle all requests`);
  console.log(`â±ï¸  Graph initialization time: ${initializationTime}ms`);

  console.log('Starting async load test...');
  const testStartTime = Date.now();

  // Create worker thread promises
  const workerPromises = Array.from(
    { length: threads },
    async (_, threadIndex) => {
      const threadId = threadIndex + 1;

      // Each worker makes multiple requests
      for (
        let requestIndex = 0;
        requestsPerThread === -1
          ? !shouldStop
          : requestIndex < requestsPerThread;
        requestIndex++
      ) {
        stats.addRequest();

        try {
          const startTime = Date.now();

          const { outputStream } = await graph.start(text);
          const {
            initialText: _initialText,
            resultCount,
            allAudioData,
          } = await processTTSStream(outputStream);

          const endTime = Date.now();
          const duration = endTime - startTime;

          // Check if the request was successful (has audio data)
          if (allAudioData.length > 0 && resultCount > 0) {
            stats.addSuccessfulRequest(
              duration,
              threadId,
              requestIndex + 1,
              resultCount,
              allAudioData.length,
            );

            // Only create audio files for successful requests (limit file creation for large tests)
            let outputPath: string | undefined;
            if (totalRequests <= 10) {
              const sampleRate =
                mode === 'fake'
                  ? getLoadTestConfig(config).sampleRate
                  : SAMPLE_RATE;
              const audio = {
                sampleRate,
                channelData: [new Float32Array(allAudioData)],
              };

              const buffer = await wavEncoder.encode(audio);
              if (!fs.existsSync(OUTPUT_DIRECTORY)) {
                fs.mkdirSync(OUTPUT_DIRECTORY, { recursive: true });
              }

              outputPath = path.join(
                OUTPUT_DIRECTORY,
                `node_tts_output_t${threadId}_r${requestIndex + 1}.wav`,
              );
              fs.writeFileSync(outputPath, Buffer.from(buffer));
            }
          } else {
            const errorMsg = `Thread ${threadId} Request ${requestIndex + 1}: No audio data generated (resultCount: ${resultCount}, audioLength: ${allAudioData.length})`;
            stats.addFailedRequest(errorMsg);
          }
        } catch (error) {
          const errorMsg = `Thread ${threadId} Request ${requestIndex + 1}: Exception: ${error instanceof Error ? error.message : String(error)}`;
          stats.addFailedRequest(errorMsg);
        }
      }
    },
  );

  // Wait for all worker threads to complete
  await Promise.all(workerPromises);

  const testEndTime = Date.now();
  const totalTestTime = testEndTime - testStartTime;

  // Print comprehensive results like C++ version
  console.log('\n=== Load Test Results ===');
  console.log(
    `Graph initialization time: ${initializationTime}ms (one-time cost)`,
  );
  console.log(
    `Request processing time: ${totalTestTime}ms${isInfiniteMode ? ' (until stopped)' : ` (${stats.totalRequests} requests)`}`,
  );
  console.log(
    `Total time (init + requests): ${initializationTime + totalTestTime}ms`,
  );
  console.log(`Total requests: ${stats.totalRequests}`);
  console.log(`Successful requests: ${stats.successfulRequests}`);
  console.log(`Failed requests: ${stats.failedRequests}`);

  if (stats.totalRequests > 0) {
    console.log(`Success rate: ${stats.getSuccessRate().toFixed(2)}%`);

    if (stats.successfulRequests > 0) {
      console.log(
        `Average processing time: ${stats.getAverageProcessingTime().toFixed(2)}ms`,
      );
    }

    console.log(
      `Throughput: ${stats.getThroughput(totalTestTime).toFixed(2)} requests/second`,
    );
  }

  // Show first few errors if any
  if (stats.errorMessages.length > 0) {
    console.log('\nFirst few errors:');
    const errorCount = Math.min(5, stats.errorMessages.length);
    for (let i = 0; i < errorCount; i++) {
      console.log(`  ${stats.errorMessages[i]}`);
    }
    if (stats.errorMessages.length > 5) {
      console.log(`  ... and ${stats.errorMessages.length - 5} more errors`);
    }
  }

  // Show aggregated statistics for successful requests
  if (stats.hasDetailedStats()) {
    console.log(
      `\nAggregated statistics for ${stats.successfulRequests} successful requests:`,
    );

    console.log(
      `  Processing time: min=${stats.minDuration}ms, max=${stats.maxDuration}ms, avg=${stats.getAverageProcessingTime().toFixed(1)}ms`,
    );
    console.log(
      `  Chunks per run: min=${stats.minChunks}, max=${stats.maxChunks}, avg=${stats.getAverageChunks().toFixed(1)}`,
    );
    console.log(
      `  Audio samples: min=${stats.minAudioLength}, max=${stats.maxAudioLength}, avg=${stats.getAverageAudioLength().toFixed(0)}`,
    );

    // Aggregate statistics only - no individual request examples stored
  }

  console.log(
    '\nâœ… Maximum memory efficiency: Zero result storage, pure streaming statistics',
  );
}

async function processTTSStream(outputStream: AsyncIterable<any>) {
  let initialText = '';
  let resultCount = 0;
  let allAudioData: number[] = [];

  for await (const result of outputStream) {
    await result.processResponse({
      TTSOutputStream: async (ttsStream: GraphTypes.TTSOutputStream) => {
        for await (const chunk of ttsStream) {
          if (chunk.text) initialText += chunk.text;
          if (chunk.audio?.data) {
            allAudioData.push(...chunk.audio.data);
          }
          resultCount++;
        }
        //console.log(`All audio data length: ${allAudioData.length}`);
      },
    });
  }

  return { initialText, resultCount, allAudioData };
}

function parseArgs(): {
  text: string;
  mode: string;
  modelId: string;
  voiceName: string;
  apiKey: string;
  threads: number;
  requestsPerThread: number;
  config: string;
} {
  const argv = minimist(process.argv.slice(2));

  if (argv.help) {
    console.log(usage);
    process.exit(0);
  }

  const text = argv._?.join(' ') || '';
  const mode = argv.mode || 'fake';
  const modelId = argv.modelId || DEFAULT_TTS_MODEL_ID;
  const voiceName = argv.voiceName || DEFAULT_VOICE_ID;

  // API key handling depends on mode
  let apiKey: string;
  if (mode === 'real') {
    apiKey = process.env.INWORLD_API_KEY || '';
    if (!apiKey) {
      throw new Error(
        `Real mode requires INWORLD_API_KEY environment variable.\\n${usage}`,
      );
    }
  } else {
    // Use fake API key for load testing since FakeTTSComponent doesn't make real API calls
    apiKey = process.env.INWORLD_API_KEY || 'fake-api-key-for-load-testing';
  }

  // Support both old --runs parameter and new --threads parameter for backwards compatibility
  const threads = parseInt(argv.threads) || parseInt(argv.runs) || 1;
  const requestsPerThread = parseInt(argv.requests_per_thread) || 1;
  const config = argv.config || 'fast';

  if (!text) {
    throw new Error(`You need to provide text.\\n${usage}`);
  }

  if (threads < 1) {
    throw new Error(`Threads must be at least 1.\\n${usage}`);
  }

  if (requestsPerThread < -1 || requestsPerThread === 0) {
    throw new Error(
      `Requests per thread must be at least 1 or -1 for infinite loop.\\n${usage}`,
    );
  }

  // Validate mode
  if (!['fake', 'real'].includes(mode)) {
    throw new Error(`Invalid mode '${mode}'. Use: fake or real.\\n${usage}`);
  }

  // Validate config (only applies to fake mode)
  if (
    mode === 'fake' &&
    !['fast', 'medium', 'slow', 'cpu-intensive'].includes(config)
  ) {
    throw new Error(
      `Invalid config '${config}'. Use: fast, medium, slow, or cpu-intensive.\\n${usage}`,
    );
  }

  // For real mode, config parameter is ignored
  if (mode === 'real' && argv.config) {
    console.log('âš ï¸  Note: --config parameter is ignored in real mode');
  }

  return {
    text,
    mode,
    modelId,
    voiceName,
    apiKey,
    threads,
    requestsPerThread,
    config,
  };
}
